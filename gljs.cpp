/* Warning: auto-generated code! */
#ifdef WIN32
#include <malloc.h>
#define alloca _alloca
#else
#include <alloca.h>
#endif

#include <nan.h>
#include <cstdio>
#include <cstdint>
#include <cstring>
#include <cmath>

#define int64 int64_t
#define int64EXT int64_t
#define intptr intptr_t
#define uintptr uintptr_t

#include <GL/glew.h>
#include <GL/gl.h>
//#include <GL/glfw.h>



NAN_METHOD(initGlew) {
  GLenum err = glewInit();
  
  if (GLEW_OK != err)
  {
    fprintf(stderr, "Error: %s\n", glewGetErrorString(err));
    return;
  }
  
  ;
}

using v8::FunctionTemplate;

            
NAN_METHOD(accum) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glAccum((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(alphaFunc) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampf");
    return;
  }
  
  GLclampf arg1 = (GLclampf)info[1]->NumberValue(ctx).ToChecked();


  glAlphaFunc((GLenum)arg0,(GLclampf)arg1);

}

      
NAN_METHOD(areTexturesResident) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  GLboolean retval = glAreTexturesResident(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(arrayElement) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glArrayElement((GLint)arg0);

}

      
NAN_METHOD(begin) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glBegin((GLenum)arg0);

}

      
NAN_METHOD(bindTexture) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindTexture((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bitmap) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  GLubyte* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLubyte*>(*arg6_tarray);
  }


  glBitmap((GLsizei)arg0,(GLsizei)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5,(const GLubyte*)arg6);

}

      
NAN_METHOD(blendFunc) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendFunc((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(callList) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glCallList((GLuint)arg0);

}

      
NAN_METHOD(callLists) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glCallLists((GLsizei)arg0,(GLenum)arg1,(const void*)arg2);

}

      
NAN_METHOD(clear) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glClear((GLbitfield)arg0);

}

      
NAN_METHOD(clearAccum) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glClearAccum((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(clearColor) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampf");
    return;
  }
  
  GLclampf arg1 = (GLclampf)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glclampf");
    return;
  }
  
  GLclampf arg2 = (GLclampf)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glclampf");
    return;
  }
  
  GLclampf arg3 = (GLclampf)info[3]->NumberValue(ctx).ToChecked();


  glClearColor((GLclampf)arg0,(GLclampf)arg1,(GLclampf)arg2,(GLclampf)arg3);

}

      
NAN_METHOD(clearDepth) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampd");
    return;
  }
  
  GLclampd arg0 = (GLclampd)info[0]->NumberValue(ctx).ToChecked();


  glClearDepth((GLclampd)arg0);

}

      
NAN_METHOD(clearIndex) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glClearIndex((GLfloat)arg0);

}

      
NAN_METHOD(clearStencil) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glClearStencil((GLint)arg0);

}

      
NAN_METHOD(clipPlane) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glClipPlane((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(color3b) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbyte");
    return;
  }
  
  GLbyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbyte");
    return;
  }
  
  GLbyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glbyte");
    return;
  }
  
  GLbyte arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glColor3b((GLbyte)arg0,(GLbyte)arg1,(GLbyte)arg2);

}

      
NAN_METHOD(color3bv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLbyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLbyte*>(*arg0_tarray);
  }


  glColor3bv((const GLbyte*)arg0);

}

      
NAN_METHOD(color3d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glColor3d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(color3dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glColor3dv((const GLdouble*)arg0);

}

      
NAN_METHOD(color3f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glColor3f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(color3fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glColor3fv((const GLfloat*)arg0);

}

      
NAN_METHOD(color3i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glColor3i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(color3iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glColor3iv((const GLint*)arg0);

}

      
NAN_METHOD(color3s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glColor3s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(color3sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glColor3sv((const GLshort*)arg0);

}

      
NAN_METHOD(color3ub) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glubyte");
    return;
  }
  
  GLubyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glubyte");
    return;
  }
  
  GLubyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glubyte");
    return;
  }
  
  GLubyte arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glColor3ub((GLubyte)arg0,(GLubyte)arg1,(GLubyte)arg2);

}

      
NAN_METHOD(color3ubv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLubyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLubyte*>(*arg0_tarray);
  }


  glColor3ubv((const GLubyte*)arg0);

}

      
NAN_METHOD(color3ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glColor3ui((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(color3uiv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }


  glColor3uiv((const GLuint*)arg0);

}

      
NAN_METHOD(color3us) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glushort");
    return;
  }
  
  GLushort arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glushort");
    return;
  }
  
  GLushort arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glushort");
    return;
  }
  
  GLushort arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glColor3us((GLushort)arg0,(GLushort)arg1,(GLushort)arg2);

}

      
NAN_METHOD(color3usv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLushort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLushort*>(*arg0_tarray);
  }


  glColor3usv((const GLushort*)arg0);

}

      
NAN_METHOD(color4b) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbyte");
    return;
  }
  
  GLbyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbyte");
    return;
  }
  
  GLbyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glbyte");
    return;
  }
  
  GLbyte arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbyte");
    return;
  }
  
  GLbyte arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glColor4b((GLbyte)arg0,(GLbyte)arg1,(GLbyte)arg2,(GLbyte)arg3);

}

      
NAN_METHOD(color4bv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLbyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLbyte*>(*arg0_tarray);
  }


  glColor4bv((const GLbyte*)arg0);

}

      
NAN_METHOD(color4d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glColor4d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(color4dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glColor4dv((const GLdouble*)arg0);

}

      
NAN_METHOD(color4f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glColor4f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(color4fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glColor4fv((const GLfloat*)arg0);

}

      
NAN_METHOD(color4i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glColor4i((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(color4iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glColor4iv((const GLint*)arg0);

}

      
NAN_METHOD(color4s) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glColor4s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(color4sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glColor4sv((const GLshort*)arg0);

}

      
NAN_METHOD(color4ub) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glubyte");
    return;
  }
  
  GLubyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glubyte");
    return;
  }
  
  GLubyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glubyte");
    return;
  }
  
  GLubyte arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glubyte");
    return;
  }
  
  GLubyte arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glColor4ub((GLubyte)arg0,(GLubyte)arg1,(GLubyte)arg2,(GLubyte)arg3);

}

      
NAN_METHOD(color4ubv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLubyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLubyte*>(*arg0_tarray);
  }


  glColor4ubv((const GLubyte*)arg0);

}

      
NAN_METHOD(color4ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glColor4ui((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(color4uiv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }


  glColor4uiv((const GLuint*)arg0);

}

      
NAN_METHOD(color4us) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glushort");
    return;
  }
  
  GLushort arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glushort");
    return;
  }
  
  GLushort arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glushort");
    return;
  }
  
  GLushort arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glushort");
    return;
  }
  
  GLushort arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glColor4us((GLushort)arg0,(GLushort)arg1,(GLushort)arg2,(GLushort)arg3);

}

      
NAN_METHOD(color4usv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLushort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLushort*>(*arg0_tarray);
  }


  glColor4usv((const GLushort*)arg0);

}

      
NAN_METHOD(colorMask) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glboolean");
    return;
  }
  
  GLboolean arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glColorMask((GLboolean)arg0,(GLboolean)arg1,(GLboolean)arg2,(GLboolean)arg3);

}

      
NAN_METHOD(colorMaterial) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glColorMaterial((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(colorPointer) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glColorPointer((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(copyPixels) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glCopyPixels((GLint)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4);

}

      
NAN_METHOD(copyTexImage1D) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glCopyTexImage1D((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLint)arg6);

}

      
NAN_METHOD(copyTexImage2D) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();


  glCopyTexImage2D((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLint)arg7);

}

      
NAN_METHOD(copyTexSubImage1D) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glCopyTexSubImage1D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(copyTexSubImage2D) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glCopyTexSubImage2D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLsizei)arg6,(GLsizei)arg7);

}

      
NAN_METHOD(cullFace) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glCullFace((GLenum)arg0);

}

      
NAN_METHOD(deleteLists) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDeleteLists((GLuint)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(deleteTextures) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteTextures((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(depthFunc) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glDepthFunc((GLenum)arg0);

}

      
NAN_METHOD(depthMask) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glboolean");
    return;
  }
  
  GLboolean arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDepthMask((GLboolean)arg0);

}

      
NAN_METHOD(depthRange) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampd");
    return;
  }
  
  GLclampd arg0 = (GLclampd)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampd");
    return;
  }
  
  GLclampd arg1 = (GLclampd)info[1]->NumberValue(ctx).ToChecked();


  glDepthRange((GLclampd)arg0,(GLclampd)arg1);

}

      
NAN_METHOD(disable) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glDisable((GLenum)arg0);

}

      
NAN_METHOD(disableClientState) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glDisableClientState((GLenum)arg0);

}

      
NAN_METHOD(drawArrays) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glDrawArrays((GLenum)arg0,(GLint)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(drawBuffer) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glDrawBuffer((GLenum)arg0);

}

      
NAN_METHOD(drawElements) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glDrawElements((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3);

}

      
NAN_METHOD(drawPixels) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glDrawPixels((GLsizei)arg0,(GLsizei)arg1,(GLenum)arg2,(GLenum)arg3,(const void*)arg4);

}

      
NAN_METHOD(edgeFlag) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glboolean");
    return;
  }
  
  GLboolean arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEdgeFlag((GLboolean)arg0);

}

      
NAN_METHOD(edgeFlagPointer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glEdgeFlagPointer((GLsizei)arg0,(const void*)arg1);

}

      
NAN_METHOD(edgeFlagv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLboolean* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLboolean*>(*arg0_tarray);
  }


  glEdgeFlagv((const GLboolean*)arg0);

}

      
NAN_METHOD(enable) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glEnable((GLenum)arg0);

}

      
NAN_METHOD(enableClientState) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glEnableClientState((GLenum)arg0);

}

      
NAN_METHOD(end) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEnd();

}

      
NAN_METHOD(endList) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndList();

}

      
NAN_METHOD(evalCoord1d) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();


  glEvalCoord1d((GLdouble)arg0);

}

      
NAN_METHOD(evalCoord1dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glEvalCoord1dv((const GLdouble*)arg0);

}

      
NAN_METHOD(evalCoord1f) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glEvalCoord1f((GLfloat)arg0);

}

      
NAN_METHOD(evalCoord1fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glEvalCoord1fv((const GLfloat*)arg0);

}

      
NAN_METHOD(evalCoord2d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glEvalCoord2d((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(evalCoord2dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glEvalCoord2dv((const GLdouble*)arg0);

}

      
NAN_METHOD(evalCoord2f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glEvalCoord2f((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(evalCoord2fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glEvalCoord2fv((const GLfloat*)arg0);

}

      
NAN_METHOD(evalMesh1) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glEvalMesh1((GLenum)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(evalMesh2) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glEvalMesh2((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(evalPoint1) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glEvalPoint1((GLint)arg0);

}

      
NAN_METHOD(evalPoint2) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glEvalPoint2((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(feedbackBuffer) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glFeedbackBuffer((GLsizei)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(finish) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glFinish();

}

      
NAN_METHOD(flush) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glFlush();

}

      
NAN_METHOD(fogf) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glFogf((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(fogfv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glFogfv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(fogi) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glFogi((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(fogiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glFogiv((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(frontFace) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glFrontFace((GLenum)arg0);

}

      
NAN_METHOD(frustum) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();


  glFrustum((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5);

}

      
NAN_METHOD(genLists) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLuint retval = glGenLists(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(genTextures) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenTextures((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getBooleanv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLboolean* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLboolean*>(*arg1_tarray);
  }


  glGetBooleanv((GLenum)arg0,(GLboolean*)arg1);

}

      
NAN_METHOD(getClipPlane) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glGetClipPlane((GLenum)arg0,(GLdouble*)arg1);

}

      
NAN_METHOD(getDoublev) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glGetDoublev((GLenum)arg0,(GLdouble*)arg1);

}

      
NAN_METHOD(getError) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  GLenum retval = glGetError();

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getFloatv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glGetFloatv((GLenum)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(getIntegerv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glGetIntegerv((GLenum)arg0,(GLint*)arg1);

}

      
NAN_METHOD(getLightfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetLightfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getLightiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetLightiv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getMapdv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetMapdv((GLenum)arg0,(GLenum)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getMapfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetMapfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getMapiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetMapiv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getMaterialfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetMaterialfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getMaterialiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetMaterialiv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getPixelMapfv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glGetPixelMapfv((GLenum)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(getPixelMapuiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGetPixelMapuiv((GLenum)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getPixelMapusv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glGetPixelMapusv((GLenum)arg0,(GLushort*)arg1);

}

      
NAN_METHOD(getPointerv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsArray()) {
    Nan::ThrowError("Invalid parameter 2, expected array of typed arrays");
    return;
  }
  
  auto array1 = info[0].As<v8::Array>();
  void** arg1 = static_cast<void**>(alloca(sizeof(void*)*array1->Length()));
    
  for (unsigned int i=0; i<array1->Length(); i++) {
    auto val = array1->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 2, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg1[i] = reinterpret_cast<void*>(*item); 
  }


  glGetPointerv((GLenum)arg0,(void**)arg1);

}

      
NAN_METHOD(getPolygonStipple) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLubyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLubyte*>(*arg0_tarray);
  }


  glGetPolygonStipple((GLubyte*)arg0);

}

      
NAN_METHOD(getString) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  const GLubyte* retval = glGetString(arg0);

  info.GetReturnValue().Set(Nan::New<v8::String>((const char*)retval, strlen((const char*)retval)).ToLocalChecked());
      
}

      
NAN_METHOD(getTexEnvfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetTexEnvfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getTexEnviv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTexEnviv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getTexGendv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetTexGendv((GLenum)arg0,(GLenum)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getTexGenfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetTexGenfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getTexGeniv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTexGeniv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getTexImage) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetTexImage((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLenum)arg3,(void*)arg4);

}

      
NAN_METHOD(getTexLevelParameterfv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetTexLevelParameterfv((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getTexLevelParameteriv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetTexLevelParameteriv((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getTexParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetTexParameterfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getTexParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTexParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(hint) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glHint((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(indexMask) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glIndexMask((GLuint)arg0);

}

      
NAN_METHOD(indexPointer) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glIndexPointer((GLenum)arg0,(GLsizei)arg1,(const void*)arg2);

}

      
NAN_METHOD(indexd) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();


  glIndexd((GLdouble)arg0);

}

      
NAN_METHOD(indexdv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glIndexdv((const GLdouble*)arg0);

}

      
NAN_METHOD(indexf) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glIndexf((GLfloat)arg0);

}

      
NAN_METHOD(indexfv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glIndexfv((const GLfloat*)arg0);

}

      
NAN_METHOD(indexi) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glIndexi((GLint)arg0);

}

      
NAN_METHOD(indexiv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glIndexiv((const GLint*)arg0);

}

      
NAN_METHOD(indexs) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();


  glIndexs((GLshort)arg0);

}

      
NAN_METHOD(indexsv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glIndexsv((const GLshort*)arg0);

}

      
NAN_METHOD(indexub) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glubyte");
    return;
  }
  
  GLubyte arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glIndexub((GLubyte)arg0);

}

      
NAN_METHOD(indexubv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLubyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLubyte*>(*arg0_tarray);
  }


  glIndexubv((const GLubyte*)arg0);

}

      
NAN_METHOD(initNames) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glInitNames();

}

      
NAN_METHOD(interleavedArrays) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glInterleavedArrays((GLenum)arg0,(GLsizei)arg1,(const void*)arg2);

}

      
NAN_METHOD(isEnabled) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLboolean retval = glIsEnabled(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isList) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsList(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isTexture) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsTexture(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(lightModelf) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glLightModelf((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(lightModelfv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glLightModelfv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(lightModeli) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glLightModeli((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(lightModeliv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glLightModeliv((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(lightf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glLightf((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(lightfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glLightfv((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(lighti) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glLighti((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(lightiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glLightiv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(lineStipple) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glushort");
    return;
  }
  
  GLushort arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glLineStipple((GLint)arg0,(GLushort)arg1);

}

      
NAN_METHOD(lineWidth) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glLineWidth((GLfloat)arg0);

}

      
NAN_METHOD(listBase) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glListBase((GLuint)arg0);

}

      
NAN_METHOD(loadIdentity) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glLoadIdentity();

}

      
NAN_METHOD(loadMatrixd) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glLoadMatrixd((const GLdouble*)arg0);

}

      
NAN_METHOD(loadMatrixf) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glLoadMatrixf((const GLfloat*)arg0);

}

      
NAN_METHOD(loadName) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glLoadName((GLuint)arg0);

}

      
NAN_METHOD(logicOp) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glLogicOp((GLenum)arg0);

}

      
NAN_METHOD(map1d) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  GLdouble* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLdouble*>(*arg5_tarray);
  }


  glMap1d((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLint)arg3,(GLint)arg4,(const GLdouble*)arg5);

}

      
NAN_METHOD(map1f) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  GLfloat* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLfloat*>(*arg5_tarray);
  }


  glMap1f((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLint)arg3,(GLint)arg4,(const GLfloat*)arg5);

}

      
NAN_METHOD(map2d) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gldouble");
    return;
  }
  
  GLdouble arg6 = (GLdouble)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  GLdouble* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<GLdouble*>(*arg9_tarray);
  }


  glMap2d((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLint)arg3,(GLint)arg4,(GLdouble)arg5,(GLdouble)arg6,(GLint)arg7,(GLint)arg8,(const GLdouble*)arg9);

}

      
NAN_METHOD(map2f) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  GLfloat* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<GLfloat*>(*arg9_tarray);
  }


  glMap2f((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLint)arg3,(GLint)arg4,(GLfloat)arg5,(GLfloat)arg6,(GLint)arg7,(GLint)arg8,(const GLfloat*)arg9);

}

      
NAN_METHOD(mapGrid1d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glMapGrid1d((GLint)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(mapGrid1f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glMapGrid1f((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(mapGrid2d) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();


  glMapGrid2d((GLint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLint)arg3,(GLdouble)arg4,(GLdouble)arg5);

}

      
NAN_METHOD(mapGrid2f) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glMapGrid2f((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLint)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(materialf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glMaterialf((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(materialfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glMaterialfv((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(materiali) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glMateriali((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(materialiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glMaterialiv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(matrixMode) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glMatrixMode((GLenum)arg0);

}

      
NAN_METHOD(multMatrixd) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glMultMatrixd((const GLdouble*)arg0);

}

      
NAN_METHOD(multMatrixf) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glMultMatrixf((const GLfloat*)arg0);

}

      
NAN_METHOD(newList) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glNewList((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(normal3b) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbyte");
    return;
  }
  
  GLbyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbyte");
    return;
  }
  
  GLbyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glbyte");
    return;
  }
  
  GLbyte arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glNormal3b((GLbyte)arg0,(GLbyte)arg1,(GLbyte)arg2);

}

      
NAN_METHOD(normal3bv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLbyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLbyte*>(*arg0_tarray);
  }


  glNormal3bv((const GLbyte*)arg0);

}

      
NAN_METHOD(normal3d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glNormal3d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(normal3dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glNormal3dv((const GLdouble*)arg0);

}

      
NAN_METHOD(normal3f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glNormal3f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(normal3fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glNormal3fv((const GLfloat*)arg0);

}

      
NAN_METHOD(normal3i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glNormal3i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(normal3iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glNormal3iv((const GLint*)arg0);

}

      
NAN_METHOD(normal3s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glNormal3s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(normal3sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glNormal3sv((const GLshort*)arg0);

}

      
NAN_METHOD(normalPointer) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glNormalPointer((GLenum)arg0,(GLsizei)arg1,(const void*)arg2);

}

      
NAN_METHOD(ortho) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();


  glOrtho((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5);

}

      
NAN_METHOD(passThrough) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glPassThrough((GLfloat)arg0);

}

      
NAN_METHOD(pixelMapfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glPixelMapfv((GLenum)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(pixelMapuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glPixelMapuiv((GLenum)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(pixelMapusv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLushort* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLushort*>(*arg2_tarray);
  }


  glPixelMapusv((GLenum)arg0,(GLsizei)arg1,(const GLushort*)arg2);

}

      
NAN_METHOD(pixelStoref) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPixelStoref((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pixelStorei) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPixelStorei((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(pixelTransferf) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPixelTransferf((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pixelTransferi) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPixelTransferi((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(pixelZoom) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPixelZoom((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pointSize) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glPointSize((GLfloat)arg0);

}

      
NAN_METHOD(polygonMode) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPolygonMode((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(polygonOffset) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPolygonOffset((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(polygonStipple) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLubyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLubyte*>(*arg0_tarray);
  }


  glPolygonStipple((const GLubyte*)arg0);

}

      
NAN_METHOD(popAttrib) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPopAttrib();

}

      
NAN_METHOD(popClientAttrib) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPopClientAttrib();

}

      
NAN_METHOD(popMatrix) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPopMatrix();

}

      
NAN_METHOD(popName) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPopName();

}

      
NAN_METHOD(prioritizeTextures) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }
  GLclampf* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLclampf*>(*arg2_tarray);
  }


  glPrioritizeTextures((GLsizei)arg0,(const GLuint*)arg1,(const GLclampf*)arg2);

}

      
NAN_METHOD(pushAttrib) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glPushAttrib((GLbitfield)arg0);

}

      
NAN_METHOD(pushClientAttrib) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glPushClientAttrib((GLbitfield)arg0);

}

      
NAN_METHOD(pushMatrix) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPushMatrix();

}

      
NAN_METHOD(pushName) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glPushName((GLuint)arg0);

}

      
NAN_METHOD(rasterPos2d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glRasterPos2d((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(rasterPos2dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glRasterPos2dv((const GLdouble*)arg0);

}

      
NAN_METHOD(rasterPos2f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glRasterPos2f((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(rasterPos2fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glRasterPos2fv((const GLfloat*)arg0);

}

      
NAN_METHOD(rasterPos2i) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glRasterPos2i((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(rasterPos2iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glRasterPos2iv((const GLint*)arg0);

}

      
NAN_METHOD(rasterPos2s) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glRasterPos2s((GLshort)arg0,(GLshort)arg1);

}

      
NAN_METHOD(rasterPos2sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glRasterPos2sv((const GLshort*)arg0);

}

      
NAN_METHOD(rasterPos3d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glRasterPos3d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(rasterPos3dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glRasterPos3dv((const GLdouble*)arg0);

}

      
NAN_METHOD(rasterPos3f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glRasterPos3f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(rasterPos3fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glRasterPos3fv((const GLfloat*)arg0);

}

      
NAN_METHOD(rasterPos3i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glRasterPos3i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(rasterPos3iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glRasterPos3iv((const GLint*)arg0);

}

      
NAN_METHOD(rasterPos3s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glRasterPos3s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(rasterPos3sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glRasterPos3sv((const GLshort*)arg0);

}

      
NAN_METHOD(rasterPos4d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glRasterPos4d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(rasterPos4dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glRasterPos4dv((const GLdouble*)arg0);

}

      
NAN_METHOD(rasterPos4f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glRasterPos4f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(rasterPos4fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glRasterPos4fv((const GLfloat*)arg0);

}

      
NAN_METHOD(rasterPos4i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glRasterPos4i((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(rasterPos4iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glRasterPos4iv((const GLint*)arg0);

}

      
NAN_METHOD(rasterPos4s) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glRasterPos4s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(rasterPos4sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glRasterPos4sv((const GLshort*)arg0);

}

      
NAN_METHOD(readBuffer) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glReadBuffer((GLenum)arg0);

}

      
NAN_METHOD(readPixels) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glReadPixels((GLint)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(void*)arg6);

}

      
NAN_METHOD(rectd) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glRectd((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(rectdv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glRectdv((const GLdouble*)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(rectf) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glRectf((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(rectfv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glRectfv((const GLfloat*)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(recti) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glRecti((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(rectiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glRectiv((const GLint*)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(rects) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glRects((GLshort)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(rectsv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glRectsv((const GLshort*)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(renderMode) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLint retval = glRenderMode(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(rotated) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glRotated((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(rotatef) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glRotatef((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(scaled) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glScaled((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(scalef) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glScalef((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(scissor) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glScissor((GLint)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(selectBuffer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glSelectBuffer((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(shadeModel) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glShadeModel((GLenum)arg0);

}

      
NAN_METHOD(stencilFunc) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glStencilFunc((GLenum)arg0,(GLint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(stencilMask) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glStencilMask((GLuint)arg0);

}

      
NAN_METHOD(stencilOp) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glStencilOp((GLenum)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(texCoord1d) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();


  glTexCoord1d((GLdouble)arg0);

}

      
NAN_METHOD(texCoord1dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glTexCoord1dv((const GLdouble*)arg0);

}

      
NAN_METHOD(texCoord1f) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glTexCoord1f((GLfloat)arg0);

}

      
NAN_METHOD(texCoord1fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glTexCoord1fv((const GLfloat*)arg0);

}

      
NAN_METHOD(texCoord1i) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glTexCoord1i((GLint)arg0);

}

      
NAN_METHOD(texCoord1iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glTexCoord1iv((const GLint*)arg0);

}

      
NAN_METHOD(texCoord1s) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();


  glTexCoord1s((GLshort)arg0);

}

      
NAN_METHOD(texCoord1sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glTexCoord1sv((const GLshort*)arg0);

}

      
NAN_METHOD(texCoord2d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glTexCoord2d((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(texCoord2dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glTexCoord2dv((const GLdouble*)arg0);

}

      
NAN_METHOD(texCoord2f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glTexCoord2f((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(texCoord2fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glTexCoord2fv((const GLfloat*)arg0);

}

      
NAN_METHOD(texCoord2i) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glTexCoord2i((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(texCoord2iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glTexCoord2iv((const GLint*)arg0);

}

      
NAN_METHOD(texCoord2s) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glTexCoord2s((GLshort)arg0,(GLshort)arg1);

}

      
NAN_METHOD(texCoord2sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glTexCoord2sv((const GLshort*)arg0);

}

      
NAN_METHOD(texCoord3d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glTexCoord3d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(texCoord3dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glTexCoord3dv((const GLdouble*)arg0);

}

      
NAN_METHOD(texCoord3f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glTexCoord3f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(texCoord3fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glTexCoord3fv((const GLfloat*)arg0);

}

      
NAN_METHOD(texCoord3i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTexCoord3i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(texCoord3iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glTexCoord3iv((const GLint*)arg0);

}

      
NAN_METHOD(texCoord3s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTexCoord3s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(texCoord3sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glTexCoord3sv((const GLshort*)arg0);

}

      
NAN_METHOD(texCoord4d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glTexCoord4d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(texCoord4dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glTexCoord4dv((const GLdouble*)arg0);

}

      
NAN_METHOD(texCoord4f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glTexCoord4f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(texCoord4fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glTexCoord4fv((const GLfloat*)arg0);

}

      
NAN_METHOD(texCoord4i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glTexCoord4i((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(texCoord4iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glTexCoord4iv((const GLint*)arg0);

}

      
NAN_METHOD(texCoord4s) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glTexCoord4s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(texCoord4sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glTexCoord4sv((const GLshort*)arg0);

}

      
NAN_METHOD(texCoordPointer) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glTexCoordPointer((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(texEnvf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glTexEnvf((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(texEnvfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glTexEnvfv((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(texEnvi) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTexEnvi((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(texEnviv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glTexEnviv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(texGend) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glTexGend((GLenum)arg0,(GLenum)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(texGendv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glTexGendv((GLenum)arg0,(GLenum)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(texGenf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glTexGenf((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(texGenfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glTexGenfv((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(texGeni) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTexGeni((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(texGeniv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glTexGeniv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(texImage1D) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glTexImage1D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLint)arg4,(GLenum)arg5,(GLenum)arg6,(const void*)arg7);

}

      
NAN_METHOD(texImage2D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glTexImage2D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLint)arg5,(GLenum)arg6,(GLenum)arg7,(const void*)arg8);

}

      
NAN_METHOD(texParameterf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glTexParameterf((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(texParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glTexParameterfv((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(texParameteri) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTexParameteri((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(texParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glTexParameteriv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(texSubImage1D) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glTexSubImage1D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(texSubImage2D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glTexSubImage2D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLenum)arg6,(GLenum)arg7,(const void*)arg8);

}

      
NAN_METHOD(translated) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glTranslated((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(translatef) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glTranslatef((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(vertex2d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glVertex2d((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(vertex2dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glVertex2dv((const GLdouble*)arg0);

}

      
NAN_METHOD(vertex2f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glVertex2f((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(vertex2fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glVertex2fv((const GLfloat*)arg0);

}

      
NAN_METHOD(vertex2i) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertex2i((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(vertex2iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glVertex2iv((const GLint*)arg0);

}

      
NAN_METHOD(vertex2s) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertex2s((GLshort)arg0,(GLshort)arg1);

}

      
NAN_METHOD(vertex2sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glVertex2sv((const GLshort*)arg0);

}

      
NAN_METHOD(vertex3d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glVertex3d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(vertex3dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glVertex3dv((const GLdouble*)arg0);

}

      
NAN_METHOD(vertex3f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glVertex3f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(vertex3fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glVertex3fv((const GLfloat*)arg0);

}

      
NAN_METHOD(vertex3i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertex3i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(vertex3iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glVertex3iv((const GLint*)arg0);

}

      
NAN_METHOD(vertex3s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertex3s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(vertex3sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glVertex3sv((const GLshort*)arg0);

}

      
NAN_METHOD(vertex4d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glVertex4d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(vertex4dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glVertex4dv((const GLdouble*)arg0);

}

      
NAN_METHOD(vertex4f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glVertex4f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(vertex4fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glVertex4fv((const GLfloat*)arg0);

}

      
NAN_METHOD(vertex4i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertex4i((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(vertex4iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glVertex4iv((const GLint*)arg0);

}

      
NAN_METHOD(vertex4s) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertex4s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(vertex4sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glVertex4sv((const GLshort*)arg0);

}

      
NAN_METHOD(vertexPointer) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glVertexPointer((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(viewport) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glViewport((GLint)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(ewInit) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  GLenum retval = glewInit();

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(ewIsSupported) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  char* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<char*>(*arg0_tarray);
  }


  GLboolean retval = glewIsSupported(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(ewGetExtension) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  char* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<char*>(*arg0_tarray);
  }


  GLboolean retval = glewGetExtension(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(ewGetErrorString) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  const GLubyte* retval = glewGetErrorString(arg0);

  info.GetReturnValue().Set(Nan::New<v8::String>((const char*)retval, strlen((const char*)retval)).ToLocalChecked());
      
}

      
NAN_METHOD(ewGetString) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  const GLubyte* retval = glewGetString(arg0);

  info.GetReturnValue().Set(Nan::New<v8::String>((const char*)retval, strlen((const char*)retval)).ToLocalChecked());
      
}

      
NAN_METHOD(copyTexSubImage3D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glsizei");
    return;
  }
  
  GLsizei arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glCopyTexSubImage3D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLsizei)arg7,(GLsizei)arg8);

}

      
NAN_METHOD(drawRangeElements) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glDrawRangeElements((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(texImage3D) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  void* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<void*>(*arg9_tarray);
  }


  glTexImage3D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6,(GLenum)arg7,(GLenum)arg8,(const void*)arg9);

}

      
NAN_METHOD(texSubImage3D) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glTexSubImage3D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(const void*)arg10);

}

      
NAN_METHOD(activeTexture) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glActiveTexture((GLenum)arg0);

}

      
NAN_METHOD(clientActiveTexture) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glClientActiveTexture((GLenum)arg0);

}

      
NAN_METHOD(compressedTexImage1D) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glCompressedTexImage1D((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLint)arg4,(GLsizei)arg5,(const void*)arg6);

}

      
NAN_METHOD(compressedTexImage2D) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glCompressedTexImage2D((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLint)arg5,(GLsizei)arg6,(const void*)arg7);

}

      
NAN_METHOD(compressedTexImage3D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glCompressedTexImage3D((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6,(GLsizei)arg7,(const void*)arg8);

}

      
NAN_METHOD(compressedTexSubImage1D) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glCompressedTexSubImage1D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLenum)arg4,(GLsizei)arg5,(const void*)arg6);

}

      
NAN_METHOD(compressedTexSubImage2D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glCompressedTexSubImage2D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLenum)arg6,(GLsizei)arg7,(const void*)arg8);

}

      
NAN_METHOD(compressedTexSubImage3D) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glsizei");
    return;
  }
  
  GLsizei arg9 = info[9]->Uint32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glCompressedTexSubImage3D((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLsizei)arg9,(const void*)arg10);

}

      
NAN_METHOD(getCompressedTexImage) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glGetCompressedTexImage((GLenum)arg0,(GLint)arg1,(void*)arg2);

}

      
NAN_METHOD(multiTexCoord1d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glMultiTexCoord1d((GLenum)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(multiTexCoord1dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord1dv((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord1f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glMultiTexCoord1f((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(multiTexCoord1fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord1fv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord1i) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMultiTexCoord1i((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(multiTexCoord1iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord1iv((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord1s) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMultiTexCoord1s((GLenum)arg0,(GLshort)arg1);

}

      
NAN_METHOD(multiTexCoord1sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord1sv((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(multiTexCoord2d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glMultiTexCoord2d((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(multiTexCoord2dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord2dv((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord2f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glMultiTexCoord2f((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(multiTexCoord2fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord2fv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord2i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glMultiTexCoord2i((GLenum)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(multiTexCoord2iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord2iv((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord2s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glMultiTexCoord2s((GLenum)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(multiTexCoord2sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord2sv((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(multiTexCoord3d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glMultiTexCoord3d((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(multiTexCoord3dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord3dv((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord3f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glMultiTexCoord3f((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(multiTexCoord3fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord3fv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord3i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glMultiTexCoord3i((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(multiTexCoord3iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord3iv((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord3s) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glMultiTexCoord3s((GLenum)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(multiTexCoord3sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord3sv((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(multiTexCoord4d) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glMultiTexCoord4d((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(multiTexCoord4dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord4dv((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord4f) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glMultiTexCoord4f((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(multiTexCoord4fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord4fv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord4i) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glMultiTexCoord4i((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(multiTexCoord4iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord4iv((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord4s) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glshort");
    return;
  }
  
  GLshort arg4 = info[4]->Int32Value(ctx).ToChecked();


  glMultiTexCoord4s((GLenum)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3,(GLshort)arg4);

}

      
NAN_METHOD(multiTexCoord4sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord4sv((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(sampleCoverage) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glSampleCoverage((GLclampf)arg0,(GLboolean)arg1);

}

      
NAN_METHOD(blendColor) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampf");
    return;
  }
  
  GLclampf arg1 = (GLclampf)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glclampf");
    return;
  }
  
  GLclampf arg2 = (GLclampf)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glclampf");
    return;
  }
  
  GLclampf arg3 = (GLclampf)info[3]->NumberValue(ctx).ToChecked();


  glBlendColor((GLclampf)arg0,(GLclampf)arg1,(GLclampf)arg2,(GLclampf)arg3);

}

      
NAN_METHOD(blendEquation) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glBlendEquation((GLenum)arg0);

}

      
NAN_METHOD(blendFuncSeparate) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glBlendFuncSeparate((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3);

}

      
NAN_METHOD(fogCoordPointer) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glFogCoordPointer((GLenum)arg0,(GLsizei)arg1,(const void*)arg2);

}

      
NAN_METHOD(fogCoordd) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();


  glFogCoordd((GLdouble)arg0);

}

      
NAN_METHOD(fogCoorddv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glFogCoorddv((const GLdouble*)arg0);

}

      
NAN_METHOD(fogCoordf) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glFogCoordf((GLfloat)arg0);

}

      
NAN_METHOD(fogCoordfv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glFogCoordfv((const GLfloat*)arg0);

}

      
NAN_METHOD(multiDrawArrays) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glMultiDrawArrays((GLenum)arg0,(const GLint*)arg1,(const GLsizei*)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(multiDrawElements) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLsizei* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLsizei*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsArray()) {
    Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
    return;
  }
  
  auto array3 = info[0].As<v8::Array>();
  void** arg3 = static_cast<void**>(alloca(sizeof(void*)*array3->Length()));
    
  for (unsigned int i=0; i<array3->Length(); i++) {
    auto val = array3->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg3[i] = reinterpret_cast<void*>(*item); 
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiDrawElements((GLenum)arg0,(const GLsizei*)arg1,(GLenum)arg2,(const void* const*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(pointParameterf) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPointParameterf((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pointParameterfv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glPointParameterfv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(pointParameteri) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPointParameteri((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(pointParameteriv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glPointParameteriv((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(secondaryColor3b) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbyte");
    return;
  }
  
  GLbyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbyte");
    return;
  }
  
  GLbyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glbyte");
    return;
  }
  
  GLbyte arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3b((GLbyte)arg0,(GLbyte)arg1,(GLbyte)arg2);

}

      
NAN_METHOD(secondaryColor3bv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLbyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLbyte*>(*arg0_tarray);
  }


  glSecondaryColor3bv((const GLbyte*)arg0);

}

      
NAN_METHOD(secondaryColor3d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glSecondaryColor3d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(secondaryColor3dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glSecondaryColor3dv((const GLdouble*)arg0);

}

      
NAN_METHOD(secondaryColor3f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glSecondaryColor3f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(secondaryColor3fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glSecondaryColor3fv((const GLfloat*)arg0);

}

      
NAN_METHOD(secondaryColor3i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glSecondaryColor3i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(secondaryColor3iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glSecondaryColor3iv((const GLint*)arg0);

}

      
NAN_METHOD(secondaryColor3s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glSecondaryColor3s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(secondaryColor3sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glSecondaryColor3sv((const GLshort*)arg0);

}

      
NAN_METHOD(secondaryColor3ub) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glubyte");
    return;
  }
  
  GLubyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glubyte");
    return;
  }
  
  GLubyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glubyte");
    return;
  }
  
  GLubyte arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3ub((GLubyte)arg0,(GLubyte)arg1,(GLubyte)arg2);

}

      
NAN_METHOD(secondaryColor3ubv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLubyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLubyte*>(*arg0_tarray);
  }


  glSecondaryColor3ubv((const GLubyte*)arg0);

}

      
NAN_METHOD(secondaryColor3ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3ui((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(secondaryColor3uiv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }


  glSecondaryColor3uiv((const GLuint*)arg0);

}

      
NAN_METHOD(secondaryColor3us) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glushort");
    return;
  }
  
  GLushort arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glushort");
    return;
  }
  
  GLushort arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glushort");
    return;
  }
  
  GLushort arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3us((GLushort)arg0,(GLushort)arg1,(GLushort)arg2);

}

      
NAN_METHOD(secondaryColor3usv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLushort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLushort*>(*arg0_tarray);
  }


  glSecondaryColor3usv((const GLushort*)arg0);

}

      
NAN_METHOD(secondaryColorPointer) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glSecondaryColorPointer((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(windowPos2d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glWindowPos2d((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(windowPos2dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glWindowPos2dv((const GLdouble*)arg0);

}

      
NAN_METHOD(windowPos2f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glWindowPos2f((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(windowPos2fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glWindowPos2fv((const GLfloat*)arg0);

}

      
NAN_METHOD(windowPos2i) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glWindowPos2i((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(windowPos2iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glWindowPos2iv((const GLint*)arg0);

}

      
NAN_METHOD(windowPos2s) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glWindowPos2s((GLshort)arg0,(GLshort)arg1);

}

      
NAN_METHOD(windowPos2sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glWindowPos2sv((const GLshort*)arg0);

}

      
NAN_METHOD(windowPos3d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glWindowPos3d((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(windowPos3dv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glWindowPos3dv((const GLdouble*)arg0);

}

      
NAN_METHOD(windowPos3f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glWindowPos3f((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(windowPos3fv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glWindowPos3fv((const GLfloat*)arg0);

}

      
NAN_METHOD(windowPos3i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glWindowPos3i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(windowPos3iv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glWindowPos3iv((const GLint*)arg0);

}

      
NAN_METHOD(windowPos3s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glWindowPos3s((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(windowPos3sv) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glWindowPos3sv((const GLshort*)arg0);

}

      
NAN_METHOD(beginQuery) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBeginQuery((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bindBuffer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindBuffer((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bufferData) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glBufferData((GLenum)arg0,(GLsizeiptr)arg1,(const void*)arg2,(GLenum)arg3);

}

      
NAN_METHOD(bufferSubData) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glBufferSubData((GLenum)arg0,(GLintptr)arg1,(GLsizeiptr)arg2,(const void*)arg3);

}

      
NAN_METHOD(deleteBuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteBuffers((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(deleteQueries) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteQueries((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(endQuery) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glEndQuery((GLenum)arg0);

}

      
NAN_METHOD(genBuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenBuffers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(genQueries) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenQueries((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getBufferParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetBufferParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getBufferPointerv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetBufferPointerv((GLenum)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(getBufferSubData) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetBufferSubData((GLenum)arg0,(GLintptr)arg1,(GLsizeiptr)arg2,(void*)arg3);

}

      
NAN_METHOD(getQueryObjectiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetQueryObjectiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getQueryObjectuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetQueryObjectuiv((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getQueryiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetQueryiv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isBuffer) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsBuffer(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isQuery) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsQuery(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(unmapBuffer) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLboolean retval = glUnmapBuffer(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(attachShader) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glAttachShader((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bindAttribLocation) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  glBindAttribLocation((GLuint)arg0,(GLuint)arg1,(const GLchar*)arg2);

}

      
NAN_METHOD(blendEquationSeparate) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendEquationSeparate((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(compileShader) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glCompileShader((GLuint)arg0);

}

      
NAN_METHOD(createProgram) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  GLuint retval = glCreateProgram();

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(createShader) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLuint retval = glCreateShader(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(deleteProgram) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDeleteProgram((GLuint)arg0);

}

      
NAN_METHOD(deleteShader) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDeleteShader((GLuint)arg0);

}

      
NAN_METHOD(detachShader) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDetachShader((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(disableVertexAttribArray) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDisableVertexAttribArray((GLuint)arg0);

}

      
NAN_METHOD(drawBuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLenum* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLenum*>(*arg1_tarray);
  }


  glDrawBuffers((GLsizei)arg0,(const GLenum*)arg1);

}

      
NAN_METHOD(enableVertexAttribArray) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEnableVertexAttribArray((GLuint)arg0);

}

      
NAN_METHOD(getActiveAttrib) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLchar* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLchar*>(*arg6_tarray);
  }


  glGetActiveAttrib((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLint*)arg4,(GLenum*)arg5,(GLchar*)arg6);

}

      
NAN_METHOD(getActiveUniform) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLchar* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLchar*>(*arg6_tarray);
  }


  glGetActiveUniform((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLint*)arg4,(GLenum*)arg5,(GLchar*)arg6);

}

      
NAN_METHOD(getAttachedShaders) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glGetAttachedShaders((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLuint*)arg3);

}

      
NAN_METHOD(getAttribLocation) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLint retval = glGetAttribLocation(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getProgramInfoLog) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetProgramInfoLog((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(getProgramiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetProgramiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getShaderInfoLog) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetShaderInfoLog((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(getShaderSource) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetShaderSource((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(getShaderiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetShaderiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getUniformLocation) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLint retval = glGetUniformLocation(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getUniformfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetUniformfv((GLuint)arg0,(GLint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getUniformiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetUniformiv((GLuint)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVertexAttribPointerv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetVertexAttribPointerv((GLuint)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(getVertexAttribdv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetVertexAttribdv((GLuint)arg0,(GLenum)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getVertexAttribfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetVertexAttribfv((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getVertexAttribiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVertexAttribiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isProgram) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsProgram(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isShader) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsShader(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(linkProgram) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glLinkProgram((GLuint)arg0);

}

      
NAN_METHOD(shaderSource) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  GLchar** arg2 = static_cast<GLchar**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<GLchar*>(*item); 
  }
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glShaderSource((GLuint)arg0,(GLsizei)arg1,(const GLchar* const*)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(stencilFuncSeparate) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glStencilFuncSeparate((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(stencilMaskSeparate) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glStencilMaskSeparate((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(stencilOpSeparate) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glStencilOpSeparate((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3);

}

      
NAN_METHOD(uniform1f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glUniform1f((GLint)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(uniform1fv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform1fv((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform1i) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glUniform1i((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(uniform1iv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform1iv((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniform2f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glUniform2f((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(uniform2fv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform2fv((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform2i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glUniform2i((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(uniform2iv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform2iv((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniform3f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glUniform3f((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(uniform3fv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform3fv((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform3i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glUniform3i((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(uniform3iv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform3iv((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniform4f) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glUniform4f((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(uniform4fv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform4fv((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform4i) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glUniform4i((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(uniform4iv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform4iv((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniformMatrix2fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix2fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix3fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix3fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix4fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix4fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(useProgram) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glUseProgram((GLuint)arg0);

}

      
NAN_METHOD(validateProgram) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glValidateProgram((GLuint)arg0);

}

      
NAN_METHOD(vertexAttrib1d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttrib1d((GLuint)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(vertexAttrib1dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib1dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib1f) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttrib1f((GLuint)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(vertexAttrib1fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib1fv((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib1s) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexAttrib1s((GLuint)arg0,(GLshort)arg1);

}

      
NAN_METHOD(vertexAttrib1sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib1sv((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib2d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttrib2d((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(vertexAttrib2dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib2dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib2f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttrib2f((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(vertexAttrib2fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib2fv((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib2s) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexAttrib2s((GLuint)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(vertexAttrib2sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib2sv((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib3d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttrib3d((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(vertexAttrib3dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib3dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib3f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttrib3f((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(vertexAttrib3fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib3fv((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib3s) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertexAttrib3s((GLuint)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(vertexAttrib3sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib3sv((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4Nbv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glVertexAttrib4Nbv((GLuint)arg0,(const GLbyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4Niv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttrib4Niv((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttrib4Nsv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib4Nsv((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4Nub) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glubyte");
    return;
  }
  
  GLubyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glubyte");
    return;
  }
  
  GLubyte arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glubyte");
    return;
  }
  
  GLubyte arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glubyte");
    return;
  }
  
  GLubyte arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttrib4Nub((GLuint)arg0,(GLubyte)arg1,(GLubyte)arg2,(GLubyte)arg3,(GLubyte)arg4);

}

      
NAN_METHOD(vertexAttrib4Nubv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVertexAttrib4Nubv((GLuint)arg0,(const GLubyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4Nuiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttrib4Nuiv((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttrib4Nusv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glVertexAttrib4Nusv((GLuint)arg0,(const GLushort*)arg1);

}

      
NAN_METHOD(vertexAttrib4bv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glVertexAttrib4bv((GLuint)arg0,(const GLbyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4d) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttrib4d((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(vertexAttrib4dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib4dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib4f) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttrib4f((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(vertexAttrib4fv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib4fv((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib4iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttrib4iv((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttrib4s) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glshort");
    return;
  }
  
  GLshort arg4 = info[4]->Int32Value(ctx).ToChecked();


  glVertexAttrib4s((GLuint)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3,(GLshort)arg4);

}

      
NAN_METHOD(vertexAttrib4sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib4sv((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4ubv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVertexAttrib4ubv((GLuint)arg0,(const GLubyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttrib4uiv((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttrib4usv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glVertexAttrib4usv((GLuint)arg0,(const GLushort*)arg1);

}

      
NAN_METHOD(vertexAttribPointer) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glVertexAttribPointer((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLboolean)arg3,(GLsizei)arg4,(const void*)arg5);

}

      
NAN_METHOD(uniformMatrix2x3fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix2x3fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix2x4fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix2x4fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix3x2fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix3x2fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix3x4fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix3x4fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix4x2fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix4x2fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix4x3fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix4x3fv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(beginConditionalRender) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBeginConditionalRender((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(beginTransformFeedback) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glBeginTransformFeedback((GLenum)arg0);

}

      
NAN_METHOD(bindFragDataLocation) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  glBindFragDataLocation((GLuint)arg0,(GLuint)arg1,(const GLchar*)arg2);

}

      
NAN_METHOD(clampColor) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glClampColor((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(clearBufferfi) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glClearBufferfi((GLenum)arg0,(GLint)arg1,(GLfloat)arg2,(GLint)arg3);

}

      
NAN_METHOD(clearBufferfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glClearBufferfv((GLenum)arg0,(GLint)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(clearBufferiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glClearBufferiv((GLenum)arg0,(GLint)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(clearBufferuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glClearBufferuiv((GLenum)arg0,(GLint)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(colorMaski) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glboolean");
    return;
  }
  
  GLboolean arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glColorMaski((GLuint)arg0,(GLboolean)arg1,(GLboolean)arg2,(GLboolean)arg3,(GLboolean)arg4);

}

      
NAN_METHOD(disablei) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDisablei((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(enablei) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glEnablei((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(endConditionalRender) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndConditionalRender();

}

      
NAN_METHOD(endTransformFeedback) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndTransformFeedback();

}

      
NAN_METHOD(getBooleani_v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  glGetBooleani_v((GLenum)arg0,(GLuint)arg1,(GLboolean*)arg2);

}

      
NAN_METHOD(getFragDataLocation) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLint retval = glGetFragDataLocation(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getTexParameterIiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTexParameterIiv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getTexParameterIuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetTexParameterIuiv((GLenum)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getTransformFeedbackVarying) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLchar* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLchar*>(*arg6_tarray);
  }


  glGetTransformFeedbackVarying((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLsizei*)arg4,(GLenum*)arg5,(GLchar*)arg6);

}

      
NAN_METHOD(getUniformuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetUniformuiv((GLuint)arg0,(GLint)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getVertexAttribIiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVertexAttribIiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVertexAttribIuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetVertexAttribIuiv((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(isEnabledi) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsEnabledi(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(texParameterIiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glTexParameterIiv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(texParameterIuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glTexParameterIuiv((GLenum)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(transformFeedbackVaryings) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  GLchar** arg2 = static_cast<GLchar**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<GLchar*>(*item); 
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glTransformFeedbackVaryings((GLuint)arg0,(GLsizei)arg1,(const GLchar* const*)arg2,(GLenum)arg3);

}

      
NAN_METHOD(uniform1ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glUniform1ui((GLint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(uniform1uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform1uiv((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(uniform2ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glUniform2ui((GLint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(uniform2uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform2uiv((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(uniform3ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glUniform3ui((GLint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(uniform3uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform3uiv((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(uniform4ui) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glUniform4ui((GLint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(uniform4uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform4uiv((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(vertexAttribI1i) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexAttribI1i((GLuint)arg0,(GLint)arg1);

}

      
NAN_METHOD(vertexAttribI1iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI1iv((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI1ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribI1ui((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexAttribI1uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI1uiv((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI2i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexAttribI2i((GLuint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(vertexAttribI2iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI2iv((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI2ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexAttribI2ui((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(vertexAttribI2uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI2uiv((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI3i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertexAttribI3i((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(vertexAttribI3iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI3iv((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI3ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribI3ui((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexAttribI3uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI3uiv((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI4bv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glVertexAttribI4bv((GLuint)arg0,(const GLbyte*)arg1);

}

      
NAN_METHOD(vertexAttribI4i) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glVertexAttribI4i((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(vertexAttribI4iv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI4iv((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI4sv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttribI4sv((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttribI4ubv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVertexAttribI4ubv((GLuint)arg0,(const GLubyte*)arg1);

}

      
NAN_METHOD(vertexAttribI4ui) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttribI4ui((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(vertexAttribI4uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI4uiv((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI4usv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glVertexAttribI4usv((GLuint)arg0,(const GLushort*)arg1);

}

      
NAN_METHOD(vertexAttribIPointer) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glVertexAttribIPointer((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(drawArraysInstanced) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawArraysInstanced((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(drawElementsInstanced) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstanced((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(primitiveRestartIndex) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glPrimitiveRestartIndex((GLuint)arg0);

}

      
NAN_METHOD(texBuffer) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTexBuffer((GLenum)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(framebufferTexture) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glFramebufferTexture((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3);

}

      
NAN_METHOD(getBufferParameteri64v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glGetBufferParameteri64v((GLenum)arg0,(GLenum)arg1,(GLint64*)arg2);

}

      
NAN_METHOD(getInteger64i_v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glGetInteger64i_v((GLenum)arg0,(GLuint)arg1,(GLint64*)arg2);

}

      
NAN_METHOD(vertexAttribDivisor) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribDivisor((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(blendEquationSeparatei) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendEquationSeparatei((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(blendEquationi) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendEquationi((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(blendFuncSeparatei) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glBlendFuncSeparatei((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4);

}

      
NAN_METHOD(blendFunci) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendFunci((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(minSampleShading) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();


  glMinSampleShading((GLclampf)arg0);

}

      
NAN_METHOD(getGraphicsResetStatus) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  GLenum retval = glGetGraphicsResetStatus();

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getnCompressedTexImage) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLvoid* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLvoid*>(*arg3_tarray);
  }


  glGetnCompressedTexImage((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLvoid*)arg3);

}

      
NAN_METHOD(getnTexImage) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLvoid* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLvoid*>(*arg5_tarray);
  }


  glGetnTexImage((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLenum)arg3,(GLsizei)arg4,(GLvoid*)arg5);

}

      
NAN_METHOD(getnUniformdv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glGetnUniformdv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLdouble*)arg3);

}

      
NAN_METHOD(multiDrawArraysIndirectCount) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLvoid* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLvoid*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiDrawArraysIndirectCount((GLenum)arg0,(const GLvoid*)arg1,(GLintptr)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(multiDrawElementsIndirectCount) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLvoid* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLvoid*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glMultiDrawElementsIndirectCount((GLenum)arg0,(GLenum)arg1,(const GLvoid*)arg2,(GLintptr)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(specializeShader) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glSpecializeShader((GLuint)arg0,(const GLchar*)arg1,(GLuint)arg2,(const GLuint*)arg3,(const GLuint*)arg4);

}

      
NAN_METHOD(tbufferMask3DFX) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glTbufferMask3DFX((GLuint)arg0);

}

      
NAN_METHOD(debugMessageEnableAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glboolean");
    return;
  }
  
  GLboolean arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDebugMessageEnableAMD((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(const GLuint*)arg3,(GLboolean)arg4);

}

      
NAN_METHOD(debugMessageInsertAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glDebugMessageInsertAMD((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLchar*)arg4);

}

      
NAN_METHOD(getDebugMessageLogAMD) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  GLsizei* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLsizei*>(*arg5_tarray);
  }
  GLchar* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLchar*>(*arg6_tarray);
  }


  GLuint retval = glGetDebugMessageLogAMD(arg0,arg1,arg2,arg3,arg4,arg5,arg6);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(blendEquationIndexedAMD) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendEquationIndexedAMD((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(blendEquationSeparateIndexedAMD) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendEquationSeparateIndexedAMD((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(blendFuncIndexedAMD) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendFuncIndexedAMD((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(blendFuncSeparateIndexedAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glBlendFuncSeparateIndexedAMD((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4);

}

      
NAN_METHOD(framebufferSamplePositionsfvAMD) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glFramebufferSamplePositionsfvAMD((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(getFramebufferParameterfvAMD) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLfloat* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLfloat*>(*arg5_tarray);
  }


  glGetFramebufferParameterfvAMD((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLuint)arg3,(GLsizei)arg4,(GLfloat*)arg5);

}

      
NAN_METHOD(getNamedFramebufferParameterfvAMD) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLfloat* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLfloat*>(*arg5_tarray);
  }


  glGetNamedFramebufferParameterfvAMD((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLuint)arg3,(GLsizei)arg4,(GLfloat*)arg5);

}

      
NAN_METHOD(namedFramebufferSamplePositionsfvAMD) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glNamedFramebufferSamplePositionsfvAMD((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(vertexAttribParameteriAMD) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexAttribParameteriAMD((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(multiDrawArraysIndirectAMD) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glMultiDrawArraysIndirectAMD((GLenum)arg0,(const void*)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(multiDrawElementsIndirectAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiDrawElementsIndirectAMD((GLenum)arg0,(GLenum)arg1,(const void*)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(deleteNamesAMD) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glDeleteNamesAMD((GLenum)arg0,(GLuint)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(genNamesAMD) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGenNamesAMD((GLenum)arg0,(GLuint)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(isNameAMD) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsNameAMD(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(queryObjectParameteruiAMD) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glQueryObjectParameteruiAMD((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLuint)arg3);

}

      
NAN_METHOD(beginPerfMonitorAMD) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBeginPerfMonitorAMD((GLuint)arg0);

}

      
NAN_METHOD(deletePerfMonitorsAMD) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeletePerfMonitorsAMD((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(endPerfMonitorAMD) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEndPerfMonitorAMD((GLuint)arg0);

}

      
NAN_METHOD(genPerfMonitorsAMD) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenPerfMonitorsAMD((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getPerfMonitorCounterDataAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glGetPerfMonitorCounterDataAMD((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLuint*)arg3,(GLint*)arg4);

}

      
NAN_METHOD(getPerfMonitorCounterInfoAMD) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetPerfMonitorCounterInfoAMD((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(void*)arg3);

}

      
NAN_METHOD(getPerfMonitorCounterStringAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glGetPerfMonitorCounterStringAMD((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLchar*)arg4);

}

      
NAN_METHOD(getPerfMonitorCountersAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glGetPerfMonitorCountersAMD((GLuint)arg0,(GLint*)arg1,(GLint*)arg2,(GLsizei)arg3,(GLuint*)arg4);

}

      
NAN_METHOD(getPerfMonitorGroupStringAMD) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetPerfMonitorGroupStringAMD((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(getPerfMonitorGroupsAMD) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetPerfMonitorGroupsAMD((GLint*)arg0,(GLsizei)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(selectPerfMonitorCountersAMD) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glSelectPerfMonitorCountersAMD((GLuint)arg0,(GLboolean)arg1,(GLuint)arg2,(GLint)arg3,(GLuint*)arg4);

}

      
NAN_METHOD(setMultisamplefvAMD) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glSetMultisamplefvAMD((GLenum)arg0,(GLuint)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(texStorageSparseAMD) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glbitfield");
    return;
  }
  
  GLbitfield arg6 = info[6]->Int32Value(ctx).ToChecked();


  glTexStorageSparseAMD((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLbitfield)arg6);

}

      
NAN_METHOD(textureStorageSparseAMD) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glbitfield");
    return;
  }
  
  GLbitfield arg7 = info[7]->Int32Value(ctx).ToChecked();


  glTextureStorageSparseAMD((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLbitfield)arg7);

}

      
NAN_METHOD(stencilOpValueAMD) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glStencilOpValueAMD((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(tessellationFactorAMD) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glTessellationFactorAMD((GLfloat)arg0);

}

      
NAN_METHOD(tessellationModeAMD) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glTessellationModeAMD((GLenum)arg0);

}

      
NAN_METHOD(blitFramebufferANGLE) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glbitfield");
    return;
  }
  
  GLbitfield arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();


  glBlitFramebufferANGLE((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLbitfield)arg8,(GLenum)arg9);

}

      
NAN_METHOD(renderbufferStorageMultisampleANGLE) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorageMultisampleANGLE((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(drawArraysInstancedANGLE) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawArraysInstancedANGLE((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(drawElementsInstancedANGLE) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedANGLE((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(vertexAttribDivisorANGLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribDivisorANGLE((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(beginQueryANGLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBeginQueryANGLE((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteQueriesANGLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteQueriesANGLE((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(endQueryANGLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glEndQueryANGLE((GLenum)arg0);

}

      
NAN_METHOD(genQueriesANGLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenQueriesANGLE((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getQueryObjecti64vANGLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glGetQueryObjecti64vANGLE((GLuint)arg0,(GLenum)arg1,(GLint64*)arg2);

}

      
NAN_METHOD(getQueryObjectivANGLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetQueryObjectivANGLE((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getQueryObjectui64vANGLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glGetQueryObjectui64vANGLE((GLuint)arg0,(GLenum)arg1,(GLuint64*)arg2);

}

      
NAN_METHOD(getQueryObjectuivANGLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetQueryObjectuivANGLE((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getQueryivANGLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetQueryivANGLE((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isQueryANGLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsQueryANGLE(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(queryCounterANGLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glQueryCounterANGLE((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(getTranslatedShaderSourceANGLE) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetTranslatedShaderSourceANGLE((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(copyTextureLevelsAPPLE) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glCopyTextureLevelsAPPLE((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(drawElementArrayAPPLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glDrawElementArrayAPPLE((GLenum)arg0,(GLint)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(drawRangeElementArrayAPPLE) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawRangeElementArrayAPPLE((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLint)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(elementPointerAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glElementPointerAPPLE((GLenum)arg0,(const void*)arg1);

}

      
NAN_METHOD(multiDrawElementArrayAPPLE) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glMultiDrawElementArrayAPPLE((GLenum)arg0,(const GLint*)arg1,(const GLsizei*)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(multiDrawRangeElementArrayAPPLE) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glMultiDrawRangeElementArrayAPPLE((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(const GLint*)arg3,(const GLsizei*)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(deleteFencesAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteFencesAPPLE((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(finishFenceAPPLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glFinishFenceAPPLE((GLuint)arg0);

}

      
NAN_METHOD(finishObjectAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glFinishObjectAPPLE((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(genFencesAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenFencesAPPLE((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(isFenceAPPLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsFenceAPPLE(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(setFenceAPPLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glSetFenceAPPLE((GLuint)arg0);

}

      
NAN_METHOD(testFenceAPPLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glTestFenceAPPLE(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(testObjectAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glTestObjectAPPLE(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bufferParameteriAPPLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBufferParameteriAPPLE((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(flushMappedBufferRangeAPPLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();


  glFlushMappedBufferRangeAPPLE((GLenum)arg0,(GLintptr)arg1,(GLsizeiptr)arg2);

}

      
NAN_METHOD(renderbufferStorageMultisampleAPPLE) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorageMultisampleAPPLE((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(resolveMultisampleFramebufferAPPLE) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glResolveMultisampleFramebufferAPPLE();

}

      
NAN_METHOD(getObjectParameterivAPPLE) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetObjectParameterivAPPLE((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(objectPurgeableAPPLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  GLenum retval = glObjectPurgeableAPPLE(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(objectUnpurgeableAPPLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  GLenum retval = glObjectUnpurgeableAPPLE(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getInteger64vAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint64* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint64*>(*arg1_tarray);
  }


  glGetInteger64vAPPLE((GLenum)arg0,(GLint64*)arg1);

}

      
NAN_METHOD(getTexParameterPointervAPPLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetTexParameterPointervAPPLE((GLenum)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(textureRangeAPPLE) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glTextureRangeAPPLE((GLenum)arg0,(GLsizei)arg1,(void*)arg2);

}

      
NAN_METHOD(bindVertexArrayAPPLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBindVertexArrayAPPLE((GLuint)arg0);

}

      
NAN_METHOD(deleteVertexArraysAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteVertexArraysAPPLE((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(genVertexArraysAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenVertexArraysAPPLE((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(isVertexArrayAPPLE) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsVertexArrayAPPLE(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(flushVertexArrayRangeAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glFlushVertexArrayRangeAPPLE((GLsizei)arg0,(void*)arg1);

}

      
NAN_METHOD(vertexArrayParameteriAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexArrayParameteriAPPLE((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(vertexArrayRangeAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glVertexArrayRangeAPPLE((GLsizei)arg0,(void*)arg1);

}

      
NAN_METHOD(disableVertexAttribAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glDisableVertexAttribAPPLE((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(enableVertexAttribAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glEnableVertexAttribAPPLE((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(isVertexAttribEnabledAPPLE) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLboolean retval = glIsVertexAttribEnabledAPPLE(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(mapVertexAttrib1dAPPLE) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  GLdouble* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLdouble*>(*arg6_tarray);
  }


  glMapVertexAttrib1dAPPLE((GLuint)arg0,(GLuint)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLint)arg4,(GLint)arg5,(const GLdouble*)arg6);

}

      
NAN_METHOD(mapVertexAttrib1fAPPLE) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  GLfloat* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLfloat*>(*arg6_tarray);
  }


  glMapVertexAttrib1fAPPLE((GLuint)arg0,(GLuint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLint)arg4,(GLint)arg5,(const GLfloat*)arg6);

}

      
NAN_METHOD(mapVertexAttrib2dAPPLE) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gldouble");
    return;
  }
  
  GLdouble arg6 = (GLdouble)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gldouble");
    return;
  }
  
  GLdouble arg7 = (GLdouble)info[7]->NumberValue(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glint");
    return;
  }
  
  GLint arg9 = info[9]->Int32Value(ctx).ToChecked();
  GLdouble* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<GLdouble*>(*arg10_tarray);
  }


  glMapVertexAttrib2dAPPLE((GLuint)arg0,(GLuint)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLint)arg4,(GLint)arg5,(GLdouble)arg6,(GLdouble)arg7,(GLint)arg8,(GLint)arg9,(const GLdouble*)arg10);

}

      
NAN_METHOD(mapVertexAttrib2fAPPLE) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glfloat");
    return;
  }
  
  GLfloat arg7 = (GLfloat)info[7]->NumberValue(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glint");
    return;
  }
  
  GLint arg9 = info[9]->Int32Value(ctx).ToChecked();
  GLfloat* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<GLfloat*>(*arg10_tarray);
  }


  glMapVertexAttrib2fAPPLE((GLuint)arg0,(GLuint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLint)arg4,(GLint)arg5,(GLfloat)arg6,(GLfloat)arg7,(GLint)arg8,(GLint)arg9,(const GLfloat*)arg10);

}

      
NAN_METHOD(clearDepthf) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();


  glClearDepthf((GLclampf)arg0);

}

      
NAN_METHOD(depthRangef) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampf");
    return;
  }
  
  GLclampf arg1 = (GLclampf)info[1]->NumberValue(ctx).ToChecked();


  glDepthRangef((GLclampf)arg0,(GLclampf)arg1);

}

      
NAN_METHOD(getShaderPrecisionFormat) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetShaderPrecisionFormat((GLenum)arg0,(GLenum)arg1,(GLint*)arg2,(GLint*)arg3);

}

      
NAN_METHOD(releaseShaderCompiler) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glReleaseShaderCompiler();

}

      
NAN_METHOD(shaderBinary) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glShaderBinary((GLsizei)arg0,(const GLuint*)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(memoryBarrierByRegion) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glMemoryBarrierByRegion((GLbitfield)arg0);

}

      
NAN_METHOD(primitiveBoundingBoxARB) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glfloat");
    return;
  }
  
  GLfloat arg7 = (GLfloat)info[7]->NumberValue(ctx).ToChecked();


  glPrimitiveBoundingBoxARB((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5,(GLfloat)arg6,(GLfloat)arg7);

}

      
NAN_METHOD(drawArraysInstancedBaseInstance) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawArraysInstancedBaseInstance((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLuint)arg4);

}

      
NAN_METHOD(drawElementsInstancedBaseInstance) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedBaseInstance((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4,(GLuint)arg5);

}

      
NAN_METHOD(drawElementsInstancedBaseVertexBaseInstance) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedBaseVertexBaseInstance((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4,(GLint)arg5,(GLuint)arg6);

}

      
NAN_METHOD(getImageHandleARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  GLuint64 retval = glGetImageHandleARB(arg0,arg1,arg2,arg3,arg4);

  info.GetReturnValue().Set((int32_t)retval);
      
}

      
NAN_METHOD(getTextureHandleARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLuint64 retval = glGetTextureHandleARB(arg0);

  info.GetReturnValue().Set((int32_t)retval);
      
}

      
NAN_METHOD(getTextureSamplerHandleARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLuint64 retval = glGetTextureSamplerHandleARB(arg0,arg1);

  info.GetReturnValue().Set((int32_t)retval);
      
}

      
NAN_METHOD(getVertexAttribLui64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glGetVertexAttribLui64vARB((GLuint)arg0,(GLenum)arg1,(GLuint64EXT*)arg2);

}

      
NAN_METHOD(isImageHandleResidentARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsImageHandleResidentARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isTextureHandleResidentARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsTextureHandleResidentARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(makeImageHandleNonResidentARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glMakeImageHandleNonResidentARB((GLuint64)arg0);

}

      
NAN_METHOD(makeImageHandleResidentARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMakeImageHandleResidentARB((GLuint64)arg0,(GLenum)arg1);

}

      
NAN_METHOD(makeTextureHandleNonResidentARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glMakeTextureHandleNonResidentARB((GLuint64)arg0);

}

      
NAN_METHOD(makeTextureHandleResidentARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glMakeTextureHandleResidentARB((GLuint64)arg0);

}

      
NAN_METHOD(programUniformHandleui64ARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniformHandleui64ARB((GLuint)arg0,(GLint)arg1,(GLuint64)arg2);

}

      
NAN_METHOD(programUniformHandleui64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glProgramUniformHandleui64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64*)arg3);

}

      
NAN_METHOD(uniformHandleui64ARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();


  glUniformHandleui64ARB((GLint)arg0,(GLuint64)arg1);

}

      
NAN_METHOD(uniformHandleui64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glUniformHandleui64vARB((GLint)arg0,(GLsizei)arg1,(const GLuint64*)arg2);

}

      
NAN_METHOD(vertexAttribL1ui64ARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribL1ui64ARB((GLuint)arg0,(GLuint64EXT)arg1);

}

      
NAN_METHOD(vertexAttribL1ui64vARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL1ui64vARB((GLuint)arg0,(const GLuint64EXT*)arg1);

}

      
NAN_METHOD(bindFragDataLocationIndexed) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glBindFragDataLocationIndexed((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(const GLchar*)arg3);

}

      
NAN_METHOD(getFragDataIndex) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLint retval = glGetFragDataIndex(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bufferStorage) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbitfield");
    return;
  }
  
  GLbitfield arg3 = info[3]->Int32Value(ctx).ToChecked();


  glBufferStorage((GLenum)arg0,(GLsizeiptr)arg1,(const void*)arg2,(GLbitfield)arg3);

}

      
NAN_METHOD(clearBufferData) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glClearBufferData((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(const void*)arg4);

}

      
NAN_METHOD(clearBufferSubData) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg3 = (GLsizeiptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glClearBufferSubData((GLenum)arg0,(GLenum)arg1,(GLintptr)arg2,(GLsizeiptr)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(clearNamedBufferDataEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glClearNamedBufferDataEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(const void*)arg4);

}

      
NAN_METHOD(clearNamedBufferSubDataEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg3 = (GLsizeiptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glClearNamedBufferSubDataEXT((GLuint)arg0,(GLenum)arg1,(GLintptr)arg2,(GLsizeiptr)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(clearTexImage) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glClearTexImage((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLenum)arg3,(const void*)arg4);

}

      
NAN_METHOD(clearTexSubImage) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glClearTexSubImage((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(const void*)arg10);

}

      
NAN_METHOD(clipControl) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glClipControl((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(clampColorARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glClampColorARB((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(dispatchCompute) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glDispatchCompute((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(dispatchComputeIndirect) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glintptr");
    return;
  }
  
  GLintptr arg0 = (GLintptr)info[0]->Uint32Value(ctx).ToChecked();


  glDispatchComputeIndirect((GLintptr)arg0);

}

      
NAN_METHOD(dispatchComputeGroupSizeARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glDispatchComputeGroupSizeARB((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5);

}

      
NAN_METHOD(copyBufferSubData) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glCopyBufferSubData((GLenum)arg0,(GLenum)arg1,(GLintptr)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(copyImageSubData) {
  if (info.Length() != 15) {
    Nan::ThrowError("Expected 15 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glint");
    return;
  }
  
  GLint arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glint");
    return;
  }
  
  GLint arg10 = info[10]->Int32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glint");
    return;
  }
  
  GLint arg11 = info[11]->Int32Value(ctx).ToChecked();
  if (!info[12]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 13, expected a glsizei");
    return;
  }
  
  GLsizei arg12 = info[12]->Uint32Value(ctx).ToChecked();
  if (!info[13]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 14, expected a glsizei");
    return;
  }
  
  GLsizei arg13 = info[13]->Uint32Value(ctx).ToChecked();
  if (!info[14]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 15, expected a glsizei");
    return;
  }
  
  GLsizei arg14 = info[14]->Uint32Value(ctx).ToChecked();


  glCopyImageSubData((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLuint)arg6,(GLenum)arg7,(GLint)arg8,(GLint)arg9,(GLint)arg10,(GLint)arg11,(GLsizei)arg12,(GLsizei)arg13,(GLsizei)arg14);

}

      
NAN_METHOD(debugMessageControlARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glDebugMessageControlARB((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(const GLuint*)arg4,(GLboolean)arg5);

}

      
NAN_METHOD(debugMessageInsertARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLchar* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLchar*>(*arg5_tarray);
  }


  glDebugMessageInsertARB((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLenum)arg3,(GLsizei)arg4,(const GLchar*)arg5);

}

      
NAN_METHOD(getDebugMessageLogARB) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }
  GLenum* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLenum*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLsizei* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLsizei*>(*arg6_tarray);
  }
  GLchar* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLchar*>(*arg7_tarray);
  }


  GLuint retval = glGetDebugMessageLogARB(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindTextureUnit) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindTextureUnit((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(blitNamedFramebuffer) {
  if (info.Length() != 12) {
    Nan::ThrowError("Expected 12 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glint");
    return;
  }
  
  GLint arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glbitfield");
    return;
  }
  
  GLbitfield arg10 = info[10]->Int32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glenum");
    return;
  }
  
  GLenum arg11 = info[11]->Int32Value(ctx).ToChecked();


  glBlitNamedFramebuffer((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLint)arg8,(GLint)arg9,(GLbitfield)arg10,(GLenum)arg11);

}

      
NAN_METHOD(checkNamedFramebufferStatus) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLenum retval = glCheckNamedFramebufferStatus(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(clearNamedBufferData) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glClearNamedBufferData((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(const void*)arg4);

}

      
NAN_METHOD(clearNamedBufferSubData) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg3 = (GLsizeiptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glClearNamedBufferSubData((GLuint)arg0,(GLenum)arg1,(GLintptr)arg2,(GLsizeiptr)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(clearNamedFramebufferfi) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glClearNamedFramebufferfi((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLfloat)arg3,(GLint)arg4);

}

      
NAN_METHOD(clearNamedFramebufferfv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glClearNamedFramebufferfv((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(clearNamedFramebufferiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glClearNamedFramebufferiv((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(clearNamedFramebufferuiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glClearNamedFramebufferuiv((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(compressedTextureSubImage1D) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glCompressedTextureSubImage1D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLenum)arg4,(GLsizei)arg5,(const void*)arg6);

}

      
NAN_METHOD(compressedTextureSubImage2D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glCompressedTextureSubImage2D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLenum)arg6,(GLsizei)arg7,(const void*)arg8);

}

      
NAN_METHOD(compressedTextureSubImage3D) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glsizei");
    return;
  }
  
  GLsizei arg9 = info[9]->Uint32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glCompressedTextureSubImage3D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLsizei)arg9,(const void*)arg10);

}

      
NAN_METHOD(copyNamedBufferSubData) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glCopyNamedBufferSubData((GLuint)arg0,(GLuint)arg1,(GLintptr)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(copyTextureSubImage1D) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glCopyTextureSubImage1D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(copyTextureSubImage2D) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glCopyTextureSubImage2D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLsizei)arg6,(GLsizei)arg7);

}

      
NAN_METHOD(copyTextureSubImage3D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glsizei");
    return;
  }
  
  GLsizei arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glCopyTextureSubImage3D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLsizei)arg7,(GLsizei)arg8);

}

      
NAN_METHOD(createBuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateBuffers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(createFramebuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateFramebuffers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(createProgramPipelines) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateProgramPipelines((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(createQueries) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glCreateQueries((GLenum)arg0,(GLsizei)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(createRenderbuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateRenderbuffers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(createSamplers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateSamplers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(createTextures) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glCreateTextures((GLenum)arg0,(GLsizei)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(createTransformFeedbacks) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateTransformFeedbacks((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(createVertexArrays) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateVertexArrays((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(disableVertexArrayAttrib) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDisableVertexArrayAttrib((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(enableVertexArrayAttrib) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glEnableVertexArrayAttrib((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(flushMappedNamedBufferRange) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();


  glFlushMappedNamedBufferRange((GLuint)arg0,(GLintptr)arg1,(GLsizeiptr)arg2);

}

      
NAN_METHOD(generateTextureMipmap) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glGenerateTextureMipmap((GLuint)arg0);

}

      
NAN_METHOD(getCompressedTextureImage) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetCompressedTextureImage((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(void*)arg3);

}

      
NAN_METHOD(getNamedBufferParameteri64v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glGetNamedBufferParameteri64v((GLuint)arg0,(GLenum)arg1,(GLint64*)arg2);

}

      
NAN_METHOD(getNamedBufferParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetNamedBufferParameteriv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getNamedBufferPointerv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetNamedBufferPointerv((GLuint)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(getNamedBufferSubData) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetNamedBufferSubData((GLuint)arg0,(GLintptr)arg1,(GLsizeiptr)arg2,(void*)arg3);

}

      
NAN_METHOD(getNamedFramebufferAttachmentParameteriv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetNamedFramebufferAttachmentParameteriv((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getNamedFramebufferParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetNamedFramebufferParameteriv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getNamedRenderbufferParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetNamedRenderbufferParameteriv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getQueryBufferObjecti64v) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();


  glGetQueryBufferObjecti64v((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLintptr)arg3);

}

      
NAN_METHOD(getQueryBufferObjectiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();


  glGetQueryBufferObjectiv((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLintptr)arg3);

}

      
NAN_METHOD(getQueryBufferObjectui64v) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();


  glGetQueryBufferObjectui64v((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLintptr)arg3);

}

      
NAN_METHOD(getQueryBufferObjectuiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();


  glGetQueryBufferObjectuiv((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLintptr)arg3);

}

      
NAN_METHOD(getTextureImage) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glGetTextureImage((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLenum)arg3,(GLsizei)arg4,(void*)arg5);

}

      
NAN_METHOD(getTextureLevelParameterfv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetTextureLevelParameterfv((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getTextureLevelParameteriv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetTextureLevelParameteriv((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getTextureParameterIiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTextureParameterIiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getTextureParameterIuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetTextureParameterIuiv((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getTextureParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetTextureParameterfv((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getTextureParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTextureParameteriv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getTransformFeedbacki64_v) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glGetTransformFeedbacki64_v((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint64*)arg3);

}

      
NAN_METHOD(getTransformFeedbacki_v) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetTransformFeedbacki_v((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getTransformFeedbackiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTransformFeedbackiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVertexArrayIndexed64iv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glGetVertexArrayIndexed64iv((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint64*)arg3);

}

      
NAN_METHOD(getVertexArrayIndexediv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetVertexArrayIndexediv((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getVertexArrayiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVertexArrayiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(invalidateNamedFramebufferData) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }


  glInvalidateNamedFramebufferData((GLuint)arg0,(GLsizei)arg1,(const GLenum*)arg2);

}

      
NAN_METHOD(invalidateNamedFramebufferSubData) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glInvalidateNamedFramebufferSubData((GLuint)arg0,(GLsizei)arg1,(const GLenum*)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6);

}

      
NAN_METHOD(namedBufferData) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glNamedBufferData((GLuint)arg0,(GLsizeiptr)arg1,(const void*)arg2,(GLenum)arg3);

}

      
NAN_METHOD(namedBufferStorage) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbitfield");
    return;
  }
  
  GLbitfield arg3 = info[3]->Int32Value(ctx).ToChecked();


  glNamedBufferStorage((GLuint)arg0,(GLsizeiptr)arg1,(const void*)arg2,(GLbitfield)arg3);

}

      
NAN_METHOD(namedBufferSubData) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glNamedBufferSubData((GLuint)arg0,(GLintptr)arg1,(GLsizeiptr)arg2,(const void*)arg3);

}

      
NAN_METHOD(namedFramebufferDrawBuffer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glNamedFramebufferDrawBuffer((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(namedFramebufferDrawBuffers) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }


  glNamedFramebufferDrawBuffers((GLuint)arg0,(GLsizei)arg1,(const GLenum*)arg2);

}

      
NAN_METHOD(namedFramebufferParameteri) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glNamedFramebufferParameteri((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(namedFramebufferReadBuffer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glNamedFramebufferReadBuffer((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(namedFramebufferRenderbuffer) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glNamedFramebufferRenderbuffer((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3);

}

      
NAN_METHOD(namedFramebufferTexture) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTexture((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3);

}

      
NAN_METHOD(namedFramebufferTextureLayer) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTextureLayer((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(namedRenderbufferStorage) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glNamedRenderbufferStorage((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(namedRenderbufferStorageMultisample) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glNamedRenderbufferStorageMultisample((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(textureBuffer) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTextureBuffer((GLuint)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(textureBufferRange) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glTextureBufferRange((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(textureParameterIiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glTextureParameterIiv((GLuint)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(textureParameterIuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glTextureParameterIuiv((GLuint)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(textureParameterf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glTextureParameterf((GLuint)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(textureParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glTextureParameterfv((GLuint)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(textureParameteri) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTextureParameteri((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(textureParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glTextureParameteriv((GLuint)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(textureStorage1D) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glTextureStorage1D((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(textureStorage2D) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glTextureStorage2D((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(textureStorage2DMultisample) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glTextureStorage2DMultisample((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLboolean)arg5);

}

      
NAN_METHOD(textureStorage3D) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glTextureStorage3D((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(textureStorage3DMultisample) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glTextureStorage3DMultisample((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6);

}

      
NAN_METHOD(textureSubImage1D) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glTextureSubImage1D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(textureSubImage2D) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glTextureSubImage2D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLenum)arg6,(GLenum)arg7,(const void*)arg8);

}

      
NAN_METHOD(textureSubImage3D) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glTextureSubImage3D((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(const void*)arg10);

}

      
NAN_METHOD(transformFeedbackBufferBase) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTransformFeedbackBufferBase((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(transformFeedbackBufferRange) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glTransformFeedbackBufferRange((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(unmapNamedBuffer) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glUnmapNamedBuffer(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(vertexArrayAttribBinding) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexArrayAttribBinding((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(vertexArrayAttribFormat) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glboolean");
    return;
  }
  
  GLboolean arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glVertexArrayAttribFormat((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLboolean)arg4,(GLuint)arg5);

}

      
NAN_METHOD(vertexArrayAttribIFormat) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayAttribIFormat((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLuint)arg4);

}

      
NAN_METHOD(vertexArrayAttribLFormat) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayAttribLFormat((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLuint)arg4);

}

      
NAN_METHOD(vertexArrayBindingDivisor) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexArrayBindingDivisor((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(vertexArrayElementBuffer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexArrayElementBuffer((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexArrayVertexBuffer) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexBuffer((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(vertexArrayVertexBuffers) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLintptr* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<intptr> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLintptr*>(*arg4_tarray);
  }
  GLsizei* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLsizei*>(*arg5_tarray);
  }


  glVertexArrayVertexBuffers((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLuint*)arg3,(const GLintptr*)arg4,(const GLsizei*)arg5);

}

      
NAN_METHOD(drawBuffersARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLenum* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLenum*>(*arg1_tarray);
  }


  glDrawBuffersARB((GLsizei)arg0,(const GLenum*)arg1);

}

      
NAN_METHOD(blendEquationSeparateiARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendEquationSeparateiARB((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(blendEquationiARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendEquationiARB((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(blendFuncSeparateiARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glBlendFuncSeparateiARB((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4);

}

      
NAN_METHOD(blendFunciARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendFunciARB((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(drawElementsBaseVertex) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glDrawElementsBaseVertex((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(void*)arg3,(GLint)arg4);

}

      
NAN_METHOD(drawElementsInstancedBaseVertex) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glDrawElementsInstancedBaseVertex((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4,(GLint)arg5);

}

      
NAN_METHOD(drawRangeElementsBaseVertex) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glDrawRangeElementsBaseVertex((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(GLenum)arg4,(void*)arg5,(GLint)arg6);

}

      
NAN_METHOD(multiDrawElementsBaseVertex) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLsizei* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLsizei*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsArray()) {
    Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
    return;
  }
  
  auto array3 = info[0].As<v8::Array>();
  void** arg3 = static_cast<void**>(alloca(sizeof(void*)*array3->Length()));
    
  for (unsigned int i=0; i<array3->Length(); i++) {
    auto val = array3->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg3[i] = reinterpret_cast<void*>(*item); 
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLint* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLint*>(*arg5_tarray);
  }


  glMultiDrawElementsBaseVertex((GLenum)arg0,(GLsizei*)arg1,(GLenum)arg2,(void**)arg3,(GLsizei)arg4,(GLint*)arg5);

}

      
NAN_METHOD(drawArraysIndirect) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glDrawArraysIndirect((GLenum)arg0,(const void*)arg1);

}

      
NAN_METHOD(drawElementsIndirect) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glDrawElementsIndirect((GLenum)arg0,(GLenum)arg1,(const void*)arg2);

}

      
NAN_METHOD(framebufferParameteri) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glFramebufferParameteri((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(getFramebufferParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetFramebufferParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getNamedFramebufferParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetNamedFramebufferParameterivEXT((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(namedFramebufferParameteriEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glNamedFramebufferParameteriEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(bindFramebuffer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindFramebuffer((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bindRenderbuffer) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindRenderbuffer((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(blitFramebuffer) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glbitfield");
    return;
  }
  
  GLbitfield arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();


  glBlitFramebuffer((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLbitfield)arg8,(GLenum)arg9);

}

      
NAN_METHOD(checkFramebufferStatus) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLenum retval = glCheckFramebufferStatus(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(deleteFramebuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteFramebuffers((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(deleteRenderbuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteRenderbuffers((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(framebufferRenderbuffer) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glFramebufferRenderbuffer((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3);

}

      
NAN_METHOD(framebufferTexture1D) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTexture1D((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4);

}

      
NAN_METHOD(framebufferTexture2D) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTexture2D((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4);

}

      
NAN_METHOD(framebufferTexture3D) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glFramebufferTexture3D((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4,(GLint)arg5);

}

      
NAN_METHOD(framebufferTextureLayer) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTextureLayer((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(genFramebuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenFramebuffers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(genRenderbuffers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenRenderbuffers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(generateMipmap) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glGenerateMipmap((GLenum)arg0);

}

      
NAN_METHOD(getFramebufferAttachmentParameteriv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetFramebufferAttachmentParameteriv((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getRenderbufferParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetRenderbufferParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isFramebuffer) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsFramebuffer(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isRenderbuffer) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsRenderbuffer(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(renderbufferStorage) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorage((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(renderbufferStorageMultisample) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorageMultisample((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(framebufferTextureARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glFramebufferTextureARB((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3);

}

      
NAN_METHOD(framebufferTextureFaceARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTextureFaceARB((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLenum)arg4);

}

      
NAN_METHOD(framebufferTextureLayerARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTextureLayerARB((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(programParameteriARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glProgramParameteriARB((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(getProgramBinary) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLenum* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLenum*>(*arg3_tarray);
  }
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetProgramBinary((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLenum*)arg3,(void*)arg4);

}

      
NAN_METHOD(programBinary) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glProgramBinary((GLuint)arg0,(GLenum)arg1,(const void*)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(programParameteri) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glProgramParameteri((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(getCompressedTextureSubImage) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glsizei");
    return;
  }
  
  GLsizei arg8 = info[8]->Uint32Value(ctx).ToChecked();
  void* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<void*>(*arg9_tarray);
  }


  glGetCompressedTextureSubImage((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLsizei)arg8,(void*)arg9);

}

      
NAN_METHOD(getTextureSubImage) {
  if (info.Length() != 12) {
    Nan::ThrowError("Expected 12 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glsizei");
    return;
  }
  
  GLsizei arg10 = info[10]->Uint32Value(ctx).ToChecked();
  void* arg11;

  if (info[11]->IsNullOrUndefined()) {
    arg11 = nullptr;
  } else {
    if (!info[11]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 12, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg11_tarray(info[11]);
    arg11 = reinterpret_cast<void*>(*arg11_tarray);
  }


  glGetTextureSubImage((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(GLsizei)arg10,(void*)arg11);

}

      
NAN_METHOD(specializeShaderARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glSpecializeShaderARB((GLuint)arg0,(const GLchar*)arg1,(GLuint)arg2,(const GLuint*)arg3,(const GLuint*)arg4);

}

      
NAN_METHOD(getUniformdv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetUniformdv((GLuint)arg0,(GLint)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(uniform1d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glUniform1d((GLint)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(uniform1dv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glUniform1dv((GLint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(uniform2d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glUniform2d((GLint)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(uniform2dv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glUniform2dv((GLint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(uniform3d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glUniform3d((GLint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(uniform3dv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glUniform3dv((GLint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(uniform4d) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glUniform4d((GLint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(uniform4dv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glUniform4dv((GLint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(uniformMatrix2dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix2dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix2x3dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix2x3dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix2x4dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix2x4dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix3dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix3dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix3x2dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix3x2dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix3x4dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix3x4dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix4dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix4dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix4x2dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix4x2dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(uniformMatrix4x3dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glUniformMatrix4x3dv((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(getUniformi64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glGetUniformi64vARB((GLuint)arg0,(GLint)arg1,(GLint64*)arg2);

}

      
NAN_METHOD(getUniformui64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glGetUniformui64vARB((GLuint)arg0,(GLint)arg1,(GLuint64*)arg2);

}

      
NAN_METHOD(getnUniformi64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glGetnUniformi64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLint64*)arg3);

}

      
NAN_METHOD(getnUniformui64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glGetnUniformui64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLuint64*)arg3);

}

      
NAN_METHOD(programUniform1i64ARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64");
    return;
  }
  
  GLint64 arg2 = (GLint64)info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniform1i64ARB((GLuint)arg0,(GLint)arg1,(GLint64)arg2);

}

      
NAN_METHOD(programUniform1i64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glProgramUniform1i64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64*)arg3);

}

      
NAN_METHOD(programUniform1ui64ARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniform1ui64ARB((GLuint)arg0,(GLint)arg1,(GLuint64)arg2);

}

      
NAN_METHOD(programUniform1ui64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glProgramUniform1ui64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64*)arg3);

}

      
NAN_METHOD(programUniform2i64ARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64");
    return;
  }
  
  GLint64 arg2 = (GLint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64");
    return;
  }
  
  GLint64 arg3 = (GLint64)info[3]->Uint32Value(ctx).ToChecked();


  glProgramUniform2i64ARB((GLuint)arg0,(GLint)arg1,(GLint64)arg2,(GLint64)arg3);

}

      
NAN_METHOD(programUniform2i64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glProgramUniform2i64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64*)arg3);

}

      
NAN_METHOD(programUniform2ui64ARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64");
    return;
  }
  
  GLuint64 arg3 = (GLuint64)info[3]->Uint32Value(ctx).ToChecked();


  glProgramUniform2ui64ARB((GLuint)arg0,(GLint)arg1,(GLuint64)arg2,(GLuint64)arg3);

}

      
NAN_METHOD(programUniform2ui64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glProgramUniform2ui64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64*)arg3);

}

      
NAN_METHOD(programUniform3i64ARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64");
    return;
  }
  
  GLint64 arg2 = (GLint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64");
    return;
  }
  
  GLint64 arg3 = (GLint64)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint64");
    return;
  }
  
  GLint64 arg4 = (GLint64)info[4]->Uint32Value(ctx).ToChecked();


  glProgramUniform3i64ARB((GLuint)arg0,(GLint)arg1,(GLint64)arg2,(GLint64)arg3,(GLint64)arg4);

}

      
NAN_METHOD(programUniform3i64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glProgramUniform3i64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64*)arg3);

}

      
NAN_METHOD(programUniform3ui64ARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64");
    return;
  }
  
  GLuint64 arg3 = (GLuint64)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint64");
    return;
  }
  
  GLuint64 arg4 = (GLuint64)info[4]->Uint32Value(ctx).ToChecked();


  glProgramUniform3ui64ARB((GLuint)arg0,(GLint)arg1,(GLuint64)arg2,(GLuint64)arg3,(GLuint64)arg4);

}

      
NAN_METHOD(programUniform3ui64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glProgramUniform3ui64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64*)arg3);

}

      
NAN_METHOD(programUniform4i64ARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64");
    return;
  }
  
  GLint64 arg2 = (GLint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64");
    return;
  }
  
  GLint64 arg3 = (GLint64)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint64");
    return;
  }
  
  GLint64 arg4 = (GLint64)info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint64");
    return;
  }
  
  GLint64 arg5 = (GLint64)info[5]->Uint32Value(ctx).ToChecked();


  glProgramUniform4i64ARB((GLuint)arg0,(GLint)arg1,(GLint64)arg2,(GLint64)arg3,(GLint64)arg4,(GLint64)arg5);

}

      
NAN_METHOD(programUniform4i64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glProgramUniform4i64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64*)arg3);

}

      
NAN_METHOD(programUniform4ui64ARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64");
    return;
  }
  
  GLuint64 arg3 = (GLuint64)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint64");
    return;
  }
  
  GLuint64 arg4 = (GLuint64)info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint64");
    return;
  }
  
  GLuint64 arg5 = (GLuint64)info[5]->Uint32Value(ctx).ToChecked();


  glProgramUniform4ui64ARB((GLuint)arg0,(GLint)arg1,(GLuint64)arg2,(GLuint64)arg3,(GLuint64)arg4,(GLuint64)arg5);

}

      
NAN_METHOD(programUniform4ui64vARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glProgramUniform4ui64vARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64*)arg3);

}

      
NAN_METHOD(uniform1i64ARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64");
    return;
  }
  
  GLint64 arg1 = (GLint64)info[1]->Uint32Value(ctx).ToChecked();


  glUniform1i64ARB((GLint)arg0,(GLint64)arg1);

}

      
NAN_METHOD(uniform1i64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glUniform1i64vARB((GLint)arg0,(GLsizei)arg1,(const GLint64*)arg2);

}

      
NAN_METHOD(uniform1ui64ARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();


  glUniform1ui64ARB((GLint)arg0,(GLuint64)arg1);

}

      
NAN_METHOD(uniform1ui64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glUniform1ui64vARB((GLint)arg0,(GLsizei)arg1,(const GLuint64*)arg2);

}

      
NAN_METHOD(uniform2i64ARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64");
    return;
  }
  
  GLint64 arg1 = (GLint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64");
    return;
  }
  
  GLint64 arg2 = (GLint64)info[2]->Uint32Value(ctx).ToChecked();


  glUniform2i64ARB((GLint)arg0,(GLint64)arg1,(GLint64)arg2);

}

      
NAN_METHOD(uniform2i64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glUniform2i64vARB((GLint)arg0,(GLsizei)arg1,(const GLint64*)arg2);

}

      
NAN_METHOD(uniform2ui64ARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();


  glUniform2ui64ARB((GLint)arg0,(GLuint64)arg1,(GLuint64)arg2);

}

      
NAN_METHOD(uniform2ui64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glUniform2ui64vARB((GLint)arg0,(GLsizei)arg1,(const GLuint64*)arg2);

}

      
NAN_METHOD(uniform3i64ARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64");
    return;
  }
  
  GLint64 arg1 = (GLint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64");
    return;
  }
  
  GLint64 arg2 = (GLint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64");
    return;
  }
  
  GLint64 arg3 = (GLint64)info[3]->Uint32Value(ctx).ToChecked();


  glUniform3i64ARB((GLint)arg0,(GLint64)arg1,(GLint64)arg2,(GLint64)arg3);

}

      
NAN_METHOD(uniform3i64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glUniform3i64vARB((GLint)arg0,(GLsizei)arg1,(const GLint64*)arg2);

}

      
NAN_METHOD(uniform3ui64ARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64");
    return;
  }
  
  GLuint64 arg3 = (GLuint64)info[3]->Uint32Value(ctx).ToChecked();


  glUniform3ui64ARB((GLint)arg0,(GLuint64)arg1,(GLuint64)arg2,(GLuint64)arg3);

}

      
NAN_METHOD(uniform3ui64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glUniform3ui64vARB((GLint)arg0,(GLsizei)arg1,(const GLuint64*)arg2);

}

      
NAN_METHOD(uniform4i64ARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64");
    return;
  }
  
  GLint64 arg1 = (GLint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64");
    return;
  }
  
  GLint64 arg2 = (GLint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64");
    return;
  }
  
  GLint64 arg3 = (GLint64)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint64");
    return;
  }
  
  GLint64 arg4 = (GLint64)info[4]->Uint32Value(ctx).ToChecked();


  glUniform4i64ARB((GLint)arg0,(GLint64)arg1,(GLint64)arg2,(GLint64)arg3,(GLint64)arg4);

}

      
NAN_METHOD(uniform4i64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glUniform4i64vARB((GLint)arg0,(GLsizei)arg1,(const GLint64*)arg2);

}

      
NAN_METHOD(uniform4ui64ARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64");
    return;
  }
  
  GLuint64 arg3 = (GLuint64)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint64");
    return;
  }
  
  GLuint64 arg4 = (GLuint64)info[4]->Uint32Value(ctx).ToChecked();


  glUniform4ui64ARB((GLint)arg0,(GLuint64)arg1,(GLuint64)arg2,(GLuint64)arg3,(GLuint64)arg4);

}

      
NAN_METHOD(uniform4ui64vARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glUniform4ui64vARB((GLint)arg0,(GLsizei)arg1,(const GLuint64*)arg2);

}

      
NAN_METHOD(colorSubTable) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glColorSubTable((GLenum)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLenum)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(colorTable) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glColorTable((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(colorTableParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glColorTableParameterfv((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(colorTableParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glColorTableParameteriv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(convolutionFilter1D) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glConvolutionFilter1D((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(convolutionFilter2D) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glConvolutionFilter2D((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(convolutionParameterf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glConvolutionParameterf((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(convolutionParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glConvolutionParameterfv((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(convolutionParameteri) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glConvolutionParameteri((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(convolutionParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glConvolutionParameteriv((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(copyColorSubTable) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glCopyColorSubTable((GLenum)arg0,(GLsizei)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(copyColorTable) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glCopyColorTable((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(copyConvolutionFilter1D) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glCopyConvolutionFilter1D((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(copyConvolutionFilter2D) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glCopyConvolutionFilter2D((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(getColorTable) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetColorTable((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(void*)arg3);

}

      
NAN_METHOD(getColorTableParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetColorTableParameterfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getColorTableParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetColorTableParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getConvolutionFilter) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetConvolutionFilter((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(void*)arg3);

}

      
NAN_METHOD(getConvolutionParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetConvolutionParameterfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getConvolutionParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetConvolutionParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getHistogram) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetHistogram((GLenum)arg0,(GLboolean)arg1,(GLenum)arg2,(GLenum)arg3,(void*)arg4);

}

      
NAN_METHOD(getHistogramParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetHistogramParameterfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getHistogramParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetHistogramParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getMinmax) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetMinmax((GLenum)arg0,(GLboolean)arg1,(GLenum)arg2,(GLenum)arg3,(void*)arg4);

}

      
NAN_METHOD(getMinmaxParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetMinmaxParameterfv((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getMinmaxParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetMinmaxParameteriv((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getSeparableFilter) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glGetSeparableFilter((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(void*)arg3,(void*)arg4,(void*)arg5);

}

      
NAN_METHOD(histogram) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glHistogram((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLboolean)arg3);

}

      
NAN_METHOD(minmax) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glMinmax((GLenum)arg0,(GLenum)arg1,(GLboolean)arg2);

}

      
NAN_METHOD(resetHistogram) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glResetHistogram((GLenum)arg0);

}

      
NAN_METHOD(resetMinmax) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glResetMinmax((GLenum)arg0);

}

      
NAN_METHOD(separableFilter2D) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glSeparableFilter2D((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6,(const void*)arg7);

}

      
NAN_METHOD(multiDrawArraysIndirectCountARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiDrawArraysIndirectCountARB((GLenum)arg0,(const void*)arg1,(GLintptr)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(multiDrawElementsIndirectCountARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glMultiDrawElementsIndirectCountARB((GLenum)arg0,(GLenum)arg1,(const void*)arg2,(GLintptr)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(drawArraysInstancedARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawArraysInstancedARB((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(drawElementsInstancedARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedARB((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(vertexAttribDivisorARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribDivisorARB((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(getInternalformativ) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glGetInternalformativ((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(GLint*)arg4);

}

      
NAN_METHOD(getInternalformati64v) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLint64* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint64*>(*arg4_tarray);
  }


  glGetInternalformati64v((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(GLint64*)arg4);

}

      
NAN_METHOD(invalidateBufferData) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glInvalidateBufferData((GLuint)arg0);

}

      
NAN_METHOD(invalidateBufferSubData) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();


  glInvalidateBufferSubData((GLuint)arg0,(GLintptr)arg1,(GLsizeiptr)arg2);

}

      
NAN_METHOD(invalidateFramebuffer) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }


  glInvalidateFramebuffer((GLenum)arg0,(GLsizei)arg1,(const GLenum*)arg2);

}

      
NAN_METHOD(invalidateSubFramebuffer) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glInvalidateSubFramebuffer((GLenum)arg0,(GLsizei)arg1,(const GLenum*)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6);

}

      
NAN_METHOD(invalidateTexImage) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glInvalidateTexImage((GLuint)arg0,(GLint)arg1);

}

      
NAN_METHOD(invalidateTexSubImage) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glInvalidateTexSubImage((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7);

}

      
NAN_METHOD(flushMappedBufferRange) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();


  glFlushMappedBufferRange((GLenum)arg0,(GLintptr)arg1,(GLsizeiptr)arg2);

}

      
NAN_METHOD(currentPaletteMatrixARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glCurrentPaletteMatrixARB((GLint)arg0);

}

      
NAN_METHOD(matrixIndexPointerARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glMatrixIndexPointerARB((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(void*)arg3);

}

      
NAN_METHOD(matrixIndexubvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glMatrixIndexubvARB((GLint)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(matrixIndexuivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glMatrixIndexuivARB((GLint)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(matrixIndexusvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glMatrixIndexusvARB((GLint)arg0,(GLushort*)arg1);

}

      
NAN_METHOD(bindBuffersBase) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glBindBuffersBase((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(bindBuffersRange) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLintptr* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<intptr> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLintptr*>(*arg4_tarray);
  }
  GLsizeiptr* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLsizeiptr*>(*arg5_tarray);
  }


  glBindBuffersRange((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLuint*)arg3,(const GLintptr*)arg4,(const GLsizeiptr*)arg5);

}

      
NAN_METHOD(bindImageTextures) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glBindImageTextures((GLuint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(bindSamplers) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glBindSamplers((GLuint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(bindTextures) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glBindTextures((GLuint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(bindVertexBuffers) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }
  GLintptr* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<intptr> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLintptr*>(*arg3_tarray);
  }
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }


  glBindVertexBuffers((GLuint)arg0,(GLsizei)arg1,(const GLuint*)arg2,(const GLintptr*)arg3,(const GLsizei*)arg4);

}

      
NAN_METHOD(multiDrawArraysIndirect) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glMultiDrawArraysIndirect((GLenum)arg0,(const void*)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(multiDrawElementsIndirect) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiDrawElementsIndirect((GLenum)arg0,(GLenum)arg1,(const void*)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(sampleCoverageARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glSampleCoverageARB((GLclampf)arg0,(GLboolean)arg1);

}

      
NAN_METHOD(activeTextureARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glActiveTextureARB((GLenum)arg0);

}

      
NAN_METHOD(clientActiveTextureARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glClientActiveTextureARB((GLenum)arg0);

}

      
NAN_METHOD(multiTexCoord1dARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glMultiTexCoord1dARB((GLenum)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(multiTexCoord1dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord1dvARB((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord1fARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glMultiTexCoord1fARB((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(multiTexCoord1fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord1fvARB((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord1iARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMultiTexCoord1iARB((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(multiTexCoord1ivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord1ivARB((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord1sARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMultiTexCoord1sARB((GLenum)arg0,(GLshort)arg1);

}

      
NAN_METHOD(multiTexCoord1svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord1svARB((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(multiTexCoord2dARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glMultiTexCoord2dARB((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(multiTexCoord2dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord2dvARB((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord2fARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glMultiTexCoord2fARB((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(multiTexCoord2fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord2fvARB((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord2iARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glMultiTexCoord2iARB((GLenum)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(multiTexCoord2ivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord2ivARB((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord2sARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glMultiTexCoord2sARB((GLenum)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(multiTexCoord2svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord2svARB((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(multiTexCoord3dARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glMultiTexCoord3dARB((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(multiTexCoord3dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord3dvARB((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord3fARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glMultiTexCoord3fARB((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(multiTexCoord3fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord3fvARB((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord3iARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glMultiTexCoord3iARB((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(multiTexCoord3ivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord3ivARB((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord3sARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glMultiTexCoord3sARB((GLenum)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(multiTexCoord3svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord3svARB((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(multiTexCoord4dARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glMultiTexCoord4dARB((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(multiTexCoord4dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glMultiTexCoord4dvARB((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(multiTexCoord4fARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glMultiTexCoord4fARB((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(multiTexCoord4fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMultiTexCoord4fvARB((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(multiTexCoord4iARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glMultiTexCoord4iARB((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(multiTexCoord4ivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glMultiTexCoord4ivARB((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(multiTexCoord4sARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glshort");
    return;
  }
  
  GLshort arg4 = info[4]->Int32Value(ctx).ToChecked();


  glMultiTexCoord4sARB((GLenum)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3,(GLshort)arg4);

}

      
NAN_METHOD(multiTexCoord4svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glMultiTexCoord4svARB((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(beginQueryARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBeginQueryARB((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteQueriesARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteQueriesARB((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(endQueryARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glEndQueryARB((GLenum)arg0);

}

      
NAN_METHOD(genQueriesARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenQueriesARB((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getQueryObjectivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetQueryObjectivARB((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getQueryObjectuivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetQueryObjectuivARB((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getQueryivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetQueryivARB((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isQueryARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsQueryARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(maxShaderCompilerThreadsARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glMaxShaderCompilerThreadsARB((GLuint)arg0);

}

      
NAN_METHOD(pointParameterfARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPointParameterfARB((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pointParameterfvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glPointParameterfvARB((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(polygonOffsetClamp) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glPolygonOffsetClamp((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(getProgramInterfaceiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetProgramInterfaceiv((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getProgramResourceIndex) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  GLuint retval = glGetProgramResourceIndex(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getProgramResourceLocation) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  GLint retval = glGetProgramResourceLocation(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getProgramResourceLocationIndex) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  GLint retval = glGetProgramResourceLocationIndex(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getProgramResourceName) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }
  GLchar* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLchar*>(*arg5_tarray);
  }


  glGetProgramResourceName((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(GLsizei*)arg4,(GLchar*)arg5);

}

      
NAN_METHOD(getProgramResourceiv) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLenum* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLenum*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  GLsizei* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLsizei*>(*arg6_tarray);
  }
  GLint* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLint*>(*arg7_tarray);
  }


  glGetProgramResourceiv((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLenum*)arg4,(GLsizei)arg5,(GLsizei*)arg6,(GLint*)arg7);

}

      
NAN_METHOD(provokingVertex) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glProvokingVertex((GLenum)arg0);

}

      
NAN_METHOD(getGraphicsResetStatusARB) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  GLenum retval = glGetGraphicsResetStatusARB();

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getnColorTableARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetnColorTableARB((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(void*)arg4);

}

      
NAN_METHOD(getnCompressedTexImageARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetnCompressedTexImageARB((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(void*)arg3);

}

      
NAN_METHOD(getnConvolutionFilterARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetnConvolutionFilterARB((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(void*)arg4);

}

      
NAN_METHOD(getnHistogramARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glGetnHistogramARB((GLenum)arg0,(GLboolean)arg1,(GLenum)arg2,(GLenum)arg3,(GLsizei)arg4,(void*)arg5);

}

      
NAN_METHOD(getnMapdvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glGetnMapdvARB((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLdouble*)arg3);

}

      
NAN_METHOD(getnMapfvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetnMapfvARB((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getnMapivARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetnMapivARB((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getnMinmaxARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glGetnMinmaxARB((GLenum)arg0,(GLboolean)arg1,(GLenum)arg2,(GLenum)arg3,(GLsizei)arg4,(void*)arg5);

}

      
NAN_METHOD(getnPixelMapfvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetnPixelMapfvARB((GLenum)arg0,(GLsizei)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getnPixelMapuivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetnPixelMapuivARB((GLenum)arg0,(GLsizei)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getnPixelMapusvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLushort* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLushort*>(*arg2_tarray);
  }


  glGetnPixelMapusvARB((GLenum)arg0,(GLsizei)arg1,(GLushort*)arg2);

}

      
NAN_METHOD(getnPolygonStippleARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glGetnPolygonStippleARB((GLsizei)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(getnSeparableFilterARB) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glGetnSeparableFilterARB((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(void*)arg4,(GLsizei)arg5,(void*)arg6,(void*)arg7);

}

      
NAN_METHOD(getnTexImageARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glGetnTexImageARB((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLenum)arg3,(GLsizei)arg4,(void*)arg5);

}

      
NAN_METHOD(getnUniformdvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glGetnUniformdvARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLdouble*)arg3);

}

      
NAN_METHOD(getnUniformfvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetnUniformfvARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getnUniformivARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetnUniformivARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getnUniformuivARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glGetnUniformuivARB((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLuint*)arg3);

}

      
NAN_METHOD(readnPixelsARB) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glReadnPixelsARB((GLint)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(GLsizei)arg6,(void*)arg7);

}

      
NAN_METHOD(framebufferSampleLocationsfvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glFramebufferSampleLocationsfvARB((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(namedFramebufferSampleLocationsfvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glNamedFramebufferSampleLocationsfvARB((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(minSampleShadingARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();


  glMinSampleShadingARB((GLclampf)arg0);

}

      
NAN_METHOD(bindSampler) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindSampler((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteSamplers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteSamplers((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(genSamplers) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenSamplers((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getSamplerParameterIiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetSamplerParameterIiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getSamplerParameterIuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetSamplerParameterIuiv((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getSamplerParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetSamplerParameterfv((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getSamplerParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetSamplerParameteriv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isSampler) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsSampler(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(samplerParameterIiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glSamplerParameterIiv((GLuint)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(samplerParameterIuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glSamplerParameterIuiv((GLuint)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(samplerParameterf) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glSamplerParameterf((GLuint)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(samplerParameterfv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glSamplerParameterfv((GLuint)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(samplerParameteri) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glSamplerParameteri((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(samplerParameteriv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glSamplerParameteriv((GLuint)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(activeShaderProgram) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glActiveShaderProgram((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bindProgramPipeline) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBindProgramPipeline((GLuint)arg0);

}

      
NAN_METHOD(createShaderProgramv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  GLchar** arg2 = static_cast<GLchar**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<GLchar*>(*item); 
  }


  GLuint retval = glCreateShaderProgramv(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(deleteProgramPipelines) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteProgramPipelines((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(genProgramPipelines) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenProgramPipelines((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getProgramPipelineInfoLog) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetProgramPipelineInfoLog((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(getProgramPipelineiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetProgramPipelineiv((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isProgramPipeline) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsProgramPipeline(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(programUniform1d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glProgramUniform1d((GLuint)arg0,(GLint)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(programUniform1dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glProgramUniform1dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(programUniform1f) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glProgramUniform1f((GLuint)arg0,(GLint)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(programUniform1fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform1fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform1i) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glProgramUniform1i((GLuint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(programUniform1iv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform1iv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform1ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniform1ui((GLuint)arg0,(GLint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(programUniform1uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform1uiv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniform2d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glProgramUniform2d((GLuint)arg0,(GLint)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(programUniform2dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glProgramUniform2dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(programUniform2f) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glProgramUniform2f((GLuint)arg0,(GLint)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(programUniform2fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform2fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform2i) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glProgramUniform2i((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(programUniform2iv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform2iv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform2ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glProgramUniform2ui((GLuint)arg0,(GLint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(programUniform2uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform2uiv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniform3d) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glProgramUniform3d((GLuint)arg0,(GLint)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(programUniform3dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glProgramUniform3dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(programUniform3f) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glProgramUniform3f((GLuint)arg0,(GLint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(programUniform3fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform3fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform3i) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glProgramUniform3i((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(programUniform3iv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform3iv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform3ui) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glProgramUniform3ui((GLuint)arg0,(GLint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(programUniform3uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform3uiv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniform4d) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();


  glProgramUniform4d((GLuint)arg0,(GLint)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5);

}

      
NAN_METHOD(programUniform4dv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glProgramUniform4dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(programUniform4f) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glProgramUniform4f((GLuint)arg0,(GLint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(programUniform4fv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform4fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform4i) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glProgramUniform4i((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5);

}

      
NAN_METHOD(programUniform4iv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform4iv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform4ui) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glProgramUniform4ui((GLuint)arg0,(GLint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5);

}

      
NAN_METHOD(programUniform4uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform4uiv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniformMatrix2dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix2dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix2fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix2fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix2x3dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix2x3dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix2x3fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix2x3fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix2x4dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix2x4dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix2x4fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix2x4fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix3dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix3dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix3fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix3fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix3x2dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix3x2dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix3x2fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix3x2fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix3x4dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix3x4dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix3x4fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix3x4fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix4dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix4dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix4fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix4fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix4x2dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix4x2dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix4x2fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix4x2fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix4x3dv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLdouble* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLdouble*>(*arg4_tarray);
  }


  glProgramUniformMatrix4x3dv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLdouble*)arg4);

}

      
NAN_METHOD(programUniformMatrix4x3fv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix4x3fv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(useProgramStages) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glUseProgramStages((GLuint)arg0,(GLbitfield)arg1,(GLuint)arg2);

}

      
NAN_METHOD(validateProgramPipeline) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glValidateProgramPipeline((GLuint)arg0);

}

      
NAN_METHOD(getActiveAtomicCounterBufferiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetActiveAtomicCounterBufferiv((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(bindImageTexture) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();


  glBindImageTexture((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLboolean)arg3,(GLint)arg4,(GLenum)arg5,(GLenum)arg6);

}

      
NAN_METHOD(memoryBarrier) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glMemoryBarrier((GLbitfield)arg0);

}

      
NAN_METHOD(attachObjectARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glAttachObjectARB((GLhandleARB)arg0,(GLhandleARB)arg1);

}

      
NAN_METHOD(compileShaderARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glCompileShaderARB((GLhandleARB)arg0);

}

      
NAN_METHOD(createProgramObjectARB) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  GLhandleARB retval = glCreateProgramObjectARB();

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(createShaderObjectARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLhandleARB retval = glCreateShaderObjectARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(deleteObjectARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDeleteObjectARB((GLhandleARB)arg0);

}

      
NAN_METHOD(detachObjectARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDetachObjectARB((GLhandleARB)arg0,(GLhandleARB)arg1);

}

      
NAN_METHOD(getActiveUniformARB) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLcharARB* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLcharARB*>(*arg6_tarray);
  }


  glGetActiveUniformARB((GLhandleARB)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLint*)arg4,(GLenum*)arg5,(GLcharARB*)arg6);

}

      
NAN_METHOD(getAttachedObjectsARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLhandleARB* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLhandleARB*>(*arg3_tarray);
  }


  glGetAttachedObjectsARB((GLhandleARB)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLhandleARB*)arg3);

}

      
NAN_METHOD(getHandleARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLhandleARB retval = glGetHandleARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getInfoLogARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLcharARB* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLcharARB*>(*arg3_tarray);
  }


  glGetInfoLogARB((GLhandleARB)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLcharARB*)arg3);

}

      
NAN_METHOD(getObjectParameterfvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetObjectParameterfvARB((GLhandleARB)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getObjectParameterivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetObjectParameterivARB((GLhandleARB)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getShaderSourceARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLcharARB* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLcharARB*>(*arg3_tarray);
  }


  glGetShaderSourceARB((GLhandleARB)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLcharARB*)arg3);

}

      
NAN_METHOD(getUniformLocationARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLcharARB* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLcharARB*>(*arg1_tarray);
  }


  GLint retval = glGetUniformLocationARB(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getUniformfvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetUniformfvARB((GLhandleARB)arg0,(GLint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getUniformivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetUniformivARB((GLhandleARB)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(linkProgramARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glLinkProgramARB((GLhandleARB)arg0);

}

      
NAN_METHOD(shaderSourceARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  GLcharARB** arg2 = static_cast<GLcharARB**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<GLcharARB*>(*item); 
  }
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glShaderSourceARB((GLhandleARB)arg0,(GLsizei)arg1,(const GLcharARB**)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(uniform1fARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glUniform1fARB((GLint)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(uniform1fvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform1fvARB((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform1iARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glUniform1iARB((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(uniform1ivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform1ivARB((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniform2fARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glUniform2fARB((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(uniform2fvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform2fvARB((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform2iARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glUniform2iARB((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(uniform2ivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform2ivARB((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniform3fARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glUniform3fARB((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(uniform3fvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform3fvARB((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform3iARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glUniform3iARB((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(uniform3ivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform3ivARB((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniform4fARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glUniform4fARB((GLint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(uniform4fvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glUniform4fvARB((GLint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(uniform4iARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glUniform4iARB((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(uniform4ivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glUniform4ivARB((GLint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(uniformMatrix2fvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix2fvARB((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix3fvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix3fvARB((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix4fvARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix4fvARB((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(useProgramObjectARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glUseProgramObjectARB((GLhandleARB)arg0);

}

      
NAN_METHOD(validateProgramARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glValidateProgramARB((GLhandleARB)arg0);

}

      
NAN_METHOD(shaderStorageBlockBinding) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glShaderStorageBlockBinding((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(getActiveSubroutineName) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }
  GLchar* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLchar*>(*arg5_tarray);
  }


  glGetActiveSubroutineName((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(GLsizei*)arg4,(GLchar*)arg5);

}

      
NAN_METHOD(getActiveSubroutineUniformName) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }
  GLchar* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLchar*>(*arg5_tarray);
  }


  glGetActiveSubroutineUniformName((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(GLsizei*)arg4,(GLchar*)arg5);

}

      
NAN_METHOD(getActiveSubroutineUniformiv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glGetActiveSubroutineUniformiv((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLenum)arg3,(GLint*)arg4);

}

      
NAN_METHOD(getProgramStageiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetProgramStageiv((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getSubroutineIndex) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  GLuint retval = glGetSubroutineIndex(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getSubroutineUniformLocation) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  GLint retval = glGetSubroutineUniformLocation(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getUniformSubroutineuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetUniformSubroutineuiv((GLenum)arg0,(GLint)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(uniformSubroutinesuiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniformSubroutinesuiv((GLenum)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(compileShaderIncludeARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  GLchar** arg2 = static_cast<GLchar**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<GLchar*>(*item); 
  }
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glCompileShaderIncludeARB((GLuint)arg0,(GLsizei)arg1,(const GLchar* const*)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(deleteNamedStringARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  glDeleteNamedStringARB((GLint)arg0,(const GLchar*)arg1);

}

      
NAN_METHOD(getNamedStringARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glGetNamedStringARB((GLint)arg0,(const GLchar*)arg1,(GLsizei)arg2,(GLint*)arg3,(GLchar*)arg4);

}

      
NAN_METHOD(getNamedStringivARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetNamedStringivARB((GLint)arg0,(const GLchar*)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(isNamedStringARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLboolean retval = glIsNamedStringARB(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(namedStringARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glNamedStringARB((GLenum)arg0,(GLint)arg1,(const GLchar*)arg2,(GLint)arg3,(const GLchar*)arg4);

}

      
NAN_METHOD(bufferPageCommitmentARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glBufferPageCommitmentARB((GLenum)arg0,(GLintptr)arg1,(GLsizeiptr)arg2,(GLboolean)arg3);

}

      
NAN_METHOD(texPageCommitmentARB) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glboolean");
    return;
  }
  
  GLboolean arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glTexPageCommitmentARB((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLboolean)arg8);

}

      
NAN_METHOD(getInteger64v) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint64* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint64*>(*arg1_tarray);
  }


  glGetInteger64v((GLenum)arg0,(GLint64*)arg1);

}

      
NAN_METHOD(patchParameterfv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glPatchParameterfv((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(patchParameteri) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPatchParameteri((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(textureBarrier) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glTextureBarrier();

}

      
NAN_METHOD(texBufferARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTexBufferARB((GLenum)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(texBufferRange) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glTexBufferRange((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(textureBufferRangeEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glintptr");
    return;
  }
  
  GLintptr arg4 = (GLintptr)info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg5 = (GLsizeiptr)info[5]->Uint32Value(ctx).ToChecked();


  glTextureBufferRangeEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLintptr)arg4,(GLsizeiptr)arg5);

}

      
NAN_METHOD(compressedTexImage1DARB) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glCompressedTexImage1DARB((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLint)arg4,(GLsizei)arg5,(const void*)arg6);

}

      
NAN_METHOD(compressedTexImage2DARB) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glCompressedTexImage2DARB((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLint)arg5,(GLsizei)arg6,(const void*)arg7);

}

      
NAN_METHOD(compressedTexImage3DARB) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glCompressedTexImage3DARB((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6,(GLsizei)arg7,(const void*)arg8);

}

      
NAN_METHOD(compressedTexSubImage1DARB) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glCompressedTexSubImage1DARB((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLenum)arg4,(GLsizei)arg5,(const void*)arg6);

}

      
NAN_METHOD(compressedTexSubImage2DARB) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glCompressedTexSubImage2DARB((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLenum)arg6,(GLsizei)arg7,(const void*)arg8);

}

      
NAN_METHOD(compressedTexSubImage3DARB) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glsizei");
    return;
  }
  
  GLsizei arg9 = info[9]->Uint32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glCompressedTexSubImage3DARB((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLsizei)arg9,(const void*)arg10);

}

      
NAN_METHOD(getCompressedTexImageARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glGetCompressedTexImageARB((GLenum)arg0,(GLint)arg1,(void*)arg2);

}

      
NAN_METHOD(getMultisamplefv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetMultisamplefv((GLenum)arg0,(GLuint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(sampleMaski) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();


  glSampleMaski((GLuint)arg0,(GLbitfield)arg1);

}

      
NAN_METHOD(texImage2DMultisample) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glTexImage2DMultisample((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLboolean)arg5);

}

      
NAN_METHOD(texImage3DMultisample) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glTexImage3DMultisample((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6);

}

      
NAN_METHOD(texStorage1D) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glTexStorage1D((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(texStorage2D) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glTexStorage2D((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(texStorage3D) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glTexStorage3D((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(texStorage2DMultisample) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glTexStorage2DMultisample((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLboolean)arg5);

}

      
NAN_METHOD(texStorage3DMultisample) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glTexStorage3DMultisample((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6);

}

      
NAN_METHOD(textureStorage2DMultisampleEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glTextureStorage2DMultisampleEXT((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6);

}

      
NAN_METHOD(textureStorage3DMultisampleEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glboolean");
    return;
  }
  
  GLboolean arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glTextureStorage3DMultisampleEXT((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLboolean)arg7);

}

      
NAN_METHOD(textureView) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glTextureView((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLenum)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6,(GLuint)arg7);

}

      
NAN_METHOD(getQueryObjecti64v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64*>(*arg2_tarray);
  }


  glGetQueryObjecti64v((GLuint)arg0,(GLenum)arg1,(GLint64*)arg2);

}

      
NAN_METHOD(getQueryObjectui64v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glGetQueryObjectui64v((GLuint)arg0,(GLenum)arg1,(GLuint64*)arg2);

}

      
NAN_METHOD(queryCounter) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glQueryCounter((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(bindTransformFeedback) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindTransformFeedback((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteTransformFeedbacks) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteTransformFeedbacks((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(drawTransformFeedback) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDrawTransformFeedback((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(genTransformFeedbacks) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenTransformFeedbacks((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(isTransformFeedback) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsTransformFeedback(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(pauseTransformFeedback) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPauseTransformFeedback();

}

      
NAN_METHOD(resumeTransformFeedback) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glResumeTransformFeedback();

}

      
NAN_METHOD(beginQueryIndexed) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glBeginQueryIndexed((GLenum)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(drawTransformFeedbackStream) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glDrawTransformFeedbackStream((GLenum)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(endQueryIndexed) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glEndQueryIndexed((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(getQueryIndexediv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetQueryIndexediv((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(drawTransformFeedbackInstanced) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glDrawTransformFeedbackInstanced((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(drawTransformFeedbackStreamInstanced) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawTransformFeedbackStreamInstanced((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(bindBufferBase) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glBindBufferBase((GLenum)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(bindBufferRange) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glBindBufferRange((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(getActiveUniformBlockName) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glGetActiveUniformBlockName((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLchar*)arg4);

}

      
NAN_METHOD(getActiveUniformBlockiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetActiveUniformBlockiv((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getActiveUniformName) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glGetActiveUniformName((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLchar*)arg4);

}

      
NAN_METHOD(getActiveUniformsiv) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glGetActiveUniformsiv((GLuint)arg0,(GLsizei)arg1,(const GLuint*)arg2,(GLenum)arg3,(GLint*)arg4);

}

      
NAN_METHOD(getIntegeri_v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetIntegeri_v((GLenum)arg0,(GLuint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getUniformBlockIndex) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLuint retval = glGetUniformBlockIndex(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getUniformIndices) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  GLchar** arg2 = static_cast<GLchar**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<GLchar*>(*item); 
  }
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glGetUniformIndices((GLuint)arg0,(GLsizei)arg1,(const GLchar* const*)arg2,(GLuint*)arg3);

}

      
NAN_METHOD(uniformBlockBinding) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glUniformBlockBinding((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(bindVertexArray) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBindVertexArray((GLuint)arg0);

}

      
NAN_METHOD(deleteVertexArrays) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteVertexArrays((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(genVertexArrays) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenVertexArrays((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(isVertexArray) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsVertexArray(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getVertexAttribLdv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetVertexAttribLdv((GLuint)arg0,(GLenum)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(vertexAttribL1d) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttribL1d((GLuint)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(vertexAttribL1dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL1dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribL2d) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttribL2d((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(vertexAttribL2dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL2dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribL3d) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttribL3d((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(vertexAttribL3dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL3dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribL4d) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttribL4d((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(vertexAttribL4dv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL4dv((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribLPointer) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glVertexAttribLPointer((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(bindVertexBuffer) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glBindVertexBuffer((GLuint)arg0,(GLuint)arg1,(GLintptr)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(vertexArrayBindVertexBufferEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayBindVertexBufferEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(vertexArrayVertexAttribBindingEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribBindingEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(vertexArrayVertexAttribFormatEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glboolean");
    return;
  }
  
  GLboolean arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribFormatEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLboolean)arg4,(GLuint)arg5);

}

      
NAN_METHOD(vertexArrayVertexAttribIFormatEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribIFormatEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLuint)arg4);

}

      
NAN_METHOD(vertexArrayVertexAttribLFormatEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribLFormatEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLuint)arg4);

}

      
NAN_METHOD(vertexArrayVertexBindingDivisorEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexBindingDivisorEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(vertexAttribBinding) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribBinding((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexAttribFormat) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttribFormat((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLboolean)arg3,(GLuint)arg4);

}

      
NAN_METHOD(vertexAttribIFormat) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribIFormat((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexAttribLFormat) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribLFormat((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexBindingDivisor) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexBindingDivisor((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexBlendARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glVertexBlendARB((GLint)arg0);

}

      
NAN_METHOD(weightPointerARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glWeightPointerARB((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(void*)arg3);

}

      
NAN_METHOD(weightbvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glWeightbvARB((GLint)arg0,(GLbyte*)arg1);

}

      
NAN_METHOD(weightdvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glWeightdvARB((GLint)arg0,(GLdouble*)arg1);

}

      
NAN_METHOD(weightfvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glWeightfvARB((GLint)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(weightivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glWeightivARB((GLint)arg0,(GLint*)arg1);

}

      
NAN_METHOD(weightsvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glWeightsvARB((GLint)arg0,(GLshort*)arg1);

}

      
NAN_METHOD(weightubvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glWeightubvARB((GLint)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(weightuivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glWeightuivARB((GLint)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(weightusvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glWeightusvARB((GLint)arg0,(GLushort*)arg1);

}

      
NAN_METHOD(bindBufferARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindBufferARB((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bufferDataARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptrarb");
    return;
  }
  
  GLsizeiptrARB arg1 = (GLsizeiptrARB)info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glBufferDataARB((GLenum)arg0,(GLsizeiptrARB)arg1,(const void*)arg2,(GLenum)arg3);

}

      
NAN_METHOD(bufferSubDataARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptrarb");
    return;
  }
  
  GLintptrARB arg1 = (GLintptrARB)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptrarb");
    return;
  }
  
  GLsizeiptrARB arg2 = (GLsizeiptrARB)info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glBufferSubDataARB((GLenum)arg0,(GLintptrARB)arg1,(GLsizeiptrARB)arg2,(const void*)arg3);

}

      
NAN_METHOD(deleteBuffersARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteBuffersARB((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(genBuffersARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenBuffersARB((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getBufferParameterivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetBufferParameterivARB((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getBufferPointervARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetBufferPointervARB((GLenum)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(getBufferSubDataARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptrarb");
    return;
  }
  
  GLintptrARB arg1 = (GLintptrARB)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptrarb");
    return;
  }
  
  GLsizeiptrARB arg2 = (GLsizeiptrARB)info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetBufferSubDataARB((GLenum)arg0,(GLintptrARB)arg1,(GLsizeiptrARB)arg2,(void*)arg3);

}

      
NAN_METHOD(isBufferARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsBufferARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(unmapBufferARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLboolean retval = glUnmapBufferARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindProgramARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindProgramARB((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteProgramsARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteProgramsARB((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(disableVertexAttribArrayARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDisableVertexAttribArrayARB((GLuint)arg0);

}

      
NAN_METHOD(enableVertexAttribArrayARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEnableVertexAttribArrayARB((GLuint)arg0);

}

      
NAN_METHOD(genProgramsARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenProgramsARB((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getProgramEnvParameterdvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetProgramEnvParameterdvARB((GLenum)arg0,(GLuint)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getProgramEnvParameterfvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetProgramEnvParameterfvARB((GLenum)arg0,(GLuint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getProgramLocalParameterdvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetProgramLocalParameterdvARB((GLenum)arg0,(GLuint)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getProgramLocalParameterfvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetProgramLocalParameterfvARB((GLenum)arg0,(GLuint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getProgramStringARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glGetProgramStringARB((GLenum)arg0,(GLenum)arg1,(void*)arg2);

}

      
NAN_METHOD(getProgramivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetProgramivARB((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVertexAttribPointervARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetVertexAttribPointervARB((GLuint)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(getVertexAttribdvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetVertexAttribdvARB((GLuint)arg0,(GLenum)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getVertexAttribfvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetVertexAttribfvARB((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getVertexAttribivARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVertexAttribivARB((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isProgramARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsProgramARB(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(programEnvParameter4dARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();


  glProgramEnvParameter4dARB((GLenum)arg0,(GLuint)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5);

}

      
NAN_METHOD(programEnvParameter4dvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glProgramEnvParameter4dvARB((GLenum)arg0,(GLuint)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(programEnvParameter4fARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glProgramEnvParameter4fARB((GLenum)arg0,(GLuint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(programEnvParameter4fvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glProgramEnvParameter4fvARB((GLenum)arg0,(GLuint)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(programLocalParameter4dARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();


  glProgramLocalParameter4dARB((GLenum)arg0,(GLuint)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5);

}

      
NAN_METHOD(programLocalParameter4dvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glProgramLocalParameter4dvARB((GLenum)arg0,(GLuint)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(programLocalParameter4fARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glProgramLocalParameter4fARB((GLenum)arg0,(GLuint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(programLocalParameter4fvARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glProgramLocalParameter4fvARB((GLenum)arg0,(GLuint)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(programStringARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glProgramStringARB((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(vertexAttrib1dARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttrib1dARB((GLuint)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(vertexAttrib1dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib1dvARB((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib1fARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttrib1fARB((GLuint)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(vertexAttrib1fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib1fvARB((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib1sARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexAttrib1sARB((GLuint)arg0,(GLshort)arg1);

}

      
NAN_METHOD(vertexAttrib1svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib1svARB((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib2dARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttrib2dARB((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(vertexAttrib2dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib2dvARB((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib2fARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttrib2fARB((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(vertexAttrib2fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib2fvARB((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib2sARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexAttrib2sARB((GLuint)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(vertexAttrib2svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib2svARB((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib3dARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttrib3dARB((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(vertexAttrib3dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib3dvARB((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib3fARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttrib3fARB((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(vertexAttrib3fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib3fvARB((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib3sARB) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertexAttrib3sARB((GLuint)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(vertexAttrib3svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib3svARB((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4NbvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glVertexAttrib4NbvARB((GLuint)arg0,(const GLbyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4NivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttrib4NivARB((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttrib4NsvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib4NsvARB((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4NubARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glubyte");
    return;
  }
  
  GLubyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glubyte");
    return;
  }
  
  GLubyte arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glubyte");
    return;
  }
  
  GLubyte arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glubyte");
    return;
  }
  
  GLubyte arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttrib4NubARB((GLuint)arg0,(GLubyte)arg1,(GLubyte)arg2,(GLubyte)arg3,(GLubyte)arg4);

}

      
NAN_METHOD(vertexAttrib4NubvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVertexAttrib4NubvARB((GLuint)arg0,(const GLubyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4NuivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttrib4NuivARB((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttrib4NusvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glVertexAttrib4NusvARB((GLuint)arg0,(const GLushort*)arg1);

}

      
NAN_METHOD(vertexAttrib4bvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glVertexAttrib4bvARB((GLuint)arg0,(const GLbyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4dARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttrib4dARB((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(vertexAttrib4dvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib4dvARB((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib4fARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttrib4fARB((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(vertexAttrib4fvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib4fvARB((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib4ivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttrib4ivARB((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttrib4sARB) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glshort");
    return;
  }
  
  GLshort arg4 = info[4]->Int32Value(ctx).ToChecked();


  glVertexAttrib4sARB((GLuint)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3,(GLshort)arg4);

}

      
NAN_METHOD(vertexAttrib4svARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib4svARB((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4ubvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVertexAttrib4ubvARB((GLuint)arg0,(const GLubyte*)arg1);

}

      
NAN_METHOD(vertexAttrib4uivARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttrib4uivARB((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttrib4usvARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glVertexAttrib4usvARB((GLuint)arg0,(const GLushort*)arg1);

}

      
NAN_METHOD(vertexAttribPointerARB) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glVertexAttribPointerARB((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLboolean)arg3,(GLsizei)arg4,(const void*)arg5);

}

      
NAN_METHOD(bindAttribLocationARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLcharARB* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLcharARB*>(*arg2_tarray);
  }


  glBindAttribLocationARB((GLhandleARB)arg0,(GLuint)arg1,(const GLcharARB*)arg2);

}

      
NAN_METHOD(getActiveAttribARB) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLcharARB* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLcharARB*>(*arg6_tarray);
  }


  glGetActiveAttribARB((GLhandleARB)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLint*)arg4,(GLenum*)arg5,(GLcharARB*)arg6);

}

      
NAN_METHOD(getAttribLocationARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glhandlearb");
    return;
  }
  
  GLhandleARB arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLcharARB* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLcharARB*>(*arg1_tarray);
  }


  GLint retval = glGetAttribLocationARB(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(colorP3ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glColorP3ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(colorP3uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glColorP3uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(colorP4ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glColorP4ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(colorP4uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glColorP4uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(multiTexCoordP1ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glMultiTexCoordP1ui((GLenum)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(multiTexCoordP1uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glMultiTexCoordP1uiv((GLenum)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(multiTexCoordP2ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glMultiTexCoordP2ui((GLenum)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(multiTexCoordP2uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glMultiTexCoordP2uiv((GLenum)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(multiTexCoordP3ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glMultiTexCoordP3ui((GLenum)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(multiTexCoordP3uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glMultiTexCoordP3uiv((GLenum)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(multiTexCoordP4ui) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glMultiTexCoordP4ui((GLenum)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(multiTexCoordP4uiv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glMultiTexCoordP4uiv((GLenum)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(normalP3ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glNormalP3ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(normalP3uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glNormalP3uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(secondaryColorP3ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glSecondaryColorP3ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(secondaryColorP3uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glSecondaryColorP3uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(texCoordP1ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glTexCoordP1ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(texCoordP1uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glTexCoordP1uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(texCoordP2ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glTexCoordP2ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(texCoordP2uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glTexCoordP2uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(texCoordP3ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glTexCoordP3ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(texCoordP3uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glTexCoordP3uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(texCoordP4ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glTexCoordP4ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(texCoordP4uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glTexCoordP4uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribP1ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribP1ui((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexAttribP1uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glVertexAttribP1uiv((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(vertexAttribP2ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribP2ui((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexAttribP2uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glVertexAttribP2uiv((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(vertexAttribP3ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribP3ui((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexAttribP3uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glVertexAttribP3uiv((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(vertexAttribP4ui) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribP4ui((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexAttribP4uiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glVertexAttribP4uiv((GLuint)arg0,(GLenum)arg1,(GLboolean)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(vertexP2ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexP2ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexP2uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexP2uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexP3ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexP3ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexP3uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexP3uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexP4ui) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexP4ui((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexP4uiv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexP4uiv((GLenum)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(depthRangeArrayv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLclampd* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLclampd*>(*arg2_tarray);
  }


  glDepthRangeArrayv((GLuint)arg0,(GLsizei)arg1,(const GLclampd*)arg2);

}

      
NAN_METHOD(depthRangeIndexed) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampd");
    return;
  }
  
  GLclampd arg1 = (GLclampd)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glclampd");
    return;
  }
  
  GLclampd arg2 = (GLclampd)info[2]->NumberValue(ctx).ToChecked();


  glDepthRangeIndexed((GLuint)arg0,(GLclampd)arg1,(GLclampd)arg2);

}

      
NAN_METHOD(getDoublei_v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetDoublei_v((GLenum)arg0,(GLuint)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getFloati_v) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetFloati_v((GLenum)arg0,(GLuint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(scissorArrayv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glScissorArrayv((GLuint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(scissorIndexed) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glScissorIndexed((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(scissorIndexedv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glScissorIndexedv((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(viewportArrayv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glViewportArrayv((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(viewportIndexedf) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glViewportIndexedf((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(viewportIndexedfv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glViewportIndexedfv((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(windowPos2dARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glWindowPos2dARB((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(windowPos2dvARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glWindowPos2dvARB((const GLdouble*)arg0);

}

      
NAN_METHOD(windowPos2fARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glWindowPos2fARB((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(windowPos2fvARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glWindowPos2fvARB((const GLfloat*)arg0);

}

      
NAN_METHOD(windowPos2iARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glWindowPos2iARB((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(windowPos2ivARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glWindowPos2ivARB((const GLint*)arg0);

}

      
NAN_METHOD(windowPos2sARB) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glWindowPos2sARB((GLshort)arg0,(GLshort)arg1);

}

      
NAN_METHOD(windowPos2svARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glWindowPos2svARB((const GLshort*)arg0);

}

      
NAN_METHOD(windowPos3dARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glWindowPos3dARB((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(windowPos3dvARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glWindowPos3dvARB((const GLdouble*)arg0);

}

      
NAN_METHOD(windowPos3fARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glWindowPos3fARB((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(windowPos3fvARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glWindowPos3fvARB((const GLfloat*)arg0);

}

      
NAN_METHOD(windowPos3iARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glWindowPos3iARB((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(windowPos3ivARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glWindowPos3ivARB((const GLint*)arg0);

}

      
NAN_METHOD(windowPos3sARB) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glWindowPos3sARB((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(windowPos3svARB) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glWindowPos3svARB((const GLshort*)arg0);

}

      
NAN_METHOD(drawBuffersATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLenum* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLenum*>(*arg1_tarray);
  }


  glDrawBuffersATI((GLsizei)arg0,(const GLenum*)arg1);

}

      
NAN_METHOD(drawElementArrayATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDrawElementArrayATI((GLenum)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(drawRangeElementArrayATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawRangeElementArrayATI((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(elementPointerATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glElementPointerATI((GLenum)arg0,(const void*)arg1);

}

      
NAN_METHOD(getTexBumpParameterfvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glGetTexBumpParameterfvATI((GLenum)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(getTexBumpParameterivATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glGetTexBumpParameterivATI((GLenum)arg0,(GLint*)arg1);

}

      
NAN_METHOD(texBumpParameterfvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glTexBumpParameterfvATI((GLenum)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(texBumpParameterivATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glTexBumpParameterivATI((GLenum)arg0,(GLint*)arg1);

}

      
NAN_METHOD(alphaFragmentOp1ATI) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glAlphaFragmentOp1ATI((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5);

}

      
NAN_METHOD(alphaFragmentOp2ATI) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glAlphaFragmentOp2ATI((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6,(GLuint)arg7,(GLuint)arg8);

}

      
NAN_METHOD(alphaFragmentOp3ATI) {
  if (info.Length() != 12) {
    Nan::ThrowError("Expected 12 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a gluint");
    return;
  }
  
  GLuint arg9 = info[9]->Uint32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a gluint");
    return;
  }
  
  GLuint arg10 = info[10]->Uint32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a gluint");
    return;
  }
  
  GLuint arg11 = info[11]->Uint32Value(ctx).ToChecked();


  glAlphaFragmentOp3ATI((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6,(GLuint)arg7,(GLuint)arg8,(GLuint)arg9,(GLuint)arg10,(GLuint)arg11);

}

      
NAN_METHOD(beginFragmentShaderATI) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glBeginFragmentShaderATI();

}

      
NAN_METHOD(bindFragmentShaderATI) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBindFragmentShaderATI((GLuint)arg0);

}

      
NAN_METHOD(colorFragmentOp1ATI) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glColorFragmentOp1ATI((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6);

}

      
NAN_METHOD(colorFragmentOp2ATI) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a gluint");
    return;
  }
  
  GLuint arg9 = info[9]->Uint32Value(ctx).ToChecked();


  glColorFragmentOp2ATI((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6,(GLuint)arg7,(GLuint)arg8,(GLuint)arg9);

}

      
NAN_METHOD(colorFragmentOp3ATI) {
  if (info.Length() != 13) {
    Nan::ThrowError("Expected 13 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a gluint");
    return;
  }
  
  GLuint arg9 = info[9]->Uint32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a gluint");
    return;
  }
  
  GLuint arg10 = info[10]->Uint32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a gluint");
    return;
  }
  
  GLuint arg11 = info[11]->Uint32Value(ctx).ToChecked();
  if (!info[12]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 13, expected a gluint");
    return;
  }
  
  GLuint arg12 = info[12]->Uint32Value(ctx).ToChecked();


  glColorFragmentOp3ATI((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6,(GLuint)arg7,(GLuint)arg8,(GLuint)arg9,(GLuint)arg10,(GLuint)arg11,(GLuint)arg12);

}

      
NAN_METHOD(deleteFragmentShaderATI) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDeleteFragmentShaderATI((GLuint)arg0);

}

      
NAN_METHOD(endFragmentShaderATI) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndFragmentShaderATI();

}

      
NAN_METHOD(genFragmentShadersATI) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLuint retval = glGenFragmentShadersATI(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(passTexCoordATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glPassTexCoordATI((GLuint)arg0,(GLuint)arg1,(GLenum)arg2);

}

      
NAN_METHOD(sampleMapATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glSampleMapATI((GLuint)arg0,(GLuint)arg1,(GLenum)arg2);

}

      
NAN_METHOD(setFragmentShaderConstantATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glSetFragmentShaderConstantATI((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(unmapObjectBufferATI) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glUnmapObjectBufferATI((GLuint)arg0);

}

      
NAN_METHOD(pNTrianglesfATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPNTrianglesfATI((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pNTrianglesiATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPNTrianglesiATI((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(stencilFuncSeparateATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glStencilFuncSeparateATI((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(stencilOpSeparateATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glStencilOpSeparateATI((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3);

}

      
NAN_METHOD(arrayObjectATI) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glArrayObjectATI((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLuint)arg4,(GLuint)arg5);

}

      
NAN_METHOD(freeObjectBufferATI) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glFreeObjectBufferATI((GLuint)arg0);

}

      
NAN_METHOD(getArrayObjectfvATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetArrayObjectfvATI((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getArrayObjectivATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetArrayObjectivATI((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getObjectBufferfvATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetObjectBufferfvATI((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getObjectBufferivATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetObjectBufferivATI((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVariantArrayObjectfvATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetVariantArrayObjectfvATI((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getVariantArrayObjectivATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVariantArrayObjectivATI((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isObjectBufferATI) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsObjectBufferATI(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(newObjectBufferATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  GLuint retval = glNewObjectBufferATI(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(updateObjectBufferATI) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glUpdateObjectBufferATI((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(const void*)arg3,(GLenum)arg4);

}

      
NAN_METHOD(variantArrayObjectATI) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVariantArrayObjectATI((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(getVertexAttribArrayObjectfvATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetVertexAttribArrayObjectfvATI((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getVertexAttribArrayObjectivATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVertexAttribArrayObjectivATI((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(vertexAttribArrayObjectATI) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glVertexAttribArrayObjectATI((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLboolean)arg3,(GLsizei)arg4,(GLuint)arg5,(GLuint)arg6);

}

      
NAN_METHOD(clientActiveVertexStreamATI) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glClientActiveVertexStreamATI((GLenum)arg0);

}

      
NAN_METHOD(normalStream3bATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbyte");
    return;
  }
  
  GLbyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glbyte");
    return;
  }
  
  GLbyte arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbyte");
    return;
  }
  
  GLbyte arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glNormalStream3bATI((GLenum)arg0,(GLbyte)arg1,(GLbyte)arg2,(GLbyte)arg3);

}

      
NAN_METHOD(normalStream3bvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glNormalStream3bvATI((GLenum)arg0,(const GLbyte*)arg1);

}

      
NAN_METHOD(normalStream3dATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glNormalStream3dATI((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(normalStream3dvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glNormalStream3dvATI((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(normalStream3fATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glNormalStream3fATI((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(normalStream3fvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glNormalStream3fvATI((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(normalStream3iATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glNormalStream3iATI((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(normalStream3ivATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glNormalStream3ivATI((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(normalStream3sATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glNormalStream3sATI((GLenum)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(normalStream3svATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glNormalStream3svATI((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexBlendEnvfATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glVertexBlendEnvfATI((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(vertexBlendEnviATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexBlendEnviATI((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(vertexStream1dATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glVertexStream1dATI((GLenum)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(vertexStream1dvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexStream1dvATI((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexStream1fATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glVertexStream1fATI((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(vertexStream1fvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexStream1fvATI((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexStream1iATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexStream1iATI((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(vertexStream1ivATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexStream1ivATI((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexStream1sATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexStream1sATI((GLenum)arg0,(GLshort)arg1);

}

      
NAN_METHOD(vertexStream1svATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexStream1svATI((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexStream2dATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glVertexStream2dATI((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(vertexStream2dvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexStream2dvATI((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexStream2fATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glVertexStream2fATI((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(vertexStream2fvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexStream2fvATI((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexStream2iATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexStream2iATI((GLenum)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(vertexStream2ivATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexStream2ivATI((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexStream2sATI) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexStream2sATI((GLenum)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(vertexStream2svATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexStream2svATI((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexStream3dATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glVertexStream3dATI((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(vertexStream3dvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexStream3dvATI((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexStream3fATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glVertexStream3fATI((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(vertexStream3fvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexStream3fvATI((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexStream3iATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertexStream3iATI((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(vertexStream3ivATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexStream3ivATI((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexStream3sATI) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertexStream3sATI((GLenum)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(vertexStream3svATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexStream3svATI((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexStream4dATI) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glVertexStream4dATI((GLenum)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(vertexStream4dvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexStream4dvATI((GLenum)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexStream4fATI) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glVertexStream4fATI((GLenum)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(vertexStream4fvATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexStream4fvATI((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexStream4iATI) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glVertexStream4iATI((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(vertexStream4ivATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexStream4ivATI((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexStream4sATI) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glshort");
    return;
  }
  
  GLshort arg4 = info[4]->Int32Value(ctx).ToChecked();


  glVertexStream4sATI((GLenum)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3,(GLshort)arg4);

}

      
NAN_METHOD(vertexStream4svATI) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexStream4svATI((GLenum)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(drawArraysInstancedBaseInstanceEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawArraysInstancedBaseInstanceEXT((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLuint)arg4);

}

      
NAN_METHOD(drawElementsInstancedBaseInstanceEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedBaseInstanceEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4,(GLuint)arg5);

}

      
NAN_METHOD(drawElementsInstancedBaseVertexBaseInstanceEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedBaseVertexBaseInstanceEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4,(GLint)arg5,(GLuint)arg6);

}

      
NAN_METHOD(getUniformBufferSizeEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLint retval = glGetUniformBufferSizeEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getUniformOffsetEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLintptr retval = glGetUniformOffsetEXT(arg0,arg1);

  info.GetReturnValue().Set((int32_t)retval);
      
}

      
NAN_METHOD(uniformBufferEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glUniformBufferEXT((GLuint)arg0,(GLint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(blendColorEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampf");
    return;
  }
  
  GLclampf arg1 = (GLclampf)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glclampf");
    return;
  }
  
  GLclampf arg2 = (GLclampf)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glclampf");
    return;
  }
  
  GLclampf arg3 = (GLclampf)info[3]->NumberValue(ctx).ToChecked();


  glBlendColorEXT((GLclampf)arg0,(GLclampf)arg1,(GLclampf)arg2,(GLclampf)arg3);

}

      
NAN_METHOD(blendEquationSeparateEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendEquationSeparateEXT((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(bindFragDataLocationIndexedEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glBindFragDataLocationIndexedEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(const GLchar*)arg3);

}

      
NAN_METHOD(getFragDataIndexEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLint retval = glGetFragDataIndexEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getProgramResourceLocationIndexEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  GLint retval = glGetProgramResourceLocationIndexEXT(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(blendFuncSeparateEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glBlendFuncSeparateEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3);

}

      
NAN_METHOD(blendEquationEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glBlendEquationEXT((GLenum)arg0);

}

      
NAN_METHOD(bufferStorageEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbitfield");
    return;
  }
  
  GLbitfield arg3 = info[3]->Int32Value(ctx).ToChecked();


  glBufferStorageEXT((GLenum)arg0,(GLsizeiptr)arg1,(const void*)arg2,(GLbitfield)arg3);

}

      
NAN_METHOD(namedBufferStorageEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbitfield");
    return;
  }
  
  GLbitfield arg3 = info[3]->Int32Value(ctx).ToChecked();


  glNamedBufferStorageEXT((GLuint)arg0,(GLsizeiptr)arg1,(const void*)arg2,(GLbitfield)arg3);

}

      
NAN_METHOD(clearTexImageEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glClearTexImageEXT((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLenum)arg3,(const void*)arg4);

}

      
NAN_METHOD(clearTexSubImageEXT) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glClearTexSubImageEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(const void*)arg10);

}

      
NAN_METHOD(colorSubTableEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glColorSubTableEXT((GLenum)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLenum)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(copyColorSubTableEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glCopyColorSubTableEXT((GLenum)arg0,(GLsizei)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(lockArraysEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glLockArraysEXT((GLint)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(unlockArraysEXT) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glUnlockArraysEXT();

}

      
NAN_METHOD(convolutionFilter1DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glConvolutionFilter1DEXT((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(convolutionFilter2DEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glConvolutionFilter2DEXT((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(convolutionParameterfEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glConvolutionParameterfEXT((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(convolutionParameterfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glConvolutionParameterfvEXT((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(convolutionParameteriEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glConvolutionParameteriEXT((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(convolutionParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glConvolutionParameterivEXT((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(copyConvolutionFilter1DEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glCopyConvolutionFilter1DEXT((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(copyConvolutionFilter2DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glCopyConvolutionFilter2DEXT((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(getConvolutionFilterEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetConvolutionFilterEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(void*)arg3);

}

      
NAN_METHOD(getConvolutionParameterfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetConvolutionParameterfvEXT((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getConvolutionParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetConvolutionParameterivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getSeparableFilterEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glGetSeparableFilterEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(void*)arg3,(void*)arg4,(void*)arg5);

}

      
NAN_METHOD(separableFilter2DEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glSeparableFilter2DEXT((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6,(const void*)arg7);

}

      
NAN_METHOD(binormalPointerEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glBinormalPointerEXT((GLenum)arg0,(GLsizei)arg1,(void*)arg2);

}

      
NAN_METHOD(tangentPointerEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glTangentPointerEXT((GLenum)arg0,(GLsizei)arg1,(void*)arg2);

}

      
NAN_METHOD(copyImageSubDataEXT) {
  if (info.Length() != 15) {
    Nan::ThrowError("Expected 15 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glint");
    return;
  }
  
  GLint arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glint");
    return;
  }
  
  GLint arg10 = info[10]->Int32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glint");
    return;
  }
  
  GLint arg11 = info[11]->Int32Value(ctx).ToChecked();
  if (!info[12]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 13, expected a glsizei");
    return;
  }
  
  GLsizei arg12 = info[12]->Uint32Value(ctx).ToChecked();
  if (!info[13]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 14, expected a glsizei");
    return;
  }
  
  GLsizei arg13 = info[13]->Uint32Value(ctx).ToChecked();
  if (!info[14]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 15, expected a glsizei");
    return;
  }
  
  GLsizei arg14 = info[14]->Uint32Value(ctx).ToChecked();


  glCopyImageSubDataEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLuint)arg6,(GLenum)arg7,(GLint)arg8,(GLint)arg9,(GLint)arg10,(GLint)arg11,(GLsizei)arg12,(GLsizei)arg13,(GLsizei)arg14);

}

      
NAN_METHOD(copyTexImage1DEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glCopyTexImage1DEXT((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLint)arg6);

}

      
NAN_METHOD(copyTexImage2DEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();


  glCopyTexImage2DEXT((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLint)arg7);

}

      
NAN_METHOD(copyTexSubImage1DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glCopyTexSubImage1DEXT((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(copyTexSubImage2DEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glCopyTexSubImage2DEXT((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLsizei)arg6,(GLsizei)arg7);

}

      
NAN_METHOD(copyTexSubImage3DEXT) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glsizei");
    return;
  }
  
  GLsizei arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glCopyTexSubImage3DEXT((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLsizei)arg7,(GLsizei)arg8);

}

      
NAN_METHOD(cullParameterdvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glCullParameterdvEXT((GLenum)arg0,(GLdouble*)arg1);

}

      
NAN_METHOD(cullParameterfvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glCullParameterfvEXT((GLenum)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(getObjectLabelEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glGetObjectLabelEXT((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLchar*)arg4);

}

      
NAN_METHOD(labelObjectEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glLabelObjectEXT((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLchar*)arg3);

}

      
NAN_METHOD(insertEventMarkerEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  glInsertEventMarkerEXT((GLsizei)arg0,(const GLchar*)arg1);

}

      
NAN_METHOD(popGroupMarkerEXT) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPopGroupMarkerEXT();

}

      
NAN_METHOD(pushGroupMarkerEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  glPushGroupMarkerEXT((GLsizei)arg0,(const GLchar*)arg1);

}

      
NAN_METHOD(depthBoundsEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampd");
    return;
  }
  
  GLclampd arg0 = (GLclampd)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampd");
    return;
  }
  
  GLclampd arg1 = (GLclampd)info[1]->NumberValue(ctx).ToChecked();


  glDepthBoundsEXT((GLclampd)arg0,(GLclampd)arg1);

}

      
NAN_METHOD(namedFramebufferTexture1DEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTexture1DEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4);

}

      
NAN_METHOD(namedFramebufferTexture2DEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTexture2DEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4);

}

      
NAN_METHOD(namedFramebufferTexture3DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTexture3DEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4,(GLint)arg5);

}

      
NAN_METHOD(namedFramebufferTextureEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTextureEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3);

}

      
NAN_METHOD(namedFramebufferTextureFaceEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTextureFaceEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLenum)arg4);

}

      
NAN_METHOD(namedFramebufferTextureLayerEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glNamedFramebufferTextureLayerEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(namedProgramLocalParameter4dEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gldouble");
    return;
  }
  
  GLdouble arg6 = (GLdouble)info[6]->NumberValue(ctx).ToChecked();


  glNamedProgramLocalParameter4dEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5,(GLdouble)arg6);

}

      
NAN_METHOD(namedProgramLocalParameter4dvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glNamedProgramLocalParameter4dvEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(namedProgramLocalParameter4fEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();


  glNamedProgramLocalParameter4fEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5,(GLfloat)arg6);

}

      
NAN_METHOD(namedProgramLocalParameter4fvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glNamedProgramLocalParameter4fvEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(namedProgramLocalParameterI4iEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glNamedProgramLocalParameterI4iEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6);

}

      
NAN_METHOD(namedProgramLocalParameterI4ivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glNamedProgramLocalParameterI4ivEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(namedProgramLocalParameterI4uiEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glNamedProgramLocalParameterI4uiEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6);

}

      
NAN_METHOD(namedProgramLocalParameterI4uivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glNamedProgramLocalParameterI4uivEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(namedProgramLocalParameters4fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glNamedProgramLocalParameters4fvEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(namedProgramLocalParametersI4ivEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glNamedProgramLocalParametersI4ivEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLint*)arg4);

}

      
NAN_METHOD(namedProgramLocalParametersI4uivEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glNamedProgramLocalParametersI4uivEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLuint*)arg4);

}

      
NAN_METHOD(namedProgramStringEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glNamedProgramStringEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(namedRenderbufferStorageEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glNamedRenderbufferStorageEXT((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(namedRenderbufferStorageMultisampleCoverageEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glNamedRenderbufferStorageMultisampleCoverageEXT((GLuint)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(namedRenderbufferStorageMultisampleEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glNamedRenderbufferStorageMultisampleEXT((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(programUniform1fEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glProgramUniform1fEXT((GLuint)arg0,(GLint)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(programUniform1fvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform1fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform1iEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glProgramUniform1iEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(programUniform1ivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform1ivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform1uiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniform1uiEXT((GLuint)arg0,(GLint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(programUniform1uivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform1uivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniform2fEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glProgramUniform2fEXT((GLuint)arg0,(GLint)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(programUniform2fvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform2fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform2iEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glProgramUniform2iEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(programUniform2ivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform2ivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform2uiEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glProgramUniform2uiEXT((GLuint)arg0,(GLint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(programUniform2uivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform2uivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniform3fEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glProgramUniform3fEXT((GLuint)arg0,(GLint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(programUniform3fvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform3fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform3iEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glProgramUniform3iEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(programUniform3ivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform3ivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform3uiEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glProgramUniform3uiEXT((GLuint)arg0,(GLint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(programUniform3uivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform3uivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniform4fEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glProgramUniform4fEXT((GLuint)arg0,(GLint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(programUniform4fvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramUniform4fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programUniform4iEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glProgramUniform4iEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5);

}

      
NAN_METHOD(programUniform4ivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramUniform4ivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programUniform4uiEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glProgramUniform4uiEXT((GLuint)arg0,(GLint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5);

}

      
NAN_METHOD(programUniform4uivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramUniform4uivEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programUniformMatrix2fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix2fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix2x3fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix2x3fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix2x4fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix2x4fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix3fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix3fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix3x2fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix3x2fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix3x4fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix3x4fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix4fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix4fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix4x2fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix4x2fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(programUniformMatrix4x3fvEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramUniformMatrix4x3fvEXT((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLboolean)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(pushClientAttribDefaultEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glPushClientAttribDefaultEXT((GLbitfield)arg0);

}

      
NAN_METHOD(textureBufferEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glTextureBufferEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3);

}

      
NAN_METHOD(textureImage1DEXT) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glTextureImage1DEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLint)arg5,(GLenum)arg6,(GLenum)arg7,(const void*)arg8);

}

      
NAN_METHOD(textureImage2DEXT) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  void* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<void*>(*arg9_tarray);
  }


  glTextureImage2DEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6,(GLenum)arg7,(GLenum)arg8,(const void*)arg9);

}

      
NAN_METHOD(textureImage3DEXT) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glTextureImage3DEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLint)arg7,(GLenum)arg8,(GLenum)arg9,(const void*)arg10);

}

      
NAN_METHOD(textureParameterIivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glTextureParameterIivEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(textureParameterIuivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glTextureParameterIuivEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(textureParameterfEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glTextureParameterfEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(textureParameterfvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glTextureParameterfvEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(textureParameteriEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glTextureParameteriEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLint)arg3);

}

      
NAN_METHOD(textureParameterivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glTextureParameterivEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(textureRenderbufferEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTextureRenderbufferEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(textureSubImage1DEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glTextureSubImage1DEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLenum)arg5,(GLenum)arg6,(const void*)arg7);

}

      
NAN_METHOD(textureSubImage2DEXT) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  void* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<void*>(*arg9_tarray);
  }


  glTextureSubImage2DEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLenum)arg7,(GLenum)arg8,(const void*)arg9);

}

      
NAN_METHOD(textureSubImage3DEXT) {
  if (info.Length() != 12) {
    Nan::ThrowError("Expected 12 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glsizei");
    return;
  }
  
  GLsizei arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glenum");
    return;
  }
  
  GLenum arg10 = info[10]->Int32Value(ctx).ToChecked();
  void* arg11;

  if (info[11]->IsNullOrUndefined()) {
    arg11 = nullptr;
  } else {
    if (!info[11]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 12, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg11_tarray(info[11]);
    arg11 = reinterpret_cast<void*>(*arg11_tarray);
  }


  glTextureSubImage3DEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLsizei)arg8,(GLenum)arg9,(GLenum)arg10,(const void*)arg11);

}

      
NAN_METHOD(unmapNamedBufferEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glUnmapNamedBufferEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(vertexArrayColorOffsetEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glintptr");
    return;
  }
  
  GLintptr arg5 = (GLintptr)info[5]->Uint32Value(ctx).ToChecked();


  glVertexArrayColorOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLsizei)arg4,(GLintptr)arg5);

}

      
NAN_METHOD(vertexArrayEdgeFlagOffsetEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();


  glVertexArrayEdgeFlagOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLintptr)arg3);

}

      
NAN_METHOD(vertexArrayFogCoordOffsetEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glintptr");
    return;
  }
  
  GLintptr arg4 = (GLintptr)info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayFogCoordOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLintptr)arg4);

}

      
NAN_METHOD(vertexArrayIndexOffsetEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glintptr");
    return;
  }
  
  GLintptr arg4 = (GLintptr)info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayIndexOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLintptr)arg4);

}

      
NAN_METHOD(vertexArrayMultiTexCoordOffsetEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glintptr");
    return;
  }
  
  GLintptr arg6 = (GLintptr)info[6]->Uint32Value(ctx).ToChecked();


  glVertexArrayMultiTexCoordOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint)arg3,(GLenum)arg4,(GLsizei)arg5,(GLintptr)arg6);

}

      
NAN_METHOD(vertexArrayNormalOffsetEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glintptr");
    return;
  }
  
  GLintptr arg4 = (GLintptr)info[4]->Uint32Value(ctx).ToChecked();


  glVertexArrayNormalOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLintptr)arg4);

}

      
NAN_METHOD(vertexArraySecondaryColorOffsetEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glintptr");
    return;
  }
  
  GLintptr arg5 = (GLintptr)info[5]->Uint32Value(ctx).ToChecked();


  glVertexArraySecondaryColorOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLsizei)arg4,(GLintptr)arg5);

}

      
NAN_METHOD(vertexArrayTexCoordOffsetEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glintptr");
    return;
  }
  
  GLintptr arg5 = (GLintptr)info[5]->Uint32Value(ctx).ToChecked();


  glVertexArrayTexCoordOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLsizei)arg4,(GLintptr)arg5);

}

      
NAN_METHOD(vertexArrayVertexAttribDivisorEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribDivisorEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(vertexArrayVertexAttribIOffsetEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glintptr");
    return;
  }
  
  GLintptr arg6 = (GLintptr)info[6]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribIOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLint)arg3,(GLenum)arg4,(GLsizei)arg5,(GLintptr)arg6);

}

      
NAN_METHOD(vertexArrayVertexAttribOffsetEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glintptr");
    return;
  }
  
  GLintptr arg7 = (GLintptr)info[7]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLint)arg3,(GLenum)arg4,(GLboolean)arg5,(GLsizei)arg6,(GLintptr)arg7);

}

      
NAN_METHOD(vertexArrayVertexOffsetEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glintptr");
    return;
  }
  
  GLintptr arg5 = (GLintptr)info[5]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLenum)arg3,(GLsizei)arg4,(GLintptr)arg5);

}

      
NAN_METHOD(discardFramebufferEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }


  glDiscardFramebufferEXT((GLenum)arg0,(GLsizei)arg1,(const GLenum*)arg2);

}

      
NAN_METHOD(drawBuffersEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLenum* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLenum*>(*arg1_tarray);
  }


  glDrawBuffersEXT((GLsizei)arg0,(const GLenum*)arg1);

}

      
NAN_METHOD(colorMaskIndexedEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glboolean");
    return;
  }
  
  GLboolean arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glColorMaskIndexedEXT((GLuint)arg0,(GLboolean)arg1,(GLboolean)arg2,(GLboolean)arg3,(GLboolean)arg4);

}

      
NAN_METHOD(disableIndexedEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDisableIndexedEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(enableIndexedEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glEnableIndexedEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(getBooleanIndexedvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  glGetBooleanIndexedvEXT((GLenum)arg0,(GLuint)arg1,(GLboolean*)arg2);

}

      
NAN_METHOD(getIntegerIndexedvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetIntegerIndexedvEXT((GLenum)arg0,(GLuint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isEnabledIndexedEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsEnabledIndexedEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(blendEquationSeparateiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendEquationSeparateiEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(blendEquationiEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendEquationiEXT((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(blendFuncSeparateiEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glBlendFuncSeparateiEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4);

}

      
NAN_METHOD(blendFunciEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glBlendFunciEXT((GLuint)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(colorMaskiEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glboolean");
    return;
  }
  
  GLboolean arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glColorMaskiEXT((GLuint)arg0,(GLboolean)arg1,(GLboolean)arg2,(GLboolean)arg3,(GLboolean)arg4);

}

      
NAN_METHOD(disableiEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDisableiEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(enableiEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glEnableiEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(isEnablediEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsEnablediEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(drawElementsBaseVertexEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glDrawElementsBaseVertexEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLint)arg4);

}

      
NAN_METHOD(drawElementsInstancedBaseVertexEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glDrawElementsInstancedBaseVertexEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4,(GLint)arg5);

}

      
NAN_METHOD(drawRangeElementsBaseVertexEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glDrawRangeElementsBaseVertexEXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(GLenum)arg4,(const void*)arg5,(GLint)arg6);

}

      
NAN_METHOD(multiDrawElementsBaseVertexEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLsizei* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLsizei*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsArray()) {
    Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
    return;
  }
  
  auto array3 = info[0].As<v8::Array>();
  void** arg3 = static_cast<void**>(alloca(sizeof(void*)*array3->Length()));
    
  for (unsigned int i=0; i<array3->Length(); i++) {
    auto val = array3->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg3[i] = reinterpret_cast<void*>(*item); 
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLint* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLint*>(*arg5_tarray);
  }


  glMultiDrawElementsBaseVertexEXT((GLenum)arg0,(const GLsizei*)arg1,(GLenum)arg2,(const void* const*)arg3,(GLsizei)arg4,(const GLint*)arg5);

}

      
NAN_METHOD(drawArraysInstancedEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawArraysInstancedEXT((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(drawElementsInstancedEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(drawRangeElementsEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glDrawRangeElementsEXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(fogCoordPointerEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glFogCoordPointerEXT((GLenum)arg0,(GLsizei)arg1,(const void*)arg2);

}

      
NAN_METHOD(fogCoorddEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();


  glFogCoorddEXT((GLdouble)arg0);

}

      
NAN_METHOD(fogCoorddvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glFogCoorddvEXT((const GLdouble*)arg0);

}

      
NAN_METHOD(fogCoordfEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glFogCoordfEXT((GLfloat)arg0);

}

      
NAN_METHOD(fogCoordfvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glFogCoordfvEXT((const GLfloat*)arg0);

}

      
NAN_METHOD(fragmentColorMaterialEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glFragmentColorMaterialEXT((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(fragmentLightModelfEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glFragmentLightModelfEXT((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(fragmentLightModelfvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glFragmentLightModelfvEXT((GLenum)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(fragmentLightModeliEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glFragmentLightModeliEXT((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(fragmentLightModelivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glFragmentLightModelivEXT((GLenum)arg0,(GLint*)arg1);

}

      
NAN_METHOD(fragmentLightfEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glFragmentLightfEXT((GLenum)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(fragmentLightfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glFragmentLightfvEXT((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(fragmentLightiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glFragmentLightiEXT((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(fragmentLightivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glFragmentLightivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(fragmentMaterialfEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glFragmentMaterialfEXT((GLenum)arg0,(GLenum)arg1,(const GLfloat)arg2);

}

      
NAN_METHOD(fragmentMaterialfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glFragmentMaterialfvEXT((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(fragmentMaterialiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glFragmentMaterialiEXT((GLenum)arg0,(GLenum)arg1,(const GLint)arg2);

}

      
NAN_METHOD(fragmentMaterialivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glFragmentMaterialivEXT((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(getFragmentLightfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetFragmentLightfvEXT((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getFragmentLightivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetFragmentLightivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getFragmentMaterialfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetFragmentMaterialfvEXT((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(getFragmentMaterialivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetFragmentMaterialivEXT((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(lightEnviEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glLightEnviEXT((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(blitFramebufferEXT) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glbitfield");
    return;
  }
  
  GLbitfield arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();


  glBlitFramebufferEXT((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLbitfield)arg8,(GLenum)arg9);

}

      
NAN_METHOD(renderbufferStorageMultisampleEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorageMultisampleEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(bindFramebufferEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindFramebufferEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bindRenderbufferEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindRenderbufferEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(checkFramebufferStatusEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLenum retval = glCheckFramebufferStatusEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(deleteFramebuffersEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteFramebuffersEXT((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(deleteRenderbuffersEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteRenderbuffersEXT((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(framebufferRenderbufferEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glFramebufferRenderbufferEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3);

}

      
NAN_METHOD(framebufferTexture1DEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTexture1DEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4);

}

      
NAN_METHOD(framebufferTexture2DEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTexture2DEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4);

}

      
NAN_METHOD(framebufferTexture3DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glFramebufferTexture3DEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4,(GLint)arg5);

}

      
NAN_METHOD(genFramebuffersEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenFramebuffersEXT((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(genRenderbuffersEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenRenderbuffersEXT((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(generateMipmapEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glGenerateMipmapEXT((GLenum)arg0);

}

      
NAN_METHOD(getFramebufferAttachmentParameterivEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetFramebufferAttachmentParameterivEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getRenderbufferParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetRenderbufferParameterivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isFramebufferEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsFramebufferEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isRenderbufferEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsRenderbufferEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(renderbufferStorageEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorageEXT((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(framebufferTextureEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glFramebufferTextureEXT((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3);

}

      
NAN_METHOD(framebufferTextureFaceEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTextureFaceEXT((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLenum)arg4);

}

      
NAN_METHOD(programParameteriEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glProgramParameteriEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(programEnvParameters4fvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramEnvParameters4fvEXT((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(programLocalParameters4fvEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramLocalParameters4fvEXT((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(bindFragDataLocationEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  glBindFragDataLocationEXT((GLuint)arg0,(GLuint)arg1,(const GLchar*)arg2);

}

      
NAN_METHOD(getFragDataLocationEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLint retval = glGetFragDataLocationEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getUniformuivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetUniformuivEXT((GLuint)arg0,(GLint)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(getVertexAttribIivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVertexAttribIivEXT((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVertexAttribIuivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetVertexAttribIuivEXT((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(uniform1uiEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glUniform1uiEXT((GLint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(uniform1uivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform1uivEXT((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(uniform2uiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glUniform2uiEXT((GLint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(uniform2uivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform2uivEXT((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(uniform3uiEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glUniform3uiEXT((GLint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(uniform3uivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform3uivEXT((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(uniform4uiEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glUniform4uiEXT((GLint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(uniform4uivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glUniform4uivEXT((GLint)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(vertexAttribI1iEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexAttribI1iEXT((GLuint)arg0,(GLint)arg1);

}

      
NAN_METHOD(vertexAttribI1ivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI1ivEXT((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI1uiEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribI1uiEXT((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(vertexAttribI1uivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI1uivEXT((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI2iEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexAttribI2iEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(vertexAttribI2ivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI2ivEXT((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI2uiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexAttribI2uiEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(vertexAttribI2uivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI2uivEXT((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI3iEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertexAttribI3iEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(vertexAttribI3ivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI3ivEXT((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI3uiEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribI3uiEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(vertexAttribI3uivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI3uivEXT((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI4bvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glVertexAttribI4bvEXT((GLuint)arg0,(const GLbyte*)arg1);

}

      
NAN_METHOD(vertexAttribI4iEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glVertexAttribI4iEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(vertexAttribI4ivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVertexAttribI4ivEXT((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(vertexAttribI4svEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttribI4svEXT((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttribI4ubvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVertexAttribI4ubvEXT((GLuint)arg0,(const GLubyte*)arg1);

}

      
NAN_METHOD(vertexAttribI4uiEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttribI4uiEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(vertexAttribI4uivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVertexAttribI4uivEXT((GLuint)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(vertexAttribI4usvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glVertexAttribI4usvEXT((GLuint)arg0,(const GLushort*)arg1);

}

      
NAN_METHOD(vertexAttribIPointerEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glVertexAttribIPointerEXT((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(getHistogramEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetHistogramEXT((GLenum)arg0,(GLboolean)arg1,(GLenum)arg2,(GLenum)arg3,(void*)arg4);

}

      
NAN_METHOD(getHistogramParameterfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetHistogramParameterfvEXT((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getHistogramParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetHistogramParameterivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getMinmaxEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glGetMinmaxEXT((GLenum)arg0,(GLboolean)arg1,(GLenum)arg2,(GLenum)arg3,(void*)arg4);

}

      
NAN_METHOD(getMinmaxParameterfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetMinmaxParameterfvEXT((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getMinmaxParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetMinmaxParameterivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(histogramEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glHistogramEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLboolean)arg3);

}

      
NAN_METHOD(minmaxEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glMinmaxEXT((GLenum)arg0,(GLenum)arg1,(GLboolean)arg2);

}

      
NAN_METHOD(resetHistogramEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glResetHistogramEXT((GLenum)arg0);

}

      
NAN_METHOD(resetMinmaxEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glResetMinmaxEXT((GLenum)arg0);

}

      
NAN_METHOD(indexFuncEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glIndexFuncEXT((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(indexMaterialEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glIndexMaterialEXT((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(vertexAttribDivisorEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribDivisorEXT((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(applyTextureEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glApplyTextureEXT((GLenum)arg0);

}

      
NAN_METHOD(textureLightEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glTextureLightEXT((GLenum)arg0);

}

      
NAN_METHOD(textureMaterialEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glTextureMaterialEXT((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(flushMappedBufferRangeEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glintptr");
    return;
  }
  
  GLintptr arg1 = (GLintptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();


  glFlushMappedBufferRangeEXT((GLenum)arg0,(GLintptr)arg1,(GLsizeiptr)arg2);

}

      
NAN_METHOD(bufferStorageMemEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64");
    return;
  }
  
  GLuint64 arg3 = (GLuint64)info[3]->Uint32Value(ctx).ToChecked();


  glBufferStorageMemEXT((GLenum)arg0,(GLsizeiptr)arg1,(GLuint)arg2,(GLuint64)arg3);

}

      
NAN_METHOD(createMemoryObjectsEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateMemoryObjectsEXT((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(deleteMemoryObjectsEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteMemoryObjectsEXT((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(getMemoryObjectParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetMemoryObjectParameterivEXT((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getUnsignedBytei_vEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }


  glGetUnsignedBytei_vEXT((GLenum)arg0,(GLuint)arg1,(GLubyte*)arg2);

}

      
NAN_METHOD(getUnsignedBytevEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glGetUnsignedBytevEXT((GLenum)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(isMemoryObjectEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsMemoryObjectEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(memoryObjectParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glMemoryObjectParameterivEXT((GLuint)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(namedBufferStorageMemEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg1 = (GLsizeiptr)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64");
    return;
  }
  
  GLuint64 arg3 = (GLuint64)info[3]->Uint32Value(ctx).ToChecked();


  glNamedBufferStorageMemEXT((GLuint)arg0,(GLsizeiptr)arg1,(GLuint)arg2,(GLuint64)arg3);

}

      
NAN_METHOD(texStorageMem1DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint64");
    return;
  }
  
  GLuint64 arg5 = (GLuint64)info[5]->Uint32Value(ctx).ToChecked();


  glTexStorageMem1DEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLuint)arg4,(GLuint64)arg5);

}

      
NAN_METHOD(texStorageMem2DEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint64");
    return;
  }
  
  GLuint64 arg6 = (GLuint64)info[6]->Uint32Value(ctx).ToChecked();


  glTexStorageMem2DEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLuint)arg5,(GLuint64)arg6);

}

      
NAN_METHOD(texStorageMem2DMultisampleEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint64");
    return;
  }
  
  GLuint64 arg7 = (GLuint64)info[7]->Uint32Value(ctx).ToChecked();


  glTexStorageMem2DMultisampleEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLboolean)arg5,(GLuint)arg6,(GLuint64)arg7);

}

      
NAN_METHOD(texStorageMem3DEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint64");
    return;
  }
  
  GLuint64 arg7 = (GLuint64)info[7]->Uint32Value(ctx).ToChecked();


  glTexStorageMem3DEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLuint)arg6,(GLuint64)arg7);

}

      
NAN_METHOD(texStorageMem3DMultisampleEXT) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint64");
    return;
  }
  
  GLuint64 arg8 = (GLuint64)info[8]->Uint32Value(ctx).ToChecked();


  glTexStorageMem3DMultisampleEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6,(GLuint)arg7,(GLuint64)arg8);

}

      
NAN_METHOD(textureStorageMem1DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint64");
    return;
  }
  
  GLuint64 arg5 = (GLuint64)info[5]->Uint32Value(ctx).ToChecked();


  glTextureStorageMem1DEXT((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLuint)arg4,(GLuint64)arg5);

}

      
NAN_METHOD(textureStorageMem2DEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint64");
    return;
  }
  
  GLuint64 arg6 = (GLuint64)info[6]->Uint32Value(ctx).ToChecked();


  glTextureStorageMem2DEXT((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLuint)arg5,(GLuint64)arg6);

}

      
NAN_METHOD(textureStorageMem2DMultisampleEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint64");
    return;
  }
  
  GLuint64 arg7 = (GLuint64)info[7]->Uint32Value(ctx).ToChecked();


  glTextureStorageMem2DMultisampleEXT((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLboolean)arg5,(GLuint)arg6,(GLuint64)arg7);

}

      
NAN_METHOD(textureStorageMem3DEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint64");
    return;
  }
  
  GLuint64 arg7 = (GLuint64)info[7]->Uint32Value(ctx).ToChecked();


  glTextureStorageMem3DEXT((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLuint)arg6,(GLuint64)arg7);

}

      
NAN_METHOD(textureStorageMem3DMultisampleEXT) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint64");
    return;
  }
  
  GLuint64 arg8 = (GLuint64)info[8]->Uint32Value(ctx).ToChecked();


  glTextureStorageMem3DMultisampleEXT((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6,(GLuint)arg7,(GLuint64)arg8);

}

      
NAN_METHOD(importMemoryFdEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glImportMemoryFdEXT((GLuint)arg0,(GLuint64)arg1,(GLenum)arg2,(GLint)arg3);

}

      
NAN_METHOD(importMemoryWin32HandleEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glImportMemoryWin32HandleEXT((GLuint)arg0,(GLuint64)arg1,(GLenum)arg2,(void*)arg3);

}

      
NAN_METHOD(importMemoryWin32NameEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glImportMemoryWin32NameEXT((GLuint)arg0,(GLuint64)arg1,(GLenum)arg2,(const void*)arg3);

}

      
NAN_METHOD(multiDrawArraysEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glMultiDrawArraysEXT((GLenum)arg0,(const GLint*)arg1,(const GLsizei*)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(multiDrawElementsEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLsizei* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLsizei*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsArray()) {
    Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
    return;
  }
  
  auto array3 = info[0].As<v8::Array>();
  void** arg3 = static_cast<void**>(alloca(sizeof(void*)*array3->Length()));
    
  for (unsigned int i=0; i<array3->Length(); i++) {
    auto val = array3->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 4, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg3[i] = reinterpret_cast<void*>(*item); 
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiDrawElementsEXT((GLenum)arg0,(GLsizei*)arg1,(GLenum)arg2,(const void* const*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(multiDrawArraysIndirectEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glMultiDrawArraysIndirectEXT((GLenum)arg0,(const void*)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(multiDrawElementsIndirectEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiDrawElementsIndirectEXT((GLenum)arg0,(GLenum)arg1,(const void*)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(sampleMaskEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampf");
    return;
  }
  
  GLclampf arg0 = (GLclampf)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glSampleMaskEXT((GLclampf)arg0,(GLboolean)arg1);

}

      
NAN_METHOD(samplePatternEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glSamplePatternEXT((GLenum)arg0);

}

      
NAN_METHOD(framebufferTexture2DMultisampleEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glFramebufferTexture2DMultisampleEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLuint)arg3,(GLint)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(drawBuffersIndexedEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLenum* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLenum*>(*arg1_tarray);
  }
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glDrawBuffersIndexedEXT((GLint)arg0,(const GLenum*)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(getIntegeri_vEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetIntegeri_vEXT((GLenum)arg0,(GLuint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(readBufferIndexedEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glReadBufferIndexedEXT((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(colorTableEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glColorTableEXT((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(getColorTableEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glGetColorTableEXT((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(void*)arg3);

}

      
NAN_METHOD(getColorTableParameterfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetColorTableParameterfvEXT((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getColorTableParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetColorTableParameterivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getPixelTransformParameterfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetPixelTransformParameterfvEXT((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(getPixelTransformParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetPixelTransformParameterivEXT((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(pixelTransformParameterfEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glPixelTransformParameterfEXT((GLenum)arg0,(GLenum)arg1,(const GLfloat)arg2);

}

      
NAN_METHOD(pixelTransformParameterfvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glPixelTransformParameterfvEXT((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(pixelTransformParameteriEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glPixelTransformParameteriEXT((GLenum)arg0,(GLenum)arg1,(const GLint)arg2);

}

      
NAN_METHOD(pixelTransformParameterivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glPixelTransformParameterivEXT((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(pointParameterfEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPointParameterfEXT((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pointParameterfvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glPointParameterfvEXT((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(polygonOffsetEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPolygonOffsetEXT((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(polygonOffsetClampEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glPolygonOffsetClampEXT((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(provokingVertexEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glProvokingVertexEXT((GLenum)arg0);

}

      
NAN_METHOD(coverageModulationNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glCoverageModulationNV((GLenum)arg0);

}

      
NAN_METHOD(coverageModulationTableNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glCoverageModulationTableNV((GLsizei)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(getCoverageModulationTableNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glGetCoverageModulationTableNV((GLsizei)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(rasterSamplesEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glRasterSamplesEXT((GLuint)arg0,(GLboolean)arg1);

}

      
NAN_METHOD(beginSceneEXT) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glBeginSceneEXT();

}

      
NAN_METHOD(endSceneEXT) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndSceneEXT();

}

      
NAN_METHOD(secondaryColor3bEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbyte");
    return;
  }
  
  GLbyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbyte");
    return;
  }
  
  GLbyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glbyte");
    return;
  }
  
  GLbyte arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3bEXT((GLbyte)arg0,(GLbyte)arg1,(GLbyte)arg2);

}

      
NAN_METHOD(secondaryColor3bvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLbyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLbyte*>(*arg0_tarray);
  }


  glSecondaryColor3bvEXT((const GLbyte*)arg0);

}

      
NAN_METHOD(secondaryColor3dEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glSecondaryColor3dEXT((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(secondaryColor3dvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glSecondaryColor3dvEXT((const GLdouble*)arg0);

}

      
NAN_METHOD(secondaryColor3fEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glSecondaryColor3fEXT((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(secondaryColor3fvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glSecondaryColor3fvEXT((const GLfloat*)arg0);

}

      
NAN_METHOD(secondaryColor3iEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glSecondaryColor3iEXT((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(secondaryColor3ivEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glSecondaryColor3ivEXT((const GLint*)arg0);

}

      
NAN_METHOD(secondaryColor3sEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glSecondaryColor3sEXT((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(secondaryColor3svEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glSecondaryColor3svEXT((const GLshort*)arg0);

}

      
NAN_METHOD(secondaryColor3ubEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glubyte");
    return;
  }
  
  GLubyte arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glubyte");
    return;
  }
  
  GLubyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glubyte");
    return;
  }
  
  GLubyte arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3ubEXT((GLubyte)arg0,(GLubyte)arg1,(GLubyte)arg2);

}

      
NAN_METHOD(secondaryColor3ubvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLubyte* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLubyte*>(*arg0_tarray);
  }


  glSecondaryColor3ubvEXT((const GLubyte*)arg0);

}

      
NAN_METHOD(secondaryColor3uiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3uiEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(secondaryColor3uivEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }


  glSecondaryColor3uivEXT((const GLuint*)arg0);

}

      
NAN_METHOD(secondaryColor3usEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glushort");
    return;
  }
  
  GLushort arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glushort");
    return;
  }
  
  GLushort arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glushort");
    return;
  }
  
  GLushort arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColor3usEXT((GLushort)arg0,(GLushort)arg1,(GLushort)arg2);

}

      
NAN_METHOD(secondaryColor3usvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLushort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLushort*>(*arg0_tarray);
  }


  glSecondaryColor3usvEXT((const GLushort*)arg0);

}

      
NAN_METHOD(secondaryColorPointerEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glSecondaryColorPointerEXT((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(deleteSemaphoresEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteSemaphoresEXT((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(genSemaphoresEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenSemaphoresEXT((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getSemaphoreParameterui64vEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glGetSemaphoreParameterui64vEXT((GLuint)arg0,(GLenum)arg1,(GLuint64*)arg2);

}

      
NAN_METHOD(isSemaphoreEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsSemaphoreEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(semaphoreParameterui64vEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glSemaphoreParameterui64vEXT((GLuint)arg0,(GLenum)arg1,(const GLuint64*)arg2);

}

      
NAN_METHOD(signalSemaphoreEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }


  glSignalSemaphoreEXT((GLuint)arg0,(GLuint)arg1,(const GLuint*)arg2,(GLuint)arg3,(const GLuint*)arg4,(const GLenum*)arg5);

}

      
NAN_METHOD(waitSemaphoreEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }


  glWaitSemaphoreEXT((GLuint)arg0,(GLuint)arg1,(const GLuint*)arg2,(GLuint)arg3,(const GLuint*)arg4,(const GLenum*)arg5);

}

      
NAN_METHOD(importSemaphoreFdEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glImportSemaphoreFdEXT((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(importSemaphoreWin32HandleEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glImportSemaphoreWin32HandleEXT((GLuint)arg0,(GLenum)arg1,(void*)arg2);

}

      
NAN_METHOD(importSemaphoreWin32NameEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glImportSemaphoreWin32NameEXT((GLuint)arg0,(GLenum)arg1,(const void*)arg2);

}

      
NAN_METHOD(activeProgramEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glActiveProgramEXT((GLuint)arg0);

}

      
NAN_METHOD(createShaderProgramEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLuint retval = glCreateShaderProgramEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(useShaderProgramEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glUseShaderProgramEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(bindImageTextureEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glBindImageTextureEXT((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLboolean)arg3,(GLint)arg4,(GLenum)arg5,(GLint)arg6);

}

      
NAN_METHOD(memoryBarrierEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glMemoryBarrierEXT((GLbitfield)arg0);

}

      
NAN_METHOD(clearPixelLocalStorageuiEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glClearPixelLocalStorageuiEXT((GLsizei)arg0,(GLsizei)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(framebufferPixelLocalStorageSizeEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glFramebufferPixelLocalStorageSizeEXT((GLuint)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(getFramebufferPixelLocalStorageSizeEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLsizei retval = glGetFramebufferPixelLocalStorageSizeEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(texPageCommitmentEXT) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glboolean");
    return;
  }
  
  GLboolean arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glTexPageCommitmentEXT((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLboolean)arg8);

}

      
NAN_METHOD(texturePageCommitmentEXT) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glboolean");
    return;
  }
  
  GLboolean arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glTexturePageCommitmentEXT((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLboolean)arg8);

}

      
NAN_METHOD(activeStencilFaceEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glActiveStencilFaceEXT((GLenum)arg0);

}

      
NAN_METHOD(texSubImage1DEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glTexSubImage1DEXT((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(const void*)arg6);

}

      
NAN_METHOD(texSubImage2DEXT) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glTexSubImage2DEXT((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLenum)arg6,(GLenum)arg7,(const void*)arg8);

}

      
NAN_METHOD(texSubImage3DEXT) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glTexSubImage3DEXT((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(const void*)arg10);

}

      
NAN_METHOD(texImage3DEXT) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  void* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<void*>(*arg9_tarray);
  }


  glTexImage3DEXT((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6,(GLenum)arg7,(GLenum)arg8,(const void*)arg9);

}

      
NAN_METHOD(framebufferTextureLayerEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTextureLayerEXT((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(texBufferEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTexBufferEXT((GLenum)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(clearColorIiEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glClearColorIiEXT((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(clearColorIuiEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glClearColorIuiEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(getTexParameterIivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTexParameterIivEXT((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getTexParameterIuivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetTexParameterIuivEXT((GLenum)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(texParameterIivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glTexParameterIivEXT((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(texParameterIuivEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glTexParameterIuivEXT((GLenum)arg0,(GLenum)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(areTexturesResidentEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  GLboolean retval = glAreTexturesResidentEXT(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindTextureEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindTextureEXT((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteTexturesEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteTexturesEXT((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(genTexturesEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenTexturesEXT((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(isTextureEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsTextureEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(prioritizeTexturesEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }
  GLclampf* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLclampf*>(*arg2_tarray);
  }


  glPrioritizeTexturesEXT((GLsizei)arg0,(const GLuint*)arg1,(const GLclampf*)arg2);

}

      
NAN_METHOD(textureNormalEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glTextureNormalEXT((GLenum)arg0);

}

      
NAN_METHOD(texStorage1DEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glTexStorage1DEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(texStorage2DEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glTexStorage2DEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(texStorage3DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glTexStorage3DEXT((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(textureStorage1DEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glTextureStorage1DEXT((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(textureStorage2DEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glTextureStorage2DEXT((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(textureStorage3DEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glTextureStorage3DEXT((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLsizei)arg6);

}

      
NAN_METHOD(textureViewEXT) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glTextureViewEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLenum)arg3,(GLuint)arg4,(GLuint)arg5,(GLuint)arg6,(GLuint)arg7);

}

      
NAN_METHOD(getQueryObjecti64vEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glGetQueryObjecti64vEXT((GLuint)arg0,(GLenum)arg1,(GLint64EXT*)arg2);

}

      
NAN_METHOD(getQueryObjectui64vEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glGetQueryObjectui64vEXT((GLuint)arg0,(GLenum)arg1,(GLuint64EXT*)arg2);

}

      
NAN_METHOD(beginTransformFeedbackEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glBeginTransformFeedbackEXT((GLenum)arg0);

}

      
NAN_METHOD(bindBufferBaseEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glBindBufferBaseEXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(bindBufferOffsetEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();


  glBindBufferOffsetEXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3);

}

      
NAN_METHOD(bindBufferRangeEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glBindBufferRangeEXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(endTransformFeedbackEXT) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndTransformFeedbackEXT();

}

      
NAN_METHOD(getTransformFeedbackVaryingEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLchar* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLchar*>(*arg6_tarray);
  }


  glGetTransformFeedbackVaryingEXT((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLsizei*)arg4,(GLenum*)arg5,(GLchar*)arg6);

}

      
NAN_METHOD(transformFeedbackVaryingsEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  GLchar** arg2 = static_cast<GLchar**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<GLchar*>(*item); 
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glTransformFeedbackVaryingsEXT((GLuint)arg0,(GLsizei)arg1,(const GLchar* const*)arg2,(GLenum)arg3);

}

      
NAN_METHOD(arrayElementEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();


  glArrayElementEXT((GLint)arg0);

}

      
NAN_METHOD(colorPointerEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glColorPointerEXT((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(drawArraysEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glDrawArraysEXT((GLenum)arg0,(GLint)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(edgeFlagPointerEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  glEdgeFlagPointerEXT((GLsizei)arg0,(GLsizei)arg1,(const GLboolean*)arg2);

}

      
NAN_METHOD(indexPointerEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glIndexPointerEXT((GLenum)arg0,(GLsizei)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(normalPointerEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glNormalPointerEXT((GLenum)arg0,(GLsizei)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(texCoordPointerEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glTexCoordPointerEXT((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(vertexPointerEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glVertexPointerEXT((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(bindArraySetEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  void* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<void*>(*arg0_tarray);
  }


  glBindArraySetEXT((const void*)arg0);

}

      
NAN_METHOD(getVertexAttribLdvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetVertexAttribLdvEXT((GLuint)arg0,(GLenum)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(vertexArrayVertexAttribLOffsetEXT) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glintptr");
    return;
  }
  
  GLintptr arg6 = (GLintptr)info[6]->Uint32Value(ctx).ToChecked();


  glVertexArrayVertexAttribLOffsetEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLint)arg3,(GLenum)arg4,(GLsizei)arg5,(GLintptr)arg6);

}

      
NAN_METHOD(vertexAttribL1dEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttribL1dEXT((GLuint)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(vertexAttribL1dvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL1dvEXT((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribL2dEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttribL2dEXT((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(vertexAttribL2dvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL2dvEXT((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribL3dEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttribL3dEXT((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(vertexAttribL3dvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL3dvEXT((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribL4dEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttribL4dEXT((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(vertexAttribL4dvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttribL4dvEXT((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttribLPointerEXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glVertexAttribLPointerEXT((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(beginVertexShaderEXT) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glBeginVertexShaderEXT();

}

      
NAN_METHOD(bindLightParameterEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLuint retval = glBindLightParameterEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindMaterialParameterEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLuint retval = glBindMaterialParameterEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindParameterEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLuint retval = glBindParameterEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindTexGenParameterEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  GLuint retval = glBindTexGenParameterEXT(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindTextureUnitParameterEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLuint retval = glBindTextureUnitParameterEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindVertexShaderEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBindVertexShaderEXT((GLuint)arg0);

}

      
NAN_METHOD(deleteVertexShaderEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDeleteVertexShaderEXT((GLuint)arg0);

}

      
NAN_METHOD(disableVariantClientStateEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDisableVariantClientStateEXT((GLuint)arg0);

}

      
NAN_METHOD(enableVariantClientStateEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEnableVariantClientStateEXT((GLuint)arg0);

}

      
NAN_METHOD(endVertexShaderEXT) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndVertexShaderEXT();

}

      
NAN_METHOD(extractComponentEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glExtractComponentEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(genSymbolsEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  GLuint retval = glGenSymbolsEXT(arg0,arg1,arg2,arg3);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(genVertexShadersEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLuint retval = glGenVertexShadersEXT(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getInvariantBooleanvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  glGetInvariantBooleanvEXT((GLuint)arg0,(GLenum)arg1,(GLboolean*)arg2);

}

      
NAN_METHOD(getInvariantFloatvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetInvariantFloatvEXT((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getInvariantIntegervEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetInvariantIntegervEXT((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getLocalConstantBooleanvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  glGetLocalConstantBooleanvEXT((GLuint)arg0,(GLenum)arg1,(GLboolean*)arg2);

}

      
NAN_METHOD(getLocalConstantFloatvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetLocalConstantFloatvEXT((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getLocalConstantIntegervEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetLocalConstantIntegervEXT((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVariantBooleanvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  glGetVariantBooleanvEXT((GLuint)arg0,(GLenum)arg1,(GLboolean*)arg2);

}

      
NAN_METHOD(getVariantFloatvEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetVariantFloatvEXT((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getVariantIntegervEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVariantIntegervEXT((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVariantPointervEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetVariantPointervEXT((GLuint)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(insertComponentEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glInsertComponentEXT((GLuint)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(isVariantEnabledEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  GLboolean retval = glIsVariantEnabledEXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(setInvariantEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glSetInvariantEXT((GLuint)arg0,(GLenum)arg1,(void*)arg2);

}

      
NAN_METHOD(setLocalConstantEXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glSetLocalConstantEXT((GLuint)arg0,(GLenum)arg1,(void*)arg2);

}

      
NAN_METHOD(shaderOp1EXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glShaderOp1EXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(shaderOp2EXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glShaderOp2EXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3);

}

      
NAN_METHOD(shaderOp3EXT) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glShaderOp3EXT((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4);

}

      
NAN_METHOD(swizzleEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();


  glSwizzleEXT((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4,(GLenum)arg5);

}

      
NAN_METHOD(variantPointerEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glVariantPointerEXT((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(void*)arg3);

}

      
NAN_METHOD(variantbvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLbyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLbyte*>(*arg1_tarray);
  }


  glVariantbvEXT((GLuint)arg0,(GLbyte*)arg1);

}

      
NAN_METHOD(variantdvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVariantdvEXT((GLuint)arg0,(GLdouble*)arg1);

}

      
NAN_METHOD(variantfvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVariantfvEXT((GLuint)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(variantivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glVariantivEXT((GLuint)arg0,(GLint*)arg1);

}

      
NAN_METHOD(variantsvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVariantsvEXT((GLuint)arg0,(GLshort*)arg1);

}

      
NAN_METHOD(variantubvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVariantubvEXT((GLuint)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(variantuivEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glVariantuivEXT((GLuint)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(variantusvEXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLushort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLushort*>(*arg1_tarray);
  }


  glVariantusvEXT((GLuint)arg0,(GLushort*)arg1);

}

      
NAN_METHOD(writeMaskEXT) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();


  glWriteMaskEXT((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4,(GLenum)arg5);

}

      
NAN_METHOD(vertexWeightPointerEXT) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glVertexWeightPointerEXT((GLint)arg0,(GLenum)arg1,(GLsizei)arg2,(void*)arg3);

}

      
NAN_METHOD(vertexWeightfEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();


  glVertexWeightfEXT((GLfloat)arg0);

}

      
NAN_METHOD(vertexWeightfvEXT) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glVertexWeightfvEXT((GLfloat*)arg0);

}

      
NAN_METHOD(acquireKeyedMutexWin32EXT) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glAcquireKeyedMutexWin32EXT(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(releaseKeyedMutexWin32EXT) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glReleaseKeyedMutexWin32EXT(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(frameTerminatorGREMEDY) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glFrameTerminatorGREMEDY();

}

      
NAN_METHOD(stringMarkerGREMEDY) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glStringMarkerGREMEDY((GLsizei)arg0,(const void*)arg1);

}

      
NAN_METHOD(getImageTransformParameterfvHP) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetImageTransformParameterfvHP((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(getImageTransformParameterivHP) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetImageTransformParameterivHP((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(imageTransformParameterfHP) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glImageTransformParameterfHP((GLenum)arg0,(GLenum)arg1,(const GLfloat)arg2);

}

      
NAN_METHOD(imageTransformParameterfvHP) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glImageTransformParameterfvHP((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(imageTransformParameteriHP) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glImageTransformParameteriHP((GLenum)arg0,(GLenum)arg1,(const GLint)arg2);

}

      
NAN_METHOD(imageTransformParameterivHP) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glImageTransformParameterivHP((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(syncTextureINTEL) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glSyncTextureINTEL((GLuint)arg0);

}

      
NAN_METHOD(unmapTexture2DINTEL) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glUnmapTexture2DINTEL((GLuint)arg0,(GLint)arg1);

}

      
NAN_METHOD(beginPerfQueryINTEL) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBeginPerfQueryINTEL((GLuint)arg0);

}

      
NAN_METHOD(createPerfQueryINTEL) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreatePerfQueryINTEL((GLuint)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(deletePerfQueryINTEL) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDeletePerfQueryINTEL((GLuint)arg0);

}

      
NAN_METHOD(endPerfQueryINTEL) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEndPerfQueryINTEL((GLuint)arg0);

}

      
NAN_METHOD(getFirstPerfQueryIdINTEL) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }


  glGetFirstPerfQueryIdINTEL((GLuint*)arg0);

}

      
NAN_METHOD(getNextPerfQueryIdINTEL) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGetNextPerfQueryIdINTEL((GLuint)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getPerfCounterInfoINTEL) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLchar* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLchar*>(*arg5_tarray);
  }
  GLuint* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLuint*>(*arg6_tarray);
  }
  GLuint* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLuint*>(*arg7_tarray);
  }
  GLuint* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<GLuint*>(*arg8_tarray);
  }
  GLuint* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<GLuint*>(*arg9_tarray);
  }
  GLuint64* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<GLuint64*>(*arg10_tarray);
  }


  glGetPerfCounterInfoINTEL((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLchar*)arg3,(GLuint)arg4,(GLchar*)arg5,(GLuint*)arg6,(GLuint*)arg7,(GLuint*)arg8,(GLuint*)arg9,(GLuint64*)arg10);

}

      
NAN_METHOD(getPerfQueryDataINTEL) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glGetPerfQueryDataINTEL((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(void*)arg3,(GLuint*)arg4);

}

      
NAN_METHOD(getPerfQueryIdByNameINTEL) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLchar* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLchar*>(*arg0_tarray);
  }
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGetPerfQueryIdByNameINTEL((GLchar*)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getPerfQueryInfoINTEL) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  GLuint* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLuint*>(*arg5_tarray);
  }
  GLuint* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLuint*>(*arg6_tarray);
  }


  glGetPerfQueryInfoINTEL((GLuint)arg0,(GLuint)arg1,(GLchar*)arg2,(GLuint*)arg3,(GLuint*)arg4,(GLuint*)arg5,(GLuint*)arg6);

}

      
NAN_METHOD(texScissorFuncINTEL) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTexScissorFuncINTEL((GLenum)arg0,(GLenum)arg1,(GLenum)arg2);

}

      
NAN_METHOD(texScissorINTEL) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampf");
    return;
  }
  
  GLclampf arg1 = (GLclampf)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glclampf");
    return;
  }
  
  GLclampf arg2 = (GLclampf)info[2]->NumberValue(ctx).ToChecked();


  glTexScissorINTEL((GLenum)arg0,(GLclampf)arg1,(GLclampf)arg2);

}

      
NAN_METHOD(blendBarrierKHR) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glBlendBarrierKHR();

}

      
NAN_METHOD(debugMessageControl) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glDebugMessageControl((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLsizei)arg3,(const GLuint*)arg4,(GLboolean)arg5);

}

      
NAN_METHOD(debugMessageInsert) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLchar* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLchar*>(*arg5_tarray);
  }


  glDebugMessageInsert((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLenum)arg3,(GLsizei)arg4,(const GLchar*)arg5);

}

      
NAN_METHOD(getDebugMessageLog) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLenum* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLenum*>(*arg2_tarray);
  }
  GLenum* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLenum*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLsizei* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLsizei*>(*arg6_tarray);
  }
  GLchar* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLchar*>(*arg7_tarray);
  }


  GLuint retval = glGetDebugMessageLog(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getObjectLabel) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLchar* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLchar*>(*arg4_tarray);
  }


  glGetObjectLabel((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLchar*)arg4);

}

      
NAN_METHOD(getObjectPtrLabel) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  void* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<void*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetObjectPtrLabel((void*)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(objectLabel) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glObjectLabel((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLchar*)arg3);

}

      
NAN_METHOD(objectPtrLabel) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  void* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<void*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }


  glObjectPtrLabel((void*)arg0,(GLsizei)arg1,(const GLchar*)arg2);

}

      
NAN_METHOD(popDebugGroup) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPopDebugGroup();

}

      
NAN_METHOD(pushDebugGroup) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glPushDebugGroup((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLchar*)arg3);

}

      
NAN_METHOD(maxShaderCompilerThreadsKHR) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glMaxShaderCompilerThreadsKHR((GLuint)arg0);

}

      
NAN_METHOD(getnUniformfv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetnUniformfv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getnUniformiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetnUniformiv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getnUniformuiv) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glGetnUniformuiv((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(GLuint*)arg3);

}

      
NAN_METHOD(readnPixels) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glReadnPixels((GLint)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLenum)arg4,(GLenum)arg5,(GLsizei)arg6,(void*)arg7);

}

      
NAN_METHOD(bufferRegionEnabled) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  GLuint retval = glBufferRegionEnabled();

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(deleteBufferRegion) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glDeleteBufferRegion((GLenum)arg0);

}

      
NAN_METHOD(drawBufferRegion) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glDrawBufferRegion((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLint)arg5,(GLint)arg6);

}

      
NAN_METHOD(newBufferRegion) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLuint retval = glNewBufferRegion(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(readBufferRegion) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glReadBufferRegion((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(resizeBuffersMESA) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glResizeBuffersMESA();

}

      
NAN_METHOD(windowPos2dMESA) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glWindowPos2dMESA((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(windowPos2dvMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glWindowPos2dvMESA((const GLdouble*)arg0);

}

      
NAN_METHOD(windowPos2fMESA) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glWindowPos2fMESA((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(windowPos2fvMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glWindowPos2fvMESA((const GLfloat*)arg0);

}

      
NAN_METHOD(windowPos2iMESA) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glWindowPos2iMESA((GLint)arg0,(GLint)arg1);

}

      
NAN_METHOD(windowPos2ivMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glWindowPos2ivMESA((const GLint*)arg0);

}

      
NAN_METHOD(windowPos2sMESA) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glWindowPos2sMESA((GLshort)arg0,(GLshort)arg1);

}

      
NAN_METHOD(windowPos2svMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glWindowPos2svMESA((const GLshort*)arg0);

}

      
NAN_METHOD(windowPos3dMESA) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glWindowPos3dMESA((GLdouble)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(windowPos3dvMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glWindowPos3dvMESA((const GLdouble*)arg0);

}

      
NAN_METHOD(windowPos3fMESA) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glWindowPos3fMESA((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(windowPos3fvMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glWindowPos3fvMESA((const GLfloat*)arg0);

}

      
NAN_METHOD(windowPos3iMESA) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glWindowPos3iMESA((GLint)arg0,(GLint)arg1,(GLint)arg2);

}

      
NAN_METHOD(windowPos3ivMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glWindowPos3ivMESA((const GLint*)arg0);

}

      
NAN_METHOD(windowPos3sMESA) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glWindowPos3sMESA((GLshort)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(windowPos3svMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glWindowPos3svMESA((const GLshort*)arg0);

}

      
NAN_METHOD(windowPos4dvMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLdouble* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLdouble*>(*arg0_tarray);
  }


  glWindowPos4dvMESA((const GLdouble*)arg0);

}

      
NAN_METHOD(windowPos4fMESA) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glWindowPos4fMESA((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(windowPos4fvMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfloat* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfloat*>(*arg0_tarray);
  }


  glWindowPos4fvMESA((const GLfloat*)arg0);

}

      
NAN_METHOD(windowPos4iMESA) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();


  glWindowPos4iMESA((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3);

}

      
NAN_METHOD(windowPos4ivMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }


  glWindowPos4ivMESA((const GLint*)arg0);

}

      
NAN_METHOD(windowPos4sMESA) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glshort");
    return;
  }
  
  GLshort arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glWindowPos4sMESA((GLshort)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(windowPos4svMESA) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLshort* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLshort*>(*arg0_tarray);
  }


  glWindowPos4svMESA((const GLshort*)arg0);

}

      
NAN_METHOD(beginConditionalRenderNVX) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBeginConditionalRenderNVX((GLuint)arg0);

}

      
NAN_METHOD(endConditionalRenderNVX) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndConditionalRenderNVX();

}

      
NAN_METHOD(lGPUCopyImageSubDataNVX) {
  if (info.Length() != 17) {
    Nan::ThrowError("Expected 17 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glint");
    return;
  }
  
  GLint arg10 = info[10]->Int32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glint");
    return;
  }
  
  GLint arg11 = info[11]->Int32Value(ctx).ToChecked();
  if (!info[12]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 13, expected a glint");
    return;
  }
  
  GLint arg12 = info[12]->Int32Value(ctx).ToChecked();
  if (!info[13]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 14, expected a glint");
    return;
  }
  
  GLint arg13 = info[13]->Int32Value(ctx).ToChecked();
  if (!info[14]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 15, expected a glsizei");
    return;
  }
  
  GLsizei arg14 = info[14]->Uint32Value(ctx).ToChecked();
  if (!info[15]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 16, expected a glsizei");
    return;
  }
  
  GLsizei arg15 = info[15]->Uint32Value(ctx).ToChecked();
  if (!info[16]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 17, expected a glsizei");
    return;
  }
  
  GLsizei arg16 = info[16]->Uint32Value(ctx).ToChecked();


  glLGPUCopyImageSubDataNVX((GLuint)arg0,(GLbitfield)arg1,(GLuint)arg2,(GLenum)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLuint)arg8,(GLenum)arg9,(GLint)arg10,(GLint)arg11,(GLint)arg12,(GLint)arg13,(GLsizei)arg14,(GLsizei)arg15,(GLsizei)arg16);

}

      
NAN_METHOD(lGPUInterlockNVX) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glLGPUInterlockNVX();

}

      
NAN_METHOD(lGPUNamedBufferSubDataNVX) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg3 = (GLsizeiptr)info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glLGPUNamedBufferSubDataNVX((GLbitfield)arg0,(GLuint)arg1,(GLintptr)arg2,(GLsizeiptr)arg3,(const void*)arg4);

}

      
NAN_METHOD(stereoParameterfNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glStereoParameterfNV((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(stereoParameteriNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glStereoParameteriNV((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(multiDrawArraysIndirectBindlessNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glMultiDrawArraysIndirectBindlessNV((GLenum)arg0,(const void*)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLint)arg4);

}

      
NAN_METHOD(multiDrawElementsIndirectBindlessNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glMultiDrawElementsIndirectBindlessNV((GLenum)arg0,(GLenum)arg1,(const void*)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLint)arg5);

}

      
NAN_METHOD(multiDrawArraysIndirectBindlessCountNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glMultiDrawArraysIndirectBindlessCountNV((GLenum)arg0,(const void*)arg1,(GLintptr)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLint)arg5);

}

      
NAN_METHOD(multiDrawElementsIndirectBindlessCountNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();


  glMultiDrawElementsIndirectBindlessCountNV((GLenum)arg0,(GLenum)arg1,(const void*)arg2,(GLintptr)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6);

}

      
NAN_METHOD(getImageHandleNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  GLuint64 retval = glGetImageHandleNV(arg0,arg1,arg2,arg3,arg4);

  info.GetReturnValue().Set((int32_t)retval);
      
}

      
NAN_METHOD(getTextureHandleNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLuint64 retval = glGetTextureHandleNV(arg0);

  info.GetReturnValue().Set((int32_t)retval);
      
}

      
NAN_METHOD(getTextureSamplerHandleNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLuint64 retval = glGetTextureSamplerHandleNV(arg0,arg1);

  info.GetReturnValue().Set((int32_t)retval);
      
}

      
NAN_METHOD(isImageHandleResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsImageHandleResidentNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isTextureHandleResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsTextureHandleResidentNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(makeImageHandleNonResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glMakeImageHandleNonResidentNV((GLuint64)arg0);

}

      
NAN_METHOD(makeImageHandleResidentNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMakeImageHandleResidentNV((GLuint64)arg0,(GLenum)arg1);

}

      
NAN_METHOD(makeTextureHandleNonResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glMakeTextureHandleNonResidentNV((GLuint64)arg0);

}

      
NAN_METHOD(makeTextureHandleResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glMakeTextureHandleResidentNV((GLuint64)arg0);

}

      
NAN_METHOD(programUniformHandleui64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64");
    return;
  }
  
  GLuint64 arg2 = (GLuint64)info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniformHandleui64NV((GLuint)arg0,(GLint)arg1,(GLuint64)arg2);

}

      
NAN_METHOD(programUniformHandleui64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glProgramUniformHandleui64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64*)arg3);

}

      
NAN_METHOD(uniformHandleui64NV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64");
    return;
  }
  
  GLuint64 arg1 = (GLuint64)info[1]->Uint32Value(ctx).ToChecked();


  glUniformHandleui64NV((GLint)arg0,(GLuint64)arg1);

}

      
NAN_METHOD(uniformHandleui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64*>(*arg2_tarray);
  }


  glUniformHandleui64vNV((GLint)arg0,(GLsizei)arg1,(const GLuint64*)arg2);

}

      
NAN_METHOD(blendBarrierNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glBlendBarrierNV();

}

      
NAN_METHOD(blendParameteriNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBlendParameteriNV((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(viewportPositionWScaleNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glViewportPositionWScaleNV((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(callCommandListNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glCallCommandListNV((GLuint)arg0);

}

      
NAN_METHOD(commandListSegmentsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glCommandListSegmentsNV((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(compileCommandListNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glCompileCommandListNV((GLuint)arg0);

}

      
NAN_METHOD(createCommandListsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateCommandListsNV((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(createStatesNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glCreateStatesNV((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(deleteCommandListsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteCommandListsNV((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(deleteStatesNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteStatesNV((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(drawCommandsAddressNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint64* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint64*>(*arg1_tarray);
  }
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawCommandsAddressNV((GLenum)arg0,(const GLuint64*)arg1,(const GLsizei*)arg2,(GLuint)arg3);

}

      
NAN_METHOD(drawCommandsNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLintptr* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<intptr> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLintptr*>(*arg2_tarray);
  }
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawCommandsNV((GLenum)arg0,(GLuint)arg1,(const GLintptr*)arg2,(const GLsizei*)arg3,(GLuint)arg4);

}

      
NAN_METHOD(drawCommandsStatesAddressNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint64* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint64*>(*arg0_tarray);
  }
  GLsizei* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLsizei*>(*arg1_tarray);
  }
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawCommandsStatesAddressNV((const GLuint64*)arg0,(const GLsizei*)arg1,(const GLuint*)arg2,(const GLuint*)arg3,(GLuint)arg4);

}

      
NAN_METHOD(drawCommandsStatesNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLintptr* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<intptr> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLintptr*>(*arg1_tarray);
  }
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glDrawCommandsStatesNV((GLuint)arg0,(const GLintptr*)arg1,(const GLsizei*)arg2,(const GLuint*)arg3,(const GLuint*)arg4,(GLuint)arg5);

}

      
NAN_METHOD(getCommandHeaderNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLuint retval = glGetCommandHeaderNV(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getStageIndexNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLushort retval = glGetStageIndexNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isCommandListNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsCommandListNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isStateNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsStateNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(listDrawCommandsStatesClientNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }
  GLuint* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLuint*>(*arg5_tarray);
  }
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glListDrawCommandsStatesClientNV((GLuint)arg0,(GLuint)arg1,(const void**)arg2,(const GLsizei*)arg3,(const GLuint*)arg4,(const GLuint*)arg5,(GLuint)arg6);

}

      
NAN_METHOD(stateCaptureNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glStateCaptureNV((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(beginConditionalRenderNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glBeginConditionalRenderNV((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(endConditionalRenderNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndConditionalRenderNV();

}

      
NAN_METHOD(subpixelPrecisionBiasNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glSubpixelPrecisionBiasNV((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(conservativeRasterParameterfNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glConservativeRasterParameterfNV((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(conservativeRasterParameteriNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glConservativeRasterParameteriNV((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(copyBufferSubDataNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glCopyBufferSubDataNV((GLenum)arg0,(GLenum)arg1,(GLintptr)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(copyImageSubDataNV) {
  if (info.Length() != 15) {
    Nan::ThrowError("Expected 15 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glint");
    return;
  }
  
  GLint arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glint");
    return;
  }
  
  GLint arg10 = info[10]->Int32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glint");
    return;
  }
  
  GLint arg11 = info[11]->Int32Value(ctx).ToChecked();
  if (!info[12]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 13, expected a glsizei");
    return;
  }
  
  GLsizei arg12 = info[12]->Uint32Value(ctx).ToChecked();
  if (!info[13]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 14, expected a glsizei");
    return;
  }
  
  GLsizei arg13 = info[13]->Uint32Value(ctx).ToChecked();
  if (!info[14]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 15, expected a glsizei");
    return;
  }
  
  GLsizei arg14 = info[14]->Uint32Value(ctx).ToChecked();


  glCopyImageSubDataNV((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLuint)arg6,(GLenum)arg7,(GLint)arg8,(GLint)arg9,(GLint)arg10,(GLint)arg11,(GLsizei)arg12,(GLsizei)arg13,(GLsizei)arg14);

}

      
NAN_METHOD(clearDepthdNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();


  glClearDepthdNV((GLdouble)arg0);

}

      
NAN_METHOD(depthBoundsdNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glDepthBoundsdNV((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(depthRangedNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gldouble");
    return;
  }
  
  GLdouble arg0 = (GLdouble)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glDepthRangedNV((GLdouble)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(drawBuffersNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLenum* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLenum*>(*arg1_tarray);
  }


  glDrawBuffersNV((GLsizei)arg0,(const GLenum*)arg1);

}

      
NAN_METHOD(drawArraysInstancedNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glDrawArraysInstancedNV((GLenum)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(drawElementsInstancedNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glDrawElementsInstancedNV((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(drawTextureNV) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glfloat");
    return;
  }
  
  GLfloat arg7 = (GLfloat)info[7]->NumberValue(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glfloat");
    return;
  }
  
  GLfloat arg8 = (GLfloat)info[8]->NumberValue(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glfloat");
    return;
  }
  
  GLfloat arg9 = (GLfloat)info[9]->NumberValue(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glfloat");
    return;
  }
  
  GLfloat arg10 = (GLfloat)info[10]->NumberValue(ctx).ToChecked();


  glDrawTextureNV((GLuint)arg0,(GLuint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5,(GLfloat)arg6,(GLfloat)arg7,(GLfloat)arg8,(GLfloat)arg9,(GLfloat)arg10);

}

      
NAN_METHOD(drawVkImageNV) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glfloat");
    return;
  }
  
  GLfloat arg7 = (GLfloat)info[7]->NumberValue(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glfloat");
    return;
  }
  
  GLfloat arg8 = (GLfloat)info[8]->NumberValue(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glfloat");
    return;
  }
  
  GLfloat arg9 = (GLfloat)info[9]->NumberValue(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glfloat");
    return;
  }
  
  GLfloat arg10 = (GLfloat)info[10]->NumberValue(ctx).ToChecked();


  glDrawVkImageNV((GLuint64)arg0,(GLuint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5,(GLfloat)arg6,(GLfloat)arg7,(GLfloat)arg8,(GLfloat)arg9,(GLfloat)arg10);

}

      
NAN_METHOD(signalVkFenceNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glSignalVkFenceNV((GLuint64)arg0);

}

      
NAN_METHOD(signalVkSemaphoreNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glSignalVkSemaphoreNV((GLuint64)arg0);

}

      
NAN_METHOD(waitVkSemaphoreNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint64");
    return;
  }
  
  GLuint64 arg0 = (GLuint64)info[0]->Uint32Value(ctx).ToChecked();


  glWaitVkSemaphoreNV((GLuint64)arg0);

}

      
NAN_METHOD(evalMapsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glEvalMapsNV((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(getMapAttribParameterfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetMapAttribParameterfvNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getMapAttribParameterivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetMapAttribParameterivNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getMapControlPointsNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glboolean");
    return;
  }
  
  GLboolean arg5 = info[5]->Uint32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }


  glGetMapControlPointsNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLboolean)arg5,(void*)arg6);

}

      
NAN_METHOD(getMapParameterfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetMapParameterfvNV((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getMapParameterivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetMapParameterivNV((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(mapControlPointsNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glboolean");
    return;
  }
  
  GLboolean arg7 = info[7]->Uint32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glMapControlPointsNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLint)arg5,(GLint)arg6,(GLboolean)arg7,(const void*)arg8);

}

      
NAN_METHOD(mapParameterfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glMapParameterfvNV((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(mapParameterivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glMapParameterivNV((GLenum)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(getMultisamplefvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetMultisamplefvNV((GLenum)arg0,(GLuint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(sampleMaskIndexedNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();


  glSampleMaskIndexedNV((GLuint)arg0,(GLbitfield)arg1);

}

      
NAN_METHOD(texRenderbufferNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glTexRenderbufferNV((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteFencesNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteFencesNV((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(finishFenceNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glFinishFenceNV((GLuint)arg0);

}

      
NAN_METHOD(genFencesNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenFencesNV((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getFenceivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetFenceivNV((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isFenceNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsFenceNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(setFenceNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glSetFenceNV((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(testFenceNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glTestFenceNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(fragmentCoverageColorNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glFragmentCoverageColorNV((GLuint)arg0);

}

      
NAN_METHOD(getProgramNamedParameterdvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glGetProgramNamedParameterdvNV((GLuint)arg0,(GLsizei)arg1,(const GLubyte*)arg2,(GLdouble*)arg3);

}

      
NAN_METHOD(getProgramNamedParameterfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetProgramNamedParameterfvNV((GLuint)arg0,(GLsizei)arg1,(const GLubyte*)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(programNamedParameter4dNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gldouble");
    return;
  }
  
  GLdouble arg6 = (GLdouble)info[6]->NumberValue(ctx).ToChecked();


  glProgramNamedParameter4dNV((GLuint)arg0,(GLsizei)arg1,(const GLubyte*)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5,(GLdouble)arg6);

}

      
NAN_METHOD(programNamedParameter4fNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();


  glProgramNamedParameter4fNV((GLuint)arg0,(GLsizei)arg1,(const GLubyte*)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5,(GLfloat)arg6);

}

      
NAN_METHOD(blitFramebufferNV) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glbitfield");
    return;
  }
  
  GLbitfield arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();


  glBlitFramebufferNV((GLint)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLbitfield)arg8,(GLenum)arg9);

}

      
NAN_METHOD(renderbufferStorageMultisampleNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorageMultisampleNV((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(renderbufferStorageMultisampleCoverageNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glRenderbufferStorageMultisampleCoverageNV((GLenum)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(programVertexLimitNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glProgramVertexLimitNV((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(multicastBarrierNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glMulticastBarrierNV();

}

      
NAN_METHOD(multicastBlitFramebufferNV) {
  if (info.Length() != 12) {
    Nan::ThrowError("Expected 12 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glint");
    return;
  }
  
  GLint arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glint");
    return;
  }
  
  GLint arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glbitfield");
    return;
  }
  
  GLbitfield arg10 = info[10]->Int32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glenum");
    return;
  }
  
  GLenum arg11 = info[11]->Int32Value(ctx).ToChecked();


  glMulticastBlitFramebufferNV((GLuint)arg0,(GLuint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLint)arg8,(GLint)arg9,(GLbitfield)arg10,(GLenum)arg11);

}

      
NAN_METHOD(multicastBufferSubDataNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glintptr");
    return;
  }
  
  GLintptr arg2 = (GLintptr)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg3 = (GLsizeiptr)info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glMulticastBufferSubDataNV((GLbitfield)arg0,(GLuint)arg1,(GLintptr)arg2,(GLsizeiptr)arg3,(const void*)arg4);

}

      
NAN_METHOD(multicastCopyBufferSubDataNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glintptr");
    return;
  }
  
  GLintptr arg4 = (GLintptr)info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glintptr");
    return;
  }
  
  GLintptr arg5 = (GLintptr)info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg6 = (GLsizeiptr)info[6]->Uint32Value(ctx).ToChecked();


  glMulticastCopyBufferSubDataNV((GLuint)arg0,(GLbitfield)arg1,(GLuint)arg2,(GLuint)arg3,(GLintptr)arg4,(GLintptr)arg5,(GLsizeiptr)arg6);

}

      
NAN_METHOD(multicastCopyImageSubDataNV) {
  if (info.Length() != 17) {
    Nan::ThrowError("Expected 17 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glint");
    return;
  }
  
  GLint arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a glint");
    return;
  }
  
  GLint arg10 = info[10]->Int32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glint");
    return;
  }
  
  GLint arg11 = info[11]->Int32Value(ctx).ToChecked();
  if (!info[12]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 13, expected a glint");
    return;
  }
  
  GLint arg12 = info[12]->Int32Value(ctx).ToChecked();
  if (!info[13]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 14, expected a glint");
    return;
  }
  
  GLint arg13 = info[13]->Int32Value(ctx).ToChecked();
  if (!info[14]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 15, expected a glsizei");
    return;
  }
  
  GLsizei arg14 = info[14]->Uint32Value(ctx).ToChecked();
  if (!info[15]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 16, expected a glsizei");
    return;
  }
  
  GLsizei arg15 = info[15]->Uint32Value(ctx).ToChecked();
  if (!info[16]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 17, expected a glsizei");
    return;
  }
  
  GLsizei arg16 = info[16]->Uint32Value(ctx).ToChecked();


  glMulticastCopyImageSubDataNV((GLuint)arg0,(GLbitfield)arg1,(GLuint)arg2,(GLenum)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLint)arg7,(GLuint)arg8,(GLenum)arg9,(GLint)arg10,(GLint)arg11,(GLint)arg12,(GLint)arg13,(GLsizei)arg14,(GLsizei)arg15,(GLsizei)arg16);

}

      
NAN_METHOD(multicastFramebufferSampleLocationsfvNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glMulticastFramebufferSampleLocationsfvNV((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(multicastGetQueryObjecti64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64*>(*arg3_tarray);
  }


  glMulticastGetQueryObjecti64vNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint64*)arg3);

}

      
NAN_METHOD(multicastGetQueryObjectivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glMulticastGetQueryObjectivNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(multicastGetQueryObjectui64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLuint64* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64*>(*arg3_tarray);
  }


  glMulticastGetQueryObjectui64vNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLuint64*)arg3);

}

      
NAN_METHOD(multicastGetQueryObjectuivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glMulticastGetQueryObjectuivNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLuint*)arg3);

}

      
NAN_METHOD(multicastWaitSyncNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMulticastWaitSyncNV((GLuint)arg0,(GLbitfield)arg1);

}

      
NAN_METHOD(renderGpuMaskNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glRenderGpuMaskNV((GLbitfield)arg0);

}

      
NAN_METHOD(programEnvParameterI4iNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glProgramEnvParameterI4iNV((GLenum)arg0,(GLuint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5);

}

      
NAN_METHOD(programEnvParameterI4ivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glProgramEnvParameterI4ivNV((GLenum)arg0,(GLuint)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(programEnvParameterI4uiNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glProgramEnvParameterI4uiNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5);

}

      
NAN_METHOD(programEnvParameterI4uivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glProgramEnvParameterI4uivNV((GLenum)arg0,(GLuint)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(programEnvParametersI4ivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramEnvParametersI4ivNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programEnvParametersI4uivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramEnvParametersI4uivNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(programLocalParameterI4iNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();


  glProgramLocalParameterI4iNV((GLenum)arg0,(GLuint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5);

}

      
NAN_METHOD(programLocalParameterI4ivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glProgramLocalParameterI4ivNV((GLenum)arg0,(GLuint)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(programLocalParameterI4uiNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glProgramLocalParameterI4uiNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint)arg4,(GLuint)arg5);

}

      
NAN_METHOD(programLocalParameterI4uivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glProgramLocalParameterI4uivNV((GLenum)arg0,(GLuint)arg1,(const GLuint*)arg2);

}

      
NAN_METHOD(programLocalParametersI4ivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glProgramLocalParametersI4ivNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(programLocalParametersI4uivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint*>(*arg3_tarray);
  }


  glProgramLocalParametersI4uivNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLuint*)arg3);

}

      
NAN_METHOD(getUniformi64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glGetUniformi64vNV((GLuint)arg0,(GLint)arg1,(GLint64EXT*)arg2);

}

      
NAN_METHOD(getUniformui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glGetUniformui64vNV((GLuint)arg0,(GLint)arg1,(GLuint64EXT*)arg2);

}

      
NAN_METHOD(programUniform1i64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniform1i64NV((GLuint)arg0,(GLint)arg1,(GLint64EXT)arg2);

}

      
NAN_METHOD(programUniform1i64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64EXT*>(*arg3_tarray);
  }


  glProgramUniform1i64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64EXT*)arg3);

}

      
NAN_METHOD(programUniform1ui64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniform1ui64NV((GLuint)arg0,(GLint)arg1,(GLuint64EXT)arg2);

}

      
NAN_METHOD(programUniform1ui64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64EXT*>(*arg3_tarray);
  }


  glProgramUniform1ui64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64EXT*)arg3);

}

      
NAN_METHOD(programUniform2i64NV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg3 = (GLint64EXT)info[3]->Uint32Value(ctx).ToChecked();


  glProgramUniform2i64NV((GLuint)arg0,(GLint)arg1,(GLint64EXT)arg2,(GLint64EXT)arg3);

}

      
NAN_METHOD(programUniform2i64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64EXT*>(*arg3_tarray);
  }


  glProgramUniform2i64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64EXT*)arg3);

}

      
NAN_METHOD(programUniform2ui64NV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg3 = (GLuint64EXT)info[3]->Uint32Value(ctx).ToChecked();


  glProgramUniform2ui64NV((GLuint)arg0,(GLint)arg1,(GLuint64EXT)arg2,(GLuint64EXT)arg3);

}

      
NAN_METHOD(programUniform2ui64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64EXT*>(*arg3_tarray);
  }


  glProgramUniform2ui64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64EXT*)arg3);

}

      
NAN_METHOD(programUniform3i64NV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg3 = (GLint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg4 = (GLint64EXT)info[4]->Uint32Value(ctx).ToChecked();


  glProgramUniform3i64NV((GLuint)arg0,(GLint)arg1,(GLint64EXT)arg2,(GLint64EXT)arg3,(GLint64EXT)arg4);

}

      
NAN_METHOD(programUniform3i64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64EXT*>(*arg3_tarray);
  }


  glProgramUniform3i64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64EXT*)arg3);

}

      
NAN_METHOD(programUniform3ui64NV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg3 = (GLuint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg4 = (GLuint64EXT)info[4]->Uint32Value(ctx).ToChecked();


  glProgramUniform3ui64NV((GLuint)arg0,(GLint)arg1,(GLuint64EXT)arg2,(GLuint64EXT)arg3,(GLuint64EXT)arg4);

}

      
NAN_METHOD(programUniform3ui64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64EXT*>(*arg3_tarray);
  }


  glProgramUniform3ui64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64EXT*)arg3);

}

      
NAN_METHOD(programUniform4i64NV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg3 = (GLint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg4 = (GLint64EXT)info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg5 = (GLint64EXT)info[5]->Uint32Value(ctx).ToChecked();


  glProgramUniform4i64NV((GLuint)arg0,(GLint)arg1,(GLint64EXT)arg2,(GLint64EXT)arg3,(GLint64EXT)arg4,(GLint64EXT)arg5);

}

      
NAN_METHOD(programUniform4i64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint64EXT*>(*arg3_tarray);
  }


  glProgramUniform4i64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLint64EXT*)arg3);

}

      
NAN_METHOD(programUniform4ui64NV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg3 = (GLuint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg4 = (GLuint64EXT)info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg5 = (GLuint64EXT)info[5]->Uint32Value(ctx).ToChecked();


  glProgramUniform4ui64NV((GLuint)arg0,(GLint)arg1,(GLuint64EXT)arg2,(GLuint64EXT)arg3,(GLuint64EXT)arg4,(GLuint64EXT)arg5);

}

      
NAN_METHOD(programUniform4ui64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64EXT*>(*arg3_tarray);
  }


  glProgramUniform4ui64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64EXT*)arg3);

}

      
NAN_METHOD(uniform1i64NV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();


  glUniform1i64NV((GLint)arg0,(GLint64EXT)arg1);

}

      
NAN_METHOD(uniform1i64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glUniform1i64vNV((GLint)arg0,(GLsizei)arg1,(const GLint64EXT*)arg2);

}

      
NAN_METHOD(uniform1ui64NV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();


  glUniform1ui64NV((GLint)arg0,(GLuint64EXT)arg1);

}

      
NAN_METHOD(uniform1ui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glUniform1ui64vNV((GLint)arg0,(GLsizei)arg1,(const GLuint64EXT*)arg2);

}

      
NAN_METHOD(uniform2i64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();


  glUniform2i64NV((GLint)arg0,(GLint64EXT)arg1,(GLint64EXT)arg2);

}

      
NAN_METHOD(uniform2i64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glUniform2i64vNV((GLint)arg0,(GLsizei)arg1,(const GLint64EXT*)arg2);

}

      
NAN_METHOD(uniform2ui64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();


  glUniform2ui64NV((GLint)arg0,(GLuint64EXT)arg1,(GLuint64EXT)arg2);

}

      
NAN_METHOD(uniform2ui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glUniform2ui64vNV((GLint)arg0,(GLsizei)arg1,(const GLuint64EXT*)arg2);

}

      
NAN_METHOD(uniform3i64NV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg3 = (GLint64EXT)info[3]->Uint32Value(ctx).ToChecked();


  glUniform3i64NV((GLint)arg0,(GLint64EXT)arg1,(GLint64EXT)arg2,(GLint64EXT)arg3);

}

      
NAN_METHOD(uniform3i64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glUniform3i64vNV((GLint)arg0,(GLsizei)arg1,(const GLint64EXT*)arg2);

}

      
NAN_METHOD(uniform3ui64NV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg3 = (GLuint64EXT)info[3]->Uint32Value(ctx).ToChecked();


  glUniform3ui64NV((GLint)arg0,(GLuint64EXT)arg1,(GLuint64EXT)arg2,(GLuint64EXT)arg3);

}

      
NAN_METHOD(uniform3ui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glUniform3ui64vNV((GLint)arg0,(GLsizei)arg1,(const GLuint64EXT*)arg2);

}

      
NAN_METHOD(uniform4i64NV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg3 = (GLint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg4 = (GLint64EXT)info[4]->Uint32Value(ctx).ToChecked();


  glUniform4i64NV((GLint)arg0,(GLint64EXT)arg1,(GLint64EXT)arg2,(GLint64EXT)arg3,(GLint64EXT)arg4);

}

      
NAN_METHOD(uniform4i64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glUniform4i64vNV((GLint)arg0,(GLsizei)arg1,(const GLint64EXT*)arg2);

}

      
NAN_METHOD(uniform4ui64NV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg3 = (GLuint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg4 = (GLuint64EXT)info[4]->Uint32Value(ctx).ToChecked();


  glUniform4ui64NV((GLint)arg0,(GLuint64EXT)arg1,(GLuint64EXT)arg2,(GLuint64EXT)arg3,(GLuint64EXT)arg4);

}

      
NAN_METHOD(uniform4ui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glUniform4ui64vNV((GLint)arg0,(GLsizei)arg1,(const GLuint64EXT*)arg2);

}

      
NAN_METHOD(vertexAttribDivisorNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribDivisorNV((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(getInternalformatSampleivNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  GLint* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLint*>(*arg5_tarray);
  }


  glGetInternalformatSampleivNV((GLenum)arg0,(GLenum)arg1,(GLsizei)arg2,(GLenum)arg3,(GLsizei)arg4,(GLint*)arg5);

}

      
NAN_METHOD(uniformMatrix2x3fvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix2x3fvNV((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix2x4fvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix2x4fvNV((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix3x2fvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix3x2fvNV((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix3x4fvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix3x4fvNV((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix4x2fvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix4x2fvNV((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(uniformMatrix4x3fvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glboolean");
    return;
  }
  
  GLboolean arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glUniformMatrix4x3fvNV((GLint)arg0,(GLsizei)arg1,(GLboolean)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(beginOcclusionQueryNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBeginOcclusionQueryNV((GLuint)arg0);

}

      
NAN_METHOD(deleteOcclusionQueriesNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteOcclusionQueriesNV((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(endOcclusionQueryNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndOcclusionQueryNV();

}

      
NAN_METHOD(genOcclusionQueriesNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenOcclusionQueriesNV((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getOcclusionQueryivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetOcclusionQueryivNV((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getOcclusionQueryuivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetOcclusionQueryuivNV((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(isOcclusionQueryNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsOcclusionQueryNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(programBufferParametersIivNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glProgramBufferParametersIivNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLint*)arg4);

}

      
NAN_METHOD(programBufferParametersIuivNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glProgramBufferParametersIuivNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLuint*)arg4);

}

      
NAN_METHOD(programBufferParametersfvNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramBufferParametersfvNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(copyPathNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glCopyPathNV((GLuint)arg0,(GLuint)arg1);

}

      
NAN_METHOD(coverFillPathInstancedNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  GLfloat* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLfloat*>(*arg6_tarray);
  }


  glCoverFillPathInstancedNV((GLsizei)arg0,(GLenum)arg1,(const void*)arg2,(GLuint)arg3,(GLenum)arg4,(GLenum)arg5,(const GLfloat*)arg6);

}

      
NAN_METHOD(coverFillPathNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glCoverFillPathNV((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(coverStrokePathInstancedNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  GLfloat* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLfloat*>(*arg6_tarray);
  }


  glCoverStrokePathInstancedNV((GLsizei)arg0,(GLenum)arg1,(const void*)arg2,(GLuint)arg3,(GLenum)arg4,(GLenum)arg5,(const GLfloat*)arg6);

}

      
NAN_METHOD(coverStrokePathNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glCoverStrokePathNV((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(deletePathsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDeletePathsNV((GLuint)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(genPathsNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLuint retval = glGenPathsNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getPathColorGenfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetPathColorGenfvNV((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getPathColorGenivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetPathColorGenivNV((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getPathCommandsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glGetPathCommandsNV((GLuint)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(getPathCoordsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glGetPathCoordsNV((GLuint)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(getPathDashArrayNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glGetPathDashArrayNV((GLuint)arg0,(GLfloat*)arg1);

}

      
NAN_METHOD(getPathLengthNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  GLfloat retval = glGetPathLengthNV(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getPathMetricRangeNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glGetPathMetricRangeNV((GLbitfield)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLfloat*)arg4);

}

      
NAN_METHOD(getPathMetricsNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  GLfloat* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLfloat*>(*arg6_tarray);
  }


  glGetPathMetricsNV((GLbitfield)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLuint)arg4,(GLsizei)arg5,(GLfloat*)arg6);

}

      
NAN_METHOD(getPathParameterfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetPathParameterfvNV((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getPathParameterivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetPathParameterivNV((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getPathSpacingNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  GLfloat* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<GLfloat*>(*arg8_tarray);
  }


  glGetPathSpacingNV((GLenum)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3,(GLuint)arg4,(GLfloat)arg5,(GLfloat)arg6,(GLenum)arg7,(GLfloat*)arg8);

}

      
NAN_METHOD(getPathTexGenfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetPathTexGenfvNV((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getPathTexGenivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetPathTexGenivNV((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getProgramResourcefvNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLenum* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLenum*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  GLsizei* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLsizei*>(*arg6_tarray);
  }
  GLfloat* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLfloat*>(*arg7_tarray);
  }


  glGetProgramResourcefvNV((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLsizei)arg3,(const GLenum*)arg4,(GLsizei)arg5,(GLsizei*)arg6,(GLfloat*)arg7);

}

      
NAN_METHOD(interpolatePathsNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glInterpolatePathsNV((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(isPathNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsPathNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isPointInFillPathNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  GLboolean retval = glIsPointInFillPathNV(arg0,arg1,arg2,arg3);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isPointInStrokePathNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  GLboolean retval = glIsPointInStrokePathNV(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(matrixLoad3x2fNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMatrixLoad3x2fNV((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(matrixLoad3x3fNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMatrixLoad3x3fNV((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(matrixLoadTranspose3x3fNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMatrixLoadTranspose3x3fNV((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(matrixMult3x2fNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMatrixMult3x2fNV((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(matrixMult3x3fNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMatrixMult3x3fNV((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(matrixMultTranspose3x3fNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glMatrixMultTranspose3x3fNV((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(pathColorGenNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glPathColorGenNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(pathCommandsNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  void* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<void*>(*arg5_tarray);
  }


  glPathCommandsNV((GLuint)arg0,(GLsizei)arg1,(const GLubyte*)arg2,(GLsizei)arg3,(GLenum)arg4,(const void*)arg5);

}

      
NAN_METHOD(pathCoordsNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glPathCoordsNV((GLuint)arg0,(GLsizei)arg1,(GLenum)arg2,(const void*)arg3);

}

      
NAN_METHOD(pathCoverDepthFuncNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glPathCoverDepthFuncNV((GLenum)arg0);

}

      
NAN_METHOD(pathDashArrayNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glPathDashArrayNV((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(pathFogGenNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glPathFogGenNV((GLenum)arg0);

}

      
NAN_METHOD(pathGlyphIndexArrayNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbitfield");
    return;
  }
  
  GLbitfield arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glfloat");
    return;
  }
  
  GLfloat arg7 = (GLfloat)info[7]->NumberValue(ctx).ToChecked();


  GLenum retval = glPathGlyphIndexArrayNV(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(pathGlyphRangeNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbitfield");
    return;
  }
  
  GLbitfield arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glfloat");
    return;
  }
  
  GLfloat arg8 = (GLfloat)info[8]->NumberValue(ctx).ToChecked();


  glPathGlyphRangeNV((GLuint)arg0,(GLenum)arg1,(const void*)arg2,(GLbitfield)arg3,(GLuint)arg4,(GLsizei)arg5,(GLenum)arg6,(GLuint)arg7,(GLfloat)arg8);

}

      
NAN_METHOD(pathGlyphsNV) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glbitfield");
    return;
  }
  
  GLbitfield arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  void* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<void*>(*arg6_tarray);
  }
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glfloat");
    return;
  }
  
  GLfloat arg9 = (GLfloat)info[9]->NumberValue(ctx).ToChecked();


  glPathGlyphsNV((GLuint)arg0,(GLenum)arg1,(const void*)arg2,(GLbitfield)arg3,(GLsizei)arg4,(GLenum)arg5,(const void*)arg6,(GLenum)arg7,(GLuint)arg8,(GLfloat)arg9);

}

      
NAN_METHOD(pathMemoryGlyphIndexArrayNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg2 = (GLsizeiptr)info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glfloat");
    return;
  }
  
  GLfloat arg8 = (GLfloat)info[8]->NumberValue(ctx).ToChecked();


  GLenum retval = glPathMemoryGlyphIndexArrayNV(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(pathParameterfNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glPathParameterfNV((GLuint)arg0,(GLenum)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(pathParameterfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glPathParameterfvNV((GLuint)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(pathParameteriNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glPathParameteriNV((GLuint)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(pathParameterivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glPathParameterivNV((GLuint)arg0,(GLenum)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(pathStencilDepthOffsetNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glPathStencilDepthOffsetNV((GLfloat)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(pathStencilFuncNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glPathStencilFuncNV((GLenum)arg0,(GLint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(pathStringNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  void* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<void*>(*arg3_tarray);
  }


  glPathStringNV((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(const void*)arg3);

}

      
NAN_METHOD(pathSubCommandsNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLubyte* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLubyte*>(*arg4_tarray);
  }
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  void* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<void*>(*arg7_tarray);
  }


  glPathSubCommandsNV((GLuint)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLsizei)arg3,(const GLubyte*)arg4,(GLsizei)arg5,(GLenum)arg6,(const void*)arg7);

}

      
NAN_METHOD(pathSubCoordsNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glPathSubCoordsNV((GLuint)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLenum)arg3,(const void*)arg4);

}

      
NAN_METHOD(pathTexGenNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glPathTexGenNV((GLenum)arg0,(GLenum)arg1,(GLint)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(pointAlongPathNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }
  GLfloat* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLfloat*>(*arg5_tarray);
  }
  GLfloat* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLfloat*>(*arg6_tarray);
  }
  GLfloat* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLfloat*>(*arg7_tarray);
  }


  GLboolean retval = glPointAlongPathNV(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(programPathFragmentInputGenNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glProgramPathFragmentInputGenNV((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLint)arg3,(const GLfloat*)arg4);

}

      
NAN_METHOD(stencilFillPathInstancedNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  GLfloat* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLfloat*>(*arg7_tarray);
  }


  glStencilFillPathInstancedNV((GLsizei)arg0,(GLenum)arg1,(const void*)arg2,(GLuint)arg3,(GLenum)arg4,(GLuint)arg5,(GLenum)arg6,(const GLfloat*)arg7);

}

      
NAN_METHOD(stencilFillPathNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glStencilFillPathNV((GLuint)arg0,(GLenum)arg1,(GLuint)arg2);

}

      
NAN_METHOD(stencilStrokePathInstancedNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  GLfloat* arg7;

  if (info[7]->IsNullOrUndefined()) {
    arg7 = nullptr;
  } else {
    if (!info[7]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 8, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg7_tarray(info[7]);
    arg7 = reinterpret_cast<GLfloat*>(*arg7_tarray);
  }


  glStencilStrokePathInstancedNV((GLsizei)arg0,(GLenum)arg1,(const void*)arg2,(GLuint)arg3,(GLint)arg4,(GLuint)arg5,(GLenum)arg6,(const GLfloat*)arg7);

}

      
NAN_METHOD(stencilStrokePathNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glStencilStrokePathNV((GLuint)arg0,(GLint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(stencilThenCoverFillPathInstancedNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  GLfloat* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<GLfloat*>(*arg8_tarray);
  }


  glStencilThenCoverFillPathInstancedNV((GLsizei)arg0,(GLenum)arg1,(const void*)arg2,(GLuint)arg3,(GLenum)arg4,(GLuint)arg5,(GLenum)arg6,(GLenum)arg7,(const GLfloat*)arg8);

}

      
NAN_METHOD(stencilThenCoverFillPathNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glStencilThenCoverFillPathNV((GLuint)arg0,(GLenum)arg1,(GLuint)arg2,(GLenum)arg3);

}

      
NAN_METHOD(stencilThenCoverStrokePathInstancedNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gluint");
    return;
  }
  
  GLuint arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  GLfloat* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<GLfloat*>(*arg8_tarray);
  }


  glStencilThenCoverStrokePathInstancedNV((GLsizei)arg0,(GLenum)arg1,(const void*)arg2,(GLuint)arg3,(GLint)arg4,(GLuint)arg5,(GLenum)arg6,(GLenum)arg7,(const GLfloat*)arg8);

}

      
NAN_METHOD(stencilThenCoverStrokePathNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glStencilThenCoverStrokePathNV((GLuint)arg0,(GLint)arg1,(GLuint)arg2,(GLenum)arg3);

}

      
NAN_METHOD(transformPathNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glTransformPathNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(flushPixelDataRangeNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glFlushPixelDataRangeNV((GLenum)arg0);

}

      
NAN_METHOD(pixelDataRangeNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glPixelDataRangeNV((GLenum)arg0,(GLsizei)arg1,(void*)arg2);

}

      
NAN_METHOD(pointParameteriNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPointParameteriNV((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(pointParameterivNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glPointParameterivNV((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(polygonModeNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glPolygonModeNV((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(getVideoi64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glGetVideoi64vNV((GLuint)arg0,(GLenum)arg1,(GLint64EXT*)arg2);

}

      
NAN_METHOD(getVideoivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVideoivNV((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVideoui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glGetVideoui64vNV((GLuint)arg0,(GLenum)arg1,(GLuint64EXT*)arg2);

}

      
NAN_METHOD(getVideouivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetVideouivNV((GLuint)arg0,(GLenum)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(presentFrameDualFillNV) {
  if (info.Length() != 13) {
    Nan::ThrowError("Expected 13 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a gluint");
    return;
  }
  
  GLuint arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a gluint");
    return;
  }
  
  GLuint arg10 = info[10]->Uint32Value(ctx).ToChecked();
  if (!info[11]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 12, expected a glenum");
    return;
  }
  
  GLenum arg11 = info[11]->Int32Value(ctx).ToChecked();
  if (!info[12]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 13, expected a gluint");
    return;
  }
  
  GLuint arg12 = info[12]->Uint32Value(ctx).ToChecked();


  glPresentFrameDualFillNV((GLuint)arg0,(GLuint64EXT)arg1,(GLuint)arg2,(GLuint)arg3,(GLenum)arg4,(GLenum)arg5,(GLuint)arg6,(GLenum)arg7,(GLuint)arg8,(GLenum)arg9,(GLuint)arg10,(GLenum)arg11,(GLuint)arg12);

}

      
NAN_METHOD(presentFrameKeyedNV) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a gluint");
    return;
  }
  
  GLuint arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a gluint");
    return;
  }
  
  GLuint arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a gluint");
    return;
  }
  
  GLuint arg9 = info[9]->Uint32Value(ctx).ToChecked();
  if (!info[10]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 11, expected a gluint");
    return;
  }
  
  GLuint arg10 = info[10]->Uint32Value(ctx).ToChecked();


  glPresentFrameKeyedNV((GLuint)arg0,(GLuint64EXT)arg1,(GLuint)arg2,(GLuint)arg3,(GLenum)arg4,(GLenum)arg5,(GLuint)arg6,(GLuint)arg7,(GLenum)arg8,(GLuint)arg9,(GLuint)arg10);

}

      
NAN_METHOD(primitiveRestartIndexNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glPrimitiveRestartIndexNV((GLuint)arg0);

}

      
NAN_METHOD(primitiveRestartNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPrimitiveRestartNV();

}

      
NAN_METHOD(combinerInputNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();


  glCombinerInputNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4,(GLenum)arg5);

}

      
NAN_METHOD(combinerOutputNV) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glenum");
    return;
  }
  
  GLenum arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glenum");
    return;
  }
  
  GLenum arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glboolean");
    return;
  }
  
  GLboolean arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glboolean");
    return;
  }
  
  GLboolean arg8 = info[8]->Uint32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glboolean");
    return;
  }
  
  GLboolean arg9 = info[9]->Uint32Value(ctx).ToChecked();


  glCombinerOutputNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4,(GLenum)arg5,(GLenum)arg6,(GLboolean)arg7,(GLboolean)arg8,(GLboolean)arg9);

}

      
NAN_METHOD(combinerParameterfNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glCombinerParameterfNV((GLenum)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(combinerParameterfvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glCombinerParameterfvNV((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(combinerParameteriNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();


  glCombinerParameteriNV((GLenum)arg0,(GLint)arg1);

}

      
NAN_METHOD(combinerParameterivNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glCombinerParameterivNV((GLenum)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(finalCombinerInputNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glFinalCombinerInputNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3);

}

      
NAN_METHOD(getCombinerInputParameterfvNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLfloat* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLfloat*>(*arg4_tarray);
  }


  glGetCombinerInputParameterfvNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLfloat*)arg4);

}

      
NAN_METHOD(getCombinerInputParameterivNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glGetCombinerInputParameterivNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLint*)arg4);

}

      
NAN_METHOD(getCombinerOutputParameterfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetCombinerOutputParameterfvNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getCombinerOutputParameterivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetCombinerOutputParameterivNV((GLenum)arg0,(GLenum)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getFinalCombinerInputParameterfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetFinalCombinerInputParameterfvNV((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getFinalCombinerInputParameterivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetFinalCombinerInputParameterivNV((GLenum)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(combinerStageParameterfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glCombinerStageParameterfvNV((GLenum)arg0,(GLenum)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(getCombinerStageParameterfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetCombinerStageParameterfvNV((GLenum)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(framebufferSampleLocationsfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glFramebufferSampleLocationsfvNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(namedFramebufferSampleLocationsfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glNamedFramebufferSampleLocationsfvNV((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(getBufferParameterui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glGetBufferParameterui64vNV((GLenum)arg0,(GLenum)arg1,(GLuint64EXT*)arg2);

}

      
NAN_METHOD(getIntegerui64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint64EXT*>(*arg1_tarray);
  }


  glGetIntegerui64vNV((GLenum)arg0,(GLuint64EXT*)arg1);

}

      
NAN_METHOD(getNamedBufferParameterui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glGetNamedBufferParameterui64vNV((GLuint)arg0,(GLenum)arg1,(GLuint64EXT*)arg2);

}

      
NAN_METHOD(isBufferResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLboolean retval = glIsBufferResidentNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isNamedBufferResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsNamedBufferResidentNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(makeBufferNonResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glMakeBufferNonResidentNV((GLenum)arg0);

}

      
NAN_METHOD(makeBufferResidentNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMakeBufferResidentNV((GLenum)arg0,(GLenum)arg1);

}

      
NAN_METHOD(makeNamedBufferNonResidentNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glMakeNamedBufferNonResidentNV((GLuint)arg0);

}

      
NAN_METHOD(makeNamedBufferResidentNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();


  glMakeNamedBufferResidentNV((GLuint)arg0,(GLenum)arg1);

}

      
NAN_METHOD(programUniformui64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();


  glProgramUniformui64NV((GLuint)arg0,(GLint)arg1,(GLuint64EXT)arg2);

}

      
NAN_METHOD(programUniformui64vNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLuint64EXT*>(*arg3_tarray);
  }


  glProgramUniformui64vNV((GLuint)arg0,(GLint)arg1,(GLsizei)arg2,(const GLuint64EXT*)arg3);

}

      
NAN_METHOD(uniformui64NV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();


  glUniformui64NV((GLint)arg0,(GLuint64EXT)arg1);

}

      
NAN_METHOD(uniformui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glUniformui64vNV((GLint)arg0,(GLsizei)arg1,(const GLuint64EXT*)arg2);

}

      
NAN_METHOD(compressedTexImage3DNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  void* arg8;

  if (info[8]->IsNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    if (!info[8]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 9, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg8_tarray(info[8]);
    arg8 = reinterpret_cast<void*>(*arg8_tarray);
  }


  glCompressedTexImage3DNV((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6,(GLsizei)arg7,(const void*)arg8);

}

      
NAN_METHOD(compressedTexSubImage3DNV) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glsizei");
    return;
  }
  
  GLsizei arg9 = info[9]->Uint32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glCompressedTexSubImage3DNV((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLsizei)arg9,(const void*)arg10);

}

      
NAN_METHOD(copyTexSubImage3DNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glsizei");
    return;
  }
  
  GLsizei arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glCopyTexSubImage3DNV((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLint)arg5,(GLint)arg6,(GLsizei)arg7,(GLsizei)arg8);

}

      
NAN_METHOD(framebufferTextureLayerNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();


  glFramebufferTextureLayerNV((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4);

}

      
NAN_METHOD(texImage3DNV) {
  if (info.Length() != 10) {
    Nan::ThrowError("Expected 10 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glint");
    return;
  }
  
  GLint arg6 = info[6]->Int32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glenum");
    return;
  }
  
  GLenum arg7 = info[7]->Int32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  void* arg9;

  if (info[9]->IsNullOrUndefined()) {
    arg9 = nullptr;
  } else {
    if (!info[9]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 10, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg9_tarray(info[9]);
    arg9 = reinterpret_cast<void*>(*arg9_tarray);
  }


  glTexImage3DNV((GLenum)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLint)arg6,(GLenum)arg7,(GLenum)arg8,(const void*)arg9);

}

      
NAN_METHOD(texSubImage3DNV) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glTexSubImage3DNV((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(const void*)arg10);

}

      
NAN_METHOD(textureBarrierNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glTextureBarrierNV();

}

      
NAN_METHOD(texImage2DMultisampleCoverageNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glTexImage2DMultisampleCoverageNV((GLenum)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6);

}

      
NAN_METHOD(texImage3DMultisampleCoverageNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glboolean");
    return;
  }
  
  GLboolean arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glTexImage3DMultisampleCoverageNV((GLenum)arg0,(GLsizei)arg1,(GLsizei)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLboolean)arg7);

}

      
NAN_METHOD(textureImage2DMultisampleCoverageNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glboolean");
    return;
  }
  
  GLboolean arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glTextureImage2DMultisampleCoverageNV((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLboolean)arg7);

}

      
NAN_METHOD(textureImage2DMultisampleNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glboolean");
    return;
  }
  
  GLboolean arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glTextureImage2DMultisampleNV((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLboolean)arg6);

}

      
NAN_METHOD(textureImage3DMultisampleCoverageNV) {
  if (info.Length() != 9) {
    Nan::ThrowError("Expected 9 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glboolean");
    return;
  }
  
  GLboolean arg8 = info[8]->Uint32Value(ctx).ToChecked();


  glTextureImage3DMultisampleCoverageNV((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLsizei)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLboolean)arg8);

}

      
NAN_METHOD(textureImage3DMultisampleNV) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glboolean");
    return;
  }
  
  GLboolean arg7 = info[7]->Uint32Value(ctx).ToChecked();


  glTextureImage3DMultisampleNV((GLuint)arg0,(GLenum)arg1,(GLsizei)arg2,(GLint)arg3,(GLsizei)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLboolean)arg7);

}

      
NAN_METHOD(activeVaryingNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  glActiveVaryingNV((GLuint)arg0,(const GLchar*)arg1);

}

      
NAN_METHOD(beginTransformFeedbackNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  glBeginTransformFeedbackNV((GLenum)arg0);

}

      
NAN_METHOD(bindBufferBaseNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glBindBufferBaseNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2);

}

      
NAN_METHOD(bindBufferOffsetNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();


  glBindBufferOffsetNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3);

}

      
NAN_METHOD(bindBufferRangeNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptr");
    return;
  }
  
  GLintptr arg3 = (GLintptr)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg4 = (GLsizeiptr)info[4]->Uint32Value(ctx).ToChecked();


  glBindBufferRangeNV((GLenum)arg0,(GLuint)arg1,(GLuint)arg2,(GLintptr)arg3,(GLsizeiptr)arg4);

}

      
NAN_METHOD(endTransformFeedbackNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glEndTransformFeedbackNV();

}

      
NAN_METHOD(getActiveVaryingNV) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLsizei* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLsizei*>(*arg3_tarray);
  }
  GLsizei* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLsizei*>(*arg4_tarray);
  }
  GLenum* arg5;

  if (info[5]->IsNullOrUndefined()) {
    arg5 = nullptr;
  } else {
    if (!info[5]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 6, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg5_tarray(info[5]);
    arg5 = reinterpret_cast<GLenum*>(*arg5_tarray);
  }
  GLchar* arg6;

  if (info[6]->IsNullOrUndefined()) {
    arg6 = nullptr;
  } else {
    if (!info[6]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 7, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg6_tarray(info[6]);
    arg6 = reinterpret_cast<GLchar*>(*arg6_tarray);
  }


  glGetActiveVaryingNV((GLuint)arg0,(GLuint)arg1,(GLsizei)arg2,(GLsizei*)arg3,(GLsizei*)arg4,(GLenum*)arg5,(GLchar*)arg6);

}

      
NAN_METHOD(getTransformFeedbackVaryingNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetTransformFeedbackVaryingNV((GLuint)arg0,(GLuint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getVaryingLocationNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLchar* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLchar*>(*arg1_tarray);
  }


  GLint retval = glGetVaryingLocationNV(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(transformFeedbackAttribsNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();


  glTransformFeedbackAttribsNV((GLuint)arg0,(const GLint*)arg1,(GLenum)arg2);

}

      
NAN_METHOD(transformFeedbackVaryingsNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glTransformFeedbackVaryingsNV((GLuint)arg0,(GLsizei)arg1,(const GLint*)arg2,(GLenum)arg3);

}

      
NAN_METHOD(bindTransformFeedbackNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindTransformFeedbackNV((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteTransformFeedbacksNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteTransformFeedbacksNV((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(drawTransformFeedbackNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDrawTransformFeedbackNV((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(genTransformFeedbacksNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenTransformFeedbacksNV((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(isTransformFeedbackNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsTransformFeedbackNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(pauseTransformFeedbackNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glPauseTransformFeedbackNV();

}

      
NAN_METHOD(resumeTransformFeedbackNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glResumeTransformFeedbackNV();

}

      
NAN_METHOD(vDPAUFiniNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glVDPAUFiniNV();

}

      
NAN_METHOD(vDPAUInitNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  void* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<void*>(*arg0_tarray);
  }
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glVDPAUInitNV((const void*)arg0,(const void*)arg1);

}

      
NAN_METHOD(flushVertexArrayRangeNV) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glFlushVertexArrayRangeNV();

}

      
NAN_METHOD(vertexArrayRangeNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  void* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<void*>(*arg1_tarray);
  }


  glVertexArrayRangeNV((GLsizei)arg0,(void*)arg1);

}

      
NAN_METHOD(getVertexAttribLi64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint64EXT*>(*arg2_tarray);
  }


  glGetVertexAttribLi64vNV((GLuint)arg0,(GLenum)arg1,(GLint64EXT*)arg2);

}

      
NAN_METHOD(getVertexAttribLui64vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  glGetVertexAttribLui64vNV((GLuint)arg0,(GLenum)arg1,(GLuint64EXT*)arg2);

}

      
NAN_METHOD(vertexAttribL1i64NV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribL1i64NV((GLuint)arg0,(GLint64EXT)arg1);

}

      
NAN_METHOD(vertexAttribL1i64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL1i64vNV((GLuint)arg0,(const GLint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribL1ui64NV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();


  glVertexAttribL1ui64NV((GLuint)arg0,(GLuint64EXT)arg1);

}

      
NAN_METHOD(vertexAttribL1ui64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL1ui64vNV((GLuint)arg0,(const GLuint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribL2i64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();


  glVertexAttribL2i64NV((GLuint)arg0,(GLint64EXT)arg1,(GLint64EXT)arg2);

}

      
NAN_METHOD(vertexAttribL2i64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL2i64vNV((GLuint)arg0,(const GLint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribL2ui64NV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();


  glVertexAttribL2ui64NV((GLuint)arg0,(GLuint64EXT)arg1,(GLuint64EXT)arg2);

}

      
NAN_METHOD(vertexAttribL2ui64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL2ui64vNV((GLuint)arg0,(const GLuint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribL3i64NV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg3 = (GLint64EXT)info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribL3i64NV((GLuint)arg0,(GLint64EXT)arg1,(GLint64EXT)arg2,(GLint64EXT)arg3);

}

      
NAN_METHOD(vertexAttribL3i64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL3i64vNV((GLuint)arg0,(const GLint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribL3ui64NV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg3 = (GLuint64EXT)info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribL3ui64NV((GLuint)arg0,(GLuint64EXT)arg1,(GLuint64EXT)arg2,(GLuint64EXT)arg3);

}

      
NAN_METHOD(vertexAttribL3ui64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL3ui64vNV((GLuint)arg0,(const GLuint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribL4i64NV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg1 = (GLint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg2 = (GLint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg3 = (GLint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint64ext");
    return;
  }
  
  GLint64EXT arg4 = (GLint64EXT)info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttribL4i64NV((GLuint)arg0,(GLint64EXT)arg1,(GLint64EXT)arg2,(GLint64EXT)arg3,(GLint64EXT)arg4);

}

      
NAN_METHOD(vertexAttribL4i64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL4i64vNV((GLuint)arg0,(const GLint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribL4ui64NV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg1 = (GLuint64EXT)info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg3 = (GLuint64EXT)info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg4 = (GLuint64EXT)info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttribL4ui64NV((GLuint)arg0,(GLuint64EXT)arg1,(GLuint64EXT)arg2,(GLuint64EXT)arg3,(GLuint64EXT)arg4);

}

      
NAN_METHOD(vertexAttribL4ui64vNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint64EXT* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint64EXT*>(*arg1_tarray);
  }


  glVertexAttribL4ui64vNV((GLuint)arg0,(const GLuint64EXT*)arg1);

}

      
NAN_METHOD(vertexAttribLFormatNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribLFormatNV((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(bufferAddressRangeNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint64ext");
    return;
  }
  
  GLuint64EXT arg2 = (GLuint64EXT)info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizeiptr");
    return;
  }
  
  GLsizeiptr arg3 = (GLsizeiptr)info[3]->Uint32Value(ctx).ToChecked();


  glBufferAddressRangeNV((GLenum)arg0,(GLuint)arg1,(GLuint64EXT)arg2,(GLsizeiptr)arg3);

}

      
NAN_METHOD(colorFormatNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glColorFormatNV((GLint)arg0,(GLenum)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(edgeFlagFormatNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEdgeFlagFormatNV((GLsizei)arg0);

}

      
NAN_METHOD(fogCoordFormatNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glFogCoordFormatNV((GLenum)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(indexFormatNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glIndexFormatNV((GLenum)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(normalFormatNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glNormalFormatNV((GLenum)arg0,(GLsizei)arg1);

}

      
NAN_METHOD(secondaryColorFormatNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glSecondaryColorFormatNV((GLint)arg0,(GLenum)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(texCoordFormatNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTexCoordFormatNV((GLint)arg0,(GLenum)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(vertexAttribFormatNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glboolean");
    return;
  }
  
  GLboolean arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttribFormatNV((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLboolean)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(vertexAttribIFormatNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glVertexAttribIFormatNV((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3);

}

      
NAN_METHOD(vertexFormatNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glVertexFormatNV((GLint)arg0,(GLenum)arg1,(GLsizei)arg2);

}

      
NAN_METHOD(areProgramsResidentNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }
  GLboolean* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<boolean> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLboolean*>(*arg2_tarray);
  }


  GLboolean retval = glAreProgramsResidentNV(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(bindProgramNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glBindProgramNV((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(deleteProgramsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glDeleteProgramsNV((GLsizei)arg0,(const GLuint*)arg1);

}

      
NAN_METHOD(executeProgramNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glExecuteProgramNV((GLenum)arg0,(GLuint)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(genProgramsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glGenProgramsNV((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(getProgramParameterdvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glGetProgramParameterdvNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLdouble*)arg3);

}

      
NAN_METHOD(getProgramParameterfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetProgramParameterfvNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getProgramStringNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }


  glGetProgramStringNV((GLuint)arg0,(GLenum)arg1,(GLubyte*)arg2);

}

      
NAN_METHOD(getProgramivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetProgramivNV((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(getTrackMatrixivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetTrackMatrixivNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getVertexAttribPointervNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsArray()) {
    Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
    return;
  }
  
  auto array2 = info[0].As<v8::Array>();
  void** arg2 = static_cast<void**>(alloca(sizeof(void*)*array2->Length()));
    
  for (unsigned int i=0; i<array2->Length(); i++) {
    auto val = array2->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 3, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg2[i] = reinterpret_cast<void*>(*item); 
  }


  glGetVertexAttribPointervNV((GLuint)arg0,(GLenum)arg1,(void**)arg2);

}

      
NAN_METHOD(getVertexAttribdvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glGetVertexAttribdvNV((GLuint)arg0,(GLenum)arg1,(GLdouble*)arg2);

}

      
NAN_METHOD(getVertexAttribfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetVertexAttribfvNV((GLuint)arg0,(GLenum)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(getVertexAttribivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVertexAttribivNV((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(isProgramNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsProgramNV(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(loadProgramNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLubyte* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLubyte*>(*arg3_tarray);
  }


  glLoadProgramNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLubyte*)arg3);

}

      
NAN_METHOD(programParameter4dNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a gldouble");
    return;
  }
  
  GLdouble arg5 = (GLdouble)info[5]->NumberValue(ctx).ToChecked();


  glProgramParameter4dNV((GLenum)arg0,(GLuint)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4,(GLdouble)arg5);

}

      
NAN_METHOD(programParameter4dvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glProgramParameter4dvNV((GLenum)arg0,(GLuint)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(programParameter4fNV) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glProgramParameter4fNV((GLenum)arg0,(GLuint)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(programParameter4fvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glProgramParameter4fvNV((GLenum)arg0,(GLuint)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(programParameters4dvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glProgramParameters4dvNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(programParameters4fvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glProgramParameters4fvNV((GLenum)arg0,(GLuint)arg1,(GLsizei)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(requestResidentProgramsNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glsizei");
    return;
  }
  
  GLsizei arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }


  glRequestResidentProgramsNV((GLsizei)arg0,(GLuint*)arg1);

}

      
NAN_METHOD(trackMatrixNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();


  glTrackMatrixNV((GLenum)arg0,(GLuint)arg1,(GLenum)arg2,(GLenum)arg3);

}

      
NAN_METHOD(vertexAttrib1dNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttrib1dNV((GLuint)arg0,(GLdouble)arg1);

}

      
NAN_METHOD(vertexAttrib1dvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib1dvNV((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib1fNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();


  glVertexAttrib1fNV((GLuint)arg0,(GLfloat)arg1);

}

      
NAN_METHOD(vertexAttrib1fvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib1fvNV((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib1sNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();


  glVertexAttrib1sNV((GLuint)arg0,(GLshort)arg1);

}

      
NAN_METHOD(vertexAttrib1svNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib1svNV((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib2dNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttrib2dNV((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2);

}

      
NAN_METHOD(vertexAttrib2dvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib2dvNV((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib2fNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glVertexAttrib2fNV((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(vertexAttrib2fvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib2fvNV((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib2sNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();


  glVertexAttrib2sNV((GLuint)arg0,(GLshort)arg1,(GLshort)arg2);

}

      
NAN_METHOD(vertexAttrib2svNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib2svNV((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib3dNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttrib3dNV((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3);

}

      
NAN_METHOD(vertexAttrib3dvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib3dvNV((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib3fNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();


  glVertexAttrib3fNV((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3);

}

      
NAN_METHOD(vertexAttrib3fvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib3fvNV((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib3sNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();


  glVertexAttrib3sNV((GLuint)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3);

}

      
NAN_METHOD(vertexAttrib3svNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib3svNV((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4dNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gldouble");
    return;
  }
  
  GLdouble arg1 = (GLdouble)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gldouble");
    return;
  }
  
  GLdouble arg2 = (GLdouble)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gldouble");
    return;
  }
  
  GLdouble arg3 = (GLdouble)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gldouble");
    return;
  }
  
  GLdouble arg4 = (GLdouble)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttrib4dNV((GLuint)arg0,(GLdouble)arg1,(GLdouble)arg2,(GLdouble)arg3,(GLdouble)arg4);

}

      
NAN_METHOD(vertexAttrib4dvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLdouble* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLdouble*>(*arg1_tarray);
  }


  glVertexAttrib4dvNV((GLuint)arg0,(const GLdouble*)arg1);

}

      
NAN_METHOD(vertexAttrib4fNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glVertexAttrib4fNV((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(vertexAttrib4fvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glVertexAttrib4fvNV((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(vertexAttrib4sNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glshort");
    return;
  }
  
  GLshort arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glshort");
    return;
  }
  
  GLshort arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glshort");
    return;
  }
  
  GLshort arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glshort");
    return;
  }
  
  GLshort arg4 = info[4]->Int32Value(ctx).ToChecked();


  glVertexAttrib4sNV((GLuint)arg0,(GLshort)arg1,(GLshort)arg2,(GLshort)arg3,(GLshort)arg4);

}

      
NAN_METHOD(vertexAttrib4svNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLshort* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLshort*>(*arg1_tarray);
  }


  glVertexAttrib4svNV((GLuint)arg0,(const GLshort*)arg1);

}

      
NAN_METHOD(vertexAttrib4ubNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glubyte");
    return;
  }
  
  GLubyte arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glubyte");
    return;
  }
  
  GLubyte arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glubyte");
    return;
  }
  
  GLubyte arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glubyte");
    return;
  }
  
  GLubyte arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glVertexAttrib4ubNV((GLuint)arg0,(GLubyte)arg1,(GLubyte)arg2,(GLubyte)arg3,(GLubyte)arg4);

}

      
NAN_METHOD(vertexAttrib4ubvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glVertexAttrib4ubvNV((GLuint)arg0,(const GLubyte*)arg1);

}

      
NAN_METHOD(vertexAttribPointerNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  void* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<void*>(*arg4_tarray);
  }


  glVertexAttribPointerNV((GLuint)arg0,(GLint)arg1,(GLenum)arg2,(GLsizei)arg3,(const void*)arg4);

}

      
NAN_METHOD(vertexAttribs1dvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glVertexAttribs1dvNV((GLuint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(vertexAttribs1fvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glVertexAttribs1fvNV((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(vertexAttribs1svNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLshort* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLshort*>(*arg2_tarray);
  }


  glVertexAttribs1svNV((GLuint)arg0,(GLsizei)arg1,(const GLshort*)arg2);

}

      
NAN_METHOD(vertexAttribs2dvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glVertexAttribs2dvNV((GLuint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(vertexAttribs2fvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glVertexAttribs2fvNV((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(vertexAttribs2svNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLshort* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLshort*>(*arg2_tarray);
  }


  glVertexAttribs2svNV((GLuint)arg0,(GLsizei)arg1,(const GLshort*)arg2);

}

      
NAN_METHOD(vertexAttribs3dvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glVertexAttribs3dvNV((GLuint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(vertexAttribs3fvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glVertexAttribs3fvNV((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(vertexAttribs3svNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLshort* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLshort*>(*arg2_tarray);
  }


  glVertexAttribs3svNV((GLuint)arg0,(GLsizei)arg1,(const GLshort*)arg2);

}

      
NAN_METHOD(vertexAttribs4dvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLdouble* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLdouble*>(*arg2_tarray);
  }


  glVertexAttribs4dvNV((GLuint)arg0,(GLsizei)arg1,(const GLdouble*)arg2);

}

      
NAN_METHOD(vertexAttribs4fvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glVertexAttribs4fvNV((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(vertexAttribs4svNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLshort* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLshort*>(*arg2_tarray);
  }


  glVertexAttribs4svNV((GLuint)arg0,(GLsizei)arg1,(const GLshort*)arg2);

}

      
NAN_METHOD(vertexAttribs4ubvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLubyte* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLubyte*>(*arg2_tarray);
  }


  glVertexAttribs4ubvNV((GLuint)arg0,(GLsizei)arg1,(const GLubyte*)arg2);

}

      
NAN_METHOD(beginVideoCaptureNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glBeginVideoCaptureNV((GLuint)arg0);

}

      
NAN_METHOD(bindVideoCaptureStreamBufferNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glintptrarb");
    return;
  }
  
  GLintptrARB arg3 = (GLintptrARB)info[3]->Uint32Value(ctx).ToChecked();


  glBindVideoCaptureStreamBufferNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLintptrARB)arg3);

}

      
NAN_METHOD(bindVideoCaptureStreamTextureNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a gluint");
    return;
  }
  
  GLuint arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glBindVideoCaptureStreamTextureNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLenum)arg3,(GLuint)arg4);

}

      
NAN_METHOD(endVideoCaptureNV) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEndVideoCaptureNV((GLuint)arg0);

}

      
NAN_METHOD(getVideoCaptureStreamdvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glGetVideoCaptureStreamdvNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLdouble*)arg3);

}

      
NAN_METHOD(getVideoCaptureStreamfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glGetVideoCaptureStreamfvNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLfloat*)arg3);

}

      
NAN_METHOD(getVideoCaptureStreamivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glGetVideoCaptureStreamivNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(GLint*)arg3);

}

      
NAN_METHOD(getVideoCaptureivNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glGetVideoCaptureivNV((GLuint)arg0,(GLenum)arg1,(GLint*)arg2);

}

      
NAN_METHOD(videoCaptureNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLuint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLuint*>(*arg1_tarray);
  }
  GLuint64EXT* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint64EXT*>(*arg2_tarray);
  }


  GLenum retval = glVideoCaptureNV(arg0,arg1,arg2);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(videoCaptureStreamParameterdvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLdouble* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<double> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLdouble*>(*arg3_tarray);
  }


  glVideoCaptureStreamParameterdvNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(const GLdouble*)arg3);

}

      
NAN_METHOD(videoCaptureStreamParameterfvNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLfloat* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLfloat*>(*arg3_tarray);
  }


  glVideoCaptureStreamParameterfvNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(const GLfloat*)arg3);

}

      
NAN_METHOD(videoCaptureStreamParameterivNV) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glVideoCaptureStreamParameterivNV((GLuint)arg0,(GLuint)arg1,(GLenum)arg2,(const GLint*)arg3);

}

      
NAN_METHOD(depthRangeArrayfvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glDepthRangeArrayfvNV((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(depthRangeIndexedfNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();


  glDepthRangeIndexedfNV((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2);

}

      
NAN_METHOD(disableiNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDisableiNV((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(enableiNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glEnableiNV((GLenum)arg0,(GLuint)arg1);

}

      
NAN_METHOD(getFloati_vNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glGetFloati_vNV((GLenum)arg0,(GLuint)arg1,(GLfloat*)arg2);

}

      
NAN_METHOD(isEnablediNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glIsEnablediNV(arg0,arg1);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(scissorArrayvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glScissorArrayvNV((GLuint)arg0,(GLsizei)arg1,(const GLint*)arg2);

}

      
NAN_METHOD(scissorIndexedNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glScissorIndexedNV((GLuint)arg0,(GLint)arg1,(GLint)arg2,(GLsizei)arg3,(GLsizei)arg4);

}

      
NAN_METHOD(scissorIndexedvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLint* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLint*>(*arg1_tarray);
  }


  glScissorIndexedvNV((GLuint)arg0,(const GLint*)arg1);

}

      
NAN_METHOD(viewportArrayvNV) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLfloat* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfloat*>(*arg2_tarray);
  }


  glViewportArrayvNV((GLuint)arg0,(GLsizei)arg1,(const GLfloat*)arg2);

}

      
NAN_METHOD(viewportIndexedfNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();


  glViewportIndexedfNV((GLuint)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4);

}

      
NAN_METHOD(viewportIndexedfvNV) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glViewportIndexedfvNV((GLuint)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(viewportSwizzleNV) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glenum");
    return;
  }
  
  GLenum arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glenum");
    return;
  }
  
  GLenum arg4 = info[4]->Int32Value(ctx).ToChecked();


  glViewportSwizzleNV((GLuint)arg0,(GLenum)arg1,(GLenum)arg2,(GLenum)arg3,(GLenum)arg4);

}

      
NAN_METHOD(framebufferTextureMultiviewOVR) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glFramebufferTextureMultiviewOVR((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5);

}

      
NAN_METHOD(framebufferTextureMultisampleMultiviewOVR) {
  if (info.Length() != 7) {
    Nan::ThrowError("Expected 7 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glsizei");
    return;
  }
  
  GLsizei arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glint");
    return;
  }
  
  GLint arg5 = info[5]->Int32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();


  glFramebufferTextureMultisampleMultiviewOVR((GLenum)arg0,(GLenum)arg1,(GLuint)arg2,(GLint)arg3,(GLsizei)arg4,(GLint)arg5,(GLsizei)arg6);

}

      
NAN_METHOD(alphaFuncQCOM) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampf");
    return;
  }
  
  GLclampf arg1 = (GLclampf)info[1]->NumberValue(ctx).ToChecked();


  glAlphaFuncQCOM((GLenum)arg0,(GLclampf)arg1);

}

      
NAN_METHOD(disableDriverControlQCOM) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glDisableDriverControlQCOM((GLuint)arg0);

}

      
NAN_METHOD(enableDriverControlQCOM) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glEnableDriverControlQCOM((GLuint)arg0);

}

      
NAN_METHOD(getDriverControlStringQCOM) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLsizei* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<size_t> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLsizei*>(*arg2_tarray);
  }
  GLchar* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLchar*>(*arg3_tarray);
  }


  glGetDriverControlStringQCOM((GLuint)arg0,(GLsizei)arg1,(GLsizei*)arg2,(GLchar*)arg3);

}

      
NAN_METHOD(getDriverControlsQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  GLuint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLuint*>(*arg2_tarray);
  }


  glGetDriverControlsQCOM((GLint*)arg0,(GLsizei)arg1,(GLuint*)arg2);

}

      
NAN_METHOD(extGetBufferPointervQCOM) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsArray()) {
    Nan::ThrowError("Invalid parameter 2, expected array of typed arrays");
    return;
  }
  
  auto array1 = info[0].As<v8::Array>();
  void** arg1 = static_cast<void**>(alloca(sizeof(void*)*array1->Length()));
    
  for (unsigned int i=0; i<array1->Length(); i++) {
    auto val = array1->Get(ctx, i);
    v8::Local<v8::Value> item;

    if (!val.ToLocalChecked()->IsTypedArray() || !val.ToLocal(&item)) {
      Nan::ThrowError("Invalid parameter 2, expected array of typed arrays");
      return;
    }
    
    Nan::TypedArrayContents<char> tarray(item);
    arg1[i] = reinterpret_cast<void*>(*item); 
  }


  glExtGetBufferPointervQCOM((GLenum)arg0,(void**)arg1);

}

      
NAN_METHOD(extGetBuffersQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glExtGetBuffersQCOM((GLuint*)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(extGetFramebuffersQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glExtGetFramebuffersQCOM((GLuint*)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(extGetRenderbuffersQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glExtGetRenderbuffersQCOM((GLuint*)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(extGetTexLevelParameterivQCOM) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glenum");
    return;
  }
  
  GLenum arg3 = info[3]->Int32Value(ctx).ToChecked();
  GLint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLint*>(*arg4_tarray);
  }


  glExtGetTexLevelParameterivQCOM((GLuint)arg0,(GLenum)arg1,(GLint)arg2,(GLenum)arg3,(GLint*)arg4);

}

      
NAN_METHOD(extGetTexSubImageQCOM) {
  if (info.Length() != 11) {
    Nan::ThrowError("Expected 11 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glint");
    return;
  }
  
  GLint arg3 = info[3]->Int32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glint");
    return;
  }
  
  GLint arg4 = info[4]->Int32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glsizei");
    return;
  }
  
  GLsizei arg5 = info[5]->Uint32Value(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glsizei");
    return;
  }
  
  GLsizei arg6 = info[6]->Uint32Value(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glsizei");
    return;
  }
  
  GLsizei arg7 = info[7]->Uint32Value(ctx).ToChecked();
  if (!info[8]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 9, expected a glenum");
    return;
  }
  
  GLenum arg8 = info[8]->Int32Value(ctx).ToChecked();
  if (!info[9]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 10, expected a glenum");
    return;
  }
  
  GLenum arg9 = info[9]->Int32Value(ctx).ToChecked();
  void* arg10;

  if (info[10]->IsNullOrUndefined()) {
    arg10 = nullptr;
  } else {
    if (!info[10]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 11, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg10_tarray(info[10]);
    arg10 = reinterpret_cast<void*>(*arg10_tarray);
  }


  glExtGetTexSubImageQCOM((GLenum)arg0,(GLint)arg1,(GLint)arg2,(GLint)arg3,(GLint)arg4,(GLsizei)arg5,(GLsizei)arg6,(GLsizei)arg7,(GLenum)arg8,(GLenum)arg9,(void*)arg10);

}

      
NAN_METHOD(extGetTexturesQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glExtGetTexturesQCOM((GLuint*)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(extTexObjectStateOverrideiQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glint");
    return;
  }
  
  GLint arg2 = info[2]->Int32Value(ctx).ToChecked();


  glExtTexObjectStateOverrideiQCOM((GLenum)arg0,(GLenum)arg1,(GLint)arg2);

}

      
NAN_METHOD(extGetProgramBinarySourceQCOM) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLchar* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLchar*>(*arg2_tarray);
  }
  GLint* arg3;

  if (info[3]->IsNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    if (!info[3]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 4, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg3_tarray(info[3]);
    arg3 = reinterpret_cast<GLint*>(*arg3_tarray);
  }


  glExtGetProgramBinarySourceQCOM((GLuint)arg0,(GLenum)arg1,(GLchar*)arg2,(GLint*)arg3);

}

      
NAN_METHOD(extGetProgramsQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glExtGetProgramsQCOM((GLuint*)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(extGetShadersQCOM) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLuint* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLuint*>(*arg0_tarray);
  }
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLint* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<int> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLint*>(*arg2_tarray);
  }


  glExtGetShadersQCOM((GLuint*)arg0,(GLint)arg1,(GLint*)arg2);

}

      
NAN_METHOD(extIsProgramBinaryQCOM) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();


  GLboolean retval = glExtIsProgramBinaryQCOM(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(framebufferFoveationConfigQCOM) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  GLuint* arg4;

  if (info[4]->IsNullOrUndefined()) {
    arg4 = nullptr;
  } else {
    if (!info[4]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 5, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned int> arg4_tarray(info[4]);
    arg4 = reinterpret_cast<GLuint*>(*arg4_tarray);
  }


  glFramebufferFoveationConfigQCOM((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLuint*)arg4);

}

      
NAN_METHOD(framebufferFoveationParametersQCOM) {
  if (info.Length() != 8) {
    Nan::ThrowError("Expected 8 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();
  if (!info[6]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 7, expected a glfloat");
    return;
  }
  
  GLfloat arg6 = (GLfloat)info[6]->NumberValue(ctx).ToChecked();
  if (!info[7]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 8, expected a glfloat");
    return;
  }
  
  GLfloat arg7 = (GLfloat)info[7]->NumberValue(ctx).ToChecked();


  glFramebufferFoveationParametersQCOM((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5,(GLfloat)arg6,(GLfloat)arg7);

}

      
NAN_METHOD(framebufferFetchBarrierQCOM) {
  if (info.Length() != 0) {
    Nan::ThrowError("Expected 0 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();



  glFramebufferFetchBarrierQCOM();

}

      
NAN_METHOD(endTilingQCOM) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glbitfield");
    return;
  }
  
  GLbitfield arg0 = info[0]->Int32Value(ctx).ToChecked();


  glEndTilingQCOM((GLbitfield)arg0);

}

      
NAN_METHOD(startTilingQCOM) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a gluint");
    return;
  }
  
  GLuint arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a gluint");
    return;
  }
  
  GLuint arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a gluint");
    return;
  }
  
  GLuint arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a gluint");
    return;
  }
  
  GLuint arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glbitfield");
    return;
  }
  
  GLbitfield arg4 = info[4]->Int32Value(ctx).ToChecked();


  glStartTilingQCOM((GLuint)arg0,(GLuint)arg1,(GLuint)arg2,(GLuint)arg3,(GLbitfield)arg4);

}

      
NAN_METHOD(alphaFuncx) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampx");
    return;
  }
  
  GLclampx arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glAlphaFuncx((GLenum)arg0,(GLclampx)arg1);

}

      
NAN_METHOD(clearColorx) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampx");
    return;
  }
  
  GLclampx arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampx");
    return;
  }
  
  GLclampx arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glclampx");
    return;
  }
  
  GLclampx arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glclampx");
    return;
  }
  
  GLclampx arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glClearColorx((GLclampx)arg0,(GLclampx)arg1,(GLclampx)arg2,(GLclampx)arg3);

}

      
NAN_METHOD(clearDepthx) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampx");
    return;
  }
  
  GLclampx arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glClearDepthx((GLclampx)arg0);

}

      
NAN_METHOD(color4x) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfixed");
    return;
  }
  
  GLfixed arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glColor4x((GLfixed)arg0,(GLfixed)arg1,(GLfixed)arg2,(GLfixed)arg3);

}

      
NAN_METHOD(depthRangex) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampx");
    return;
  }
  
  GLclampx arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glclampx");
    return;
  }
  
  GLclampx arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glDepthRangex((GLclampx)arg0,(GLclampx)arg1);

}

      
NAN_METHOD(fogx) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glFogx((GLenum)arg0,(GLfixed)arg1);

}

      
NAN_METHOD(fogxv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfixed* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfixed*>(*arg1_tarray);
  }


  glFogxv((GLenum)arg0,(const GLfixed*)arg1);

}

      
NAN_METHOD(frustumf) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glFrustumf((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(frustumx) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfixed");
    return;
  }
  
  GLfixed arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfixed");
    return;
  }
  
  GLfixed arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfixed");
    return;
  }
  
  GLfixed arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glFrustumx((GLfixed)arg0,(GLfixed)arg1,(GLfixed)arg2,(GLfixed)arg3,(GLfixed)arg4,(GLfixed)arg5);

}

      
NAN_METHOD(lightModelx) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glLightModelx((GLenum)arg0,(GLfixed)arg1);

}

      
NAN_METHOD(lightModelxv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfixed* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfixed*>(*arg1_tarray);
  }


  glLightModelxv((GLenum)arg0,(const GLfixed*)arg1);

}

      
NAN_METHOD(lightx) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glLightx((GLenum)arg0,(GLenum)arg1,(GLfixed)arg2);

}

      
NAN_METHOD(lightxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glLightxv((GLenum)arg0,(GLenum)arg1,(const GLfixed*)arg2);

}

      
NAN_METHOD(lineWidthx) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glLineWidthx((GLfixed)arg0);

}

      
NAN_METHOD(loadMatrixx) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfixed* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfixed*>(*arg0_tarray);
  }


  glLoadMatrixx((const GLfixed*)arg0);

}

      
NAN_METHOD(materialx) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glMaterialx((GLenum)arg0,(GLenum)arg1,(GLfixed)arg2);

}

      
NAN_METHOD(materialxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glMaterialxv((GLenum)arg0,(GLenum)arg1,(const GLfixed*)arg2);

}

      
NAN_METHOD(multMatrixx) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLfixed* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLfixed*>(*arg0_tarray);
  }


  glMultMatrixx((const GLfixed*)arg0);

}

      
NAN_METHOD(multiTexCoord4x) {
  if (info.Length() != 5) {
    Nan::ThrowError("Expected 5 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfixed");
    return;
  }
  
  GLfixed arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfixed");
    return;
  }
  
  GLfixed arg4 = info[4]->Uint32Value(ctx).ToChecked();


  glMultiTexCoord4x((GLenum)arg0,(GLfixed)arg1,(GLfixed)arg2,(GLfixed)arg3,(GLfixed)arg4);

}

      
NAN_METHOD(normal3x) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glNormal3x((GLfixed)arg0,(GLfixed)arg1,(GLfixed)arg2);

}

      
NAN_METHOD(orthof) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfloat");
    return;
  }
  
  GLfloat arg0 = (GLfloat)info[0]->NumberValue(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfloat");
    return;
  }
  
  GLfloat arg1 = (GLfloat)info[1]->NumberValue(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfloat");
    return;
  }
  
  GLfloat arg2 = (GLfloat)info[2]->NumberValue(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfloat");
    return;
  }
  
  GLfloat arg3 = (GLfloat)info[3]->NumberValue(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfloat");
    return;
  }
  
  GLfloat arg4 = (GLfloat)info[4]->NumberValue(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfloat");
    return;
  }
  
  GLfloat arg5 = (GLfloat)info[5]->NumberValue(ctx).ToChecked();


  glOrthof((GLfloat)arg0,(GLfloat)arg1,(GLfloat)arg2,(GLfloat)arg3,(GLfloat)arg4,(GLfloat)arg5);

}

      
NAN_METHOD(orthox) {
  if (info.Length() != 6) {
    Nan::ThrowError("Expected 6 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfixed");
    return;
  }
  
  GLfixed arg3 = info[3]->Uint32Value(ctx).ToChecked();
  if (!info[4]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 5, expected a glfixed");
    return;
  }
  
  GLfixed arg4 = info[4]->Uint32Value(ctx).ToChecked();
  if (!info[5]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 6, expected a glfixed");
    return;
  }
  
  GLfixed arg5 = info[5]->Uint32Value(ctx).ToChecked();


  glOrthox((GLfixed)arg0,(GLfixed)arg1,(GLfixed)arg2,(GLfixed)arg3,(GLfixed)arg4,(GLfixed)arg5);

}

      
NAN_METHOD(pointSizex) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();


  glPointSizex((GLfixed)arg0);

}

      
NAN_METHOD(polygonOffsetx) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glPolygonOffsetx((GLfixed)arg0,(GLfixed)arg1);

}

      
NAN_METHOD(rotatex) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glfixed");
    return;
  }
  
  GLfixed arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glRotatex((GLfixed)arg0,(GLfixed)arg1,(GLfixed)arg2,(GLfixed)arg3);

}

      
NAN_METHOD(sampleCoveragex) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glclampx");
    return;
  }
  
  GLclampx arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glboolean");
    return;
  }
  
  GLboolean arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glSampleCoveragex((GLclampx)arg0,(GLboolean)arg1);

}

      
NAN_METHOD(scalex) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glScalex((GLfixed)arg0,(GLfixed)arg1,(GLfixed)arg2);

}

      
NAN_METHOD(texEnvx) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTexEnvx((GLenum)arg0,(GLenum)arg1,(GLfixed)arg2);

}

      
NAN_METHOD(texEnvxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glTexEnvxv((GLenum)arg0,(GLenum)arg1,(const GLfixed*)arg2);

}

      
NAN_METHOD(texParameterx) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTexParameterx((GLenum)arg0,(GLenum)arg1,(GLfixed)arg2);

}

      
NAN_METHOD(translatex) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glfixed");
    return;
  }
  
  GLfixed arg0 = info[0]->Uint32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glfixed");
    return;
  }
  
  GLfixed arg2 = info[2]->Uint32Value(ctx).ToChecked();


  glTranslatex((GLfixed)arg0,(GLfixed)arg1,(GLfixed)arg2);

}

      
NAN_METHOD(clipPlanef) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfloat* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<float> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfloat*>(*arg1_tarray);
  }


  glClipPlanef((GLenum)arg0,(const GLfloat*)arg1);

}

      
NAN_METHOD(clipPlanex) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfixed* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfixed*>(*arg1_tarray);
  }


  glClipPlanex((GLenum)arg0,(const GLfixed*)arg1);

}

      
NAN_METHOD(getFixedv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfixed* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfixed*>(*arg1_tarray);
  }


  glGetFixedv((GLenum)arg0,(GLfixed*)arg1);

}

      
NAN_METHOD(getLightxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glGetLightxv((GLenum)arg0,(GLenum)arg1,(GLfixed*)arg2);

}

      
NAN_METHOD(getMaterialxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glGetMaterialxv((GLenum)arg0,(GLenum)arg1,(GLfixed*)arg2);

}

      
NAN_METHOD(getTexEnvxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glGetTexEnvxv((GLenum)arg0,(GLenum)arg1,(GLfixed*)arg2);

}

      
NAN_METHOD(getTexParameterxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glGetTexParameterxv((GLenum)arg0,(GLenum)arg1,(GLfixed*)arg2);

}

      
NAN_METHOD(pointParameterx) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glfixed");
    return;
  }
  
  GLfixed arg1 = info[1]->Uint32Value(ctx).ToChecked();


  glPointParameterx((GLenum)arg0,(GLfixed)arg1);

}

      
NAN_METHOD(pointParameterxv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLfixed* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLfixed*>(*arg1_tarray);
  }


  glPointParameterxv((GLenum)arg0,(const GLfixed*)arg1);

}

      
NAN_METHOD(pointSizePointerOES) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glsizei");
    return;
  }
  
  GLsizei arg1 = info[1]->Uint32Value(ctx).ToChecked();
  void* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<void*>(*arg2_tarray);
  }


  glPointSizePointerOES((GLenum)arg0,(GLsizei)arg1,(const void*)arg2);

}

      
NAN_METHOD(texParameterxv) {
  if (info.Length() != 3) {
    Nan::ThrowError("Expected 3 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glenum");
    return;
  }
  
  GLenum arg1 = info[1]->Int32Value(ctx).ToChecked();
  GLfixed* arg2;

  if (info[2]->IsNullOrUndefined()) {
    arg2 = nullptr;
  } else {
    if (!info[2]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 3, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned short> arg2_tarray(info[2]);
    arg2 = reinterpret_cast<GLfixed*>(*arg2_tarray);
  }


  glTexParameterxv((GLenum)arg0,(GLenum)arg1,(const GLfixed*)arg2);

}

      
NAN_METHOD(getExtensionREGAL) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLchar* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLchar*>(*arg0_tarray);
  }


  GLboolean retval = glGetExtensionREGAL(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(isSupportedREGAL) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  GLchar* arg0;

  if (info[0]->IsNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    if (!info[0]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 1, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<char> arg0_tarray(info[0]);
    arg0 = reinterpret_cast<GLchar*>(*arg0_tarray);
  }


  GLboolean retval = glIsSupportedREGAL(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(addressSpace) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glbitfield");
    return;
  }
  
  GLbitfield arg1 = info[1]->Int32Value(ctx).ToChecked();


  glAddressSpace((GLenum)arg0,(GLbitfield)arg1);

}

      
NAN_METHOD(dataPipe) {
  if (info.Length() != 1) {
    Nan::ThrowError("Expected 1 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();


  GLint retval = glDataPipe(arg0);

  info.GetReturnValue().Set(retval);
      
}

      
NAN_METHOD(getMPEGQuantTableubv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glGetMPEGQuantTableubv((GLenum)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(mPEGQuantTableubv) {
  if (info.Length() != 2) {
    Nan::ThrowError("Expected 2 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glenum");
    return;
  }
  
  GLenum arg0 = info[0]->Int32Value(ctx).ToChecked();
  GLubyte* arg1;

  if (info[1]->IsNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    if (!info[1]->IsTypedArray()) {
      Nan::ThrowError("Invalid parameter 2, expected a typed array");
      return;
    }
   
    Nan::TypedArrayContents<unsigned char> arg1_tarray(info[1]);
    arg1 = reinterpret_cast<GLubyte*>(*arg1_tarray);
  }


  glMPEGQuantTableubv((GLenum)arg0,(GLubyte*)arg1);

}

      
NAN_METHOD(addSwapHintRectWIN) {
  if (info.Length() != 4) {
    Nan::ThrowError("Expected 4 arguments");
    return;
  }
  
  auto ctx = Nan::GetCurrentContext();

  if (!info[0]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 1, expected a glint");
    return;
  }
  
  GLint arg0 = info[0]->Int32Value(ctx).ToChecked();
  if (!info[1]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 2, expected a glint");
    return;
  }
  
  GLint arg1 = info[1]->Int32Value(ctx).ToChecked();
  if (!info[2]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 3, expected a glsizei");
    return;
  }
  
  GLsizei arg2 = info[2]->Uint32Value(ctx).ToChecked();
  if (!info[3]->IsNumber()) {
    Nan::ThrowError("Invalid parameter 4, expected a glsizei");
    return;
  }
  
  GLsizei arg3 = info[3]->Uint32Value(ctx).ToChecked();


  glAddSwapHintRectWIN((GLint)arg0,(GLint)arg1,(GLsizei)arg2,(GLsizei)arg3);

}


NAN_MODULE_INIT(InitAll) {
  Nan::Set(target, Nan::New("initGlew").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(initGlew)).ToLocalChecked());    
      Nan::Set(target, Nan::New("accum").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(accum)).ToLocalChecked());
  Nan::Set(target, Nan::New("alphaFunc").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(alphaFunc)).ToLocalChecked());
  Nan::Set(target, Nan::New("areTexturesResident").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(areTexturesResident)).ToLocalChecked());
  Nan::Set(target, Nan::New("arrayElement").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(arrayElement)).ToLocalChecked());
  Nan::Set(target, Nan::New("begin").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(begin)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTexture").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTexture)).ToLocalChecked());
  Nan::Set(target, Nan::New("bitmap").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bitmap)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFunc").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFunc)).ToLocalChecked());
  Nan::Set(target, Nan::New("callList").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(callList)).ToLocalChecked());
  Nan::Set(target, Nan::New("callLists").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(callLists)).ToLocalChecked());
  Nan::Set(target, Nan::New("clear").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clear)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearAccum").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearAccum)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearColor").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearColor)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearDepth").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearDepth)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearIndex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearIndex)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearStencil").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearStencil)).ToLocalChecked());
  Nan::Set(target, Nan::New("clipPlane").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clipPlane)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3b").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3b)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3bv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3bv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3ub").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3ub)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3ubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3ubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3us").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3us)).ToLocalChecked());
  Nan::Set(target, Nan::New("color3usv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color3usv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4b").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4b)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4bv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4bv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4s)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4ub").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4ub)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4ubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4ubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4us").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4us)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4usv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4usv)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorMask").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorMask)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorMaterial").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorMaterial)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyPixels").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyPixels)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexSubImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexSubImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexSubImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexSubImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("cullFace").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(cullFace)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteLists").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteLists)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteTextures").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteTextures)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthFunc").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthFunc)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthMask").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthMask)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("disable").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disable)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableClientState").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableClientState)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArrays").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArrays)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElements").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElements)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawPixels").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawPixels)).ToLocalChecked());
  Nan::Set(target, Nan::New("edgeFlag").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(edgeFlag)).ToLocalChecked());
  Nan::Set(target, Nan::New("edgeFlagPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(edgeFlagPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("edgeFlagv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(edgeFlagv)).ToLocalChecked());
  Nan::Set(target, Nan::New("enable").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enable)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableClientState").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableClientState)).ToLocalChecked());
  Nan::Set(target, Nan::New("end").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(end)).ToLocalChecked());
  Nan::Set(target, Nan::New("endList").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endList)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord1dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord1dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord1fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord1fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalCoord2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalCoord2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalMesh1").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalMesh1)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalMesh2").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalMesh2)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalPoint1").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalPoint1)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalPoint2").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalPoint2)).ToLocalChecked());
  Nan::Set(target, Nan::New("feedbackBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(feedbackBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("finish").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(finish)).ToLocalChecked());
  Nan::Set(target, Nan::New("flush").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flush)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogf)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogi)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("frontFace").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(frontFace)).ToLocalChecked());
  Nan::Set(target, Nan::New("frustum").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(frustum)).ToLocalChecked());
  Nan::Set(target, Nan::New("genLists").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genLists)).ToLocalChecked());
  Nan::Set(target, Nan::New("genTextures").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genTextures)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBooleanv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBooleanv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getClipPlane").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getClipPlane)).ToLocalChecked());
  Nan::Set(target, Nan::New("getDoublev").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getDoublev)).ToLocalChecked());
  Nan::Set(target, Nan::New("getError").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getError)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFloatv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFloatv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getIntegerv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getIntegerv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getLightfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getLightfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getLightiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getLightiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapdv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapdv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMaterialfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMaterialfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMaterialiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMaterialiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPixelMapfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPixelMapfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPixelMapuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPixelMapuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPixelMapusv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPixelMapusv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPointerv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPointerv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPolygonStipple").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPolygonStipple)).ToLocalChecked());
  Nan::Set(target, Nan::New("getString").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getString)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexEnvfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexEnvfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexEnviv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexEnviv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexGendv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexGendv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexGenfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexGenfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexGeniv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexGeniv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexLevelParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexLevelParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexLevelParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexLevelParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("hint").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(hint)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexMask").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexMask)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexd").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexd)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexdv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexdv)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexf)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexi)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexs").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexs)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexsv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexsv)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexub").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexub)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("initNames").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(initNames)).ToLocalChecked());
  Nan::Set(target, Nan::New("interleavedArrays").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(interleavedArrays)).ToLocalChecked());
  Nan::Set(target, Nan::New("isEnabled").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isEnabled)).ToLocalChecked());
  Nan::Set(target, Nan::New("isList").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isList)).ToLocalChecked());
  Nan::Set(target, Nan::New("isTexture").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isTexture)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightModelf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightModelf)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightModelfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightModelfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightModeli").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightModeli)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightModeliv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightModeliv)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightf)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("lighti").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lighti)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("lineStipple").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lineStipple)).ToLocalChecked());
  Nan::Set(target, Nan::New("lineWidth").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lineWidth)).ToLocalChecked());
  Nan::Set(target, Nan::New("listBase").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(listBase)).ToLocalChecked());
  Nan::Set(target, Nan::New("loadIdentity").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(loadIdentity)).ToLocalChecked());
  Nan::Set(target, Nan::New("loadMatrixd").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(loadMatrixd)).ToLocalChecked());
  Nan::Set(target, Nan::New("loadMatrixf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(loadMatrixf)).ToLocalChecked());
  Nan::Set(target, Nan::New("loadName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(loadName)).ToLocalChecked());
  Nan::Set(target, Nan::New("logicOp").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(logicOp)).ToLocalChecked());
  Nan::Set(target, Nan::New("map1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(map1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("map1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(map1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("map2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(map2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("map2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(map2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapGrid1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapGrid1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapGrid1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapGrid1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapGrid2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapGrid2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapGrid2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapGrid2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("materialf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(materialf)).ToLocalChecked());
  Nan::Set(target, Nan::New("materialfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(materialfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("materiali").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(materiali)).ToLocalChecked());
  Nan::Set(target, Nan::New("materialiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(materialiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixMode").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixMode)).ToLocalChecked());
  Nan::Set(target, Nan::New("multMatrixd").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multMatrixd)).ToLocalChecked());
  Nan::Set(target, Nan::New("multMatrixf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multMatrixf)).ToLocalChecked());
  Nan::Set(target, Nan::New("newList").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(newList)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3b").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3b)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3bv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3bv)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("ortho").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(ortho)).ToLocalChecked());
  Nan::Set(target, Nan::New("passThrough").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(passThrough)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelMapfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelMapfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelMapuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelMapuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelMapusv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelMapusv)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelStoref").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelStoref)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelStorei").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelStorei)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelTransferf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelTransferf)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelTransferi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelTransferi)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelZoom").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelZoom)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointSize").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointSize)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonMode").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonMode)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonOffset").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonOffset)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonStipple").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonStipple)).ToLocalChecked());
  Nan::Set(target, Nan::New("popAttrib").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(popAttrib)).ToLocalChecked());
  Nan::Set(target, Nan::New("popClientAttrib").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(popClientAttrib)).ToLocalChecked());
  Nan::Set(target, Nan::New("popMatrix").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(popMatrix)).ToLocalChecked());
  Nan::Set(target, Nan::New("popName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(popName)).ToLocalChecked());
  Nan::Set(target, Nan::New("prioritizeTextures").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(prioritizeTextures)).ToLocalChecked());
  Nan::Set(target, Nan::New("pushAttrib").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pushAttrib)).ToLocalChecked());
  Nan::Set(target, Nan::New("pushClientAttrib").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pushClientAttrib)).ToLocalChecked());
  Nan::Set(target, Nan::New("pushMatrix").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pushMatrix)).ToLocalChecked());
  Nan::Set(target, Nan::New("pushName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pushName)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2s)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos2sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos2sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4s)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterPos4sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterPos4sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("readBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(readBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("readPixels").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(readPixels)).ToLocalChecked());
  Nan::Set(target, Nan::New("rectd").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rectd)).ToLocalChecked());
  Nan::Set(target, Nan::New("rectdv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rectdv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rectf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rectf)).ToLocalChecked());
  Nan::Set(target, Nan::New("rectfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rectfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("recti").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(recti)).ToLocalChecked());
  Nan::Set(target, Nan::New("rectiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rectiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("rects").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rects)).ToLocalChecked());
  Nan::Set(target, Nan::New("rectsv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rectsv)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderMode").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderMode)).ToLocalChecked());
  Nan::Set(target, Nan::New("rotated").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rotated)).ToLocalChecked());
  Nan::Set(target, Nan::New("rotatef").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rotatef)).ToLocalChecked());
  Nan::Set(target, Nan::New("scaled").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scaled)).ToLocalChecked());
  Nan::Set(target, Nan::New("scalef").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scalef)).ToLocalChecked());
  Nan::Set(target, Nan::New("scissor").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scissor)).ToLocalChecked());
  Nan::Set(target, Nan::New("selectBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(selectBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("shadeModel").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shadeModel)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilFunc").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilFunc)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilMask").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilMask)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilOp").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilOp)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1i)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1s)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord1sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord1sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2s)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord2sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord2sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4s)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoord4sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoord4sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("texEnvf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texEnvf)).ToLocalChecked());
  Nan::Set(target, Nan::New("texEnvfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texEnvfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texEnvi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texEnvi)).ToLocalChecked());
  Nan::Set(target, Nan::New("texEnviv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texEnviv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texGend").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texGend)).ToLocalChecked());
  Nan::Set(target, Nan::New("texGendv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texGendv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texGenf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texGenf)).ToLocalChecked());
  Nan::Set(target, Nan::New("texGenfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texGenfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texGeni").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texGeni)).ToLocalChecked());
  Nan::Set(target, Nan::New("texGeniv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texGeniv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterf)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texSubImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texSubImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("texSubImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texSubImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("translated").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(translated)).ToLocalChecked());
  Nan::Set(target, Nan::New("translatef").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(translatef)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2s)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex2sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex2sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4s)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertex4sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertex4sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewport").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewport)).ToLocalChecked());
  Nan::Set(target, Nan::New("ewInit").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(ewInit)).ToLocalChecked());
  Nan::Set(target, Nan::New("ewIsSupported").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(ewIsSupported)).ToLocalChecked());
  Nan::Set(target, Nan::New("ewGetExtension").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(ewGetExtension)).ToLocalChecked());
  Nan::Set(target, Nan::New("ewGetErrorString").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(ewGetErrorString)).ToLocalChecked());
  Nan::Set(target, Nan::New("ewGetString").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(ewGetString)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexSubImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexSubImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawRangeElements").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawRangeElements)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("texSubImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texSubImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("activeTexture").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(activeTexture)).ToLocalChecked());
  Nan::Set(target, Nan::New("clientActiveTexture").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clientActiveTexture)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexSubImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexSubImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexSubImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexSubImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexSubImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexSubImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCompressedTexImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCompressedTexImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1i)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1s)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2s)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4s)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("sampleCoverage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(sampleCoverage)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendColor").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendColor)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquation)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFuncSeparate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFuncSeparate)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordd").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordd)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoorddv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoorddv)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordf)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArrays").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArrays)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElements").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElements)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterf)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3b").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3b)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3bv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3bv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3ub").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3ub)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3ubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3ubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3us").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3us)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3usv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3usv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColorPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColorPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2s)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginQuery").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginQuery)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferData)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteBuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteBuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteQueries").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteQueries)).ToLocalChecked());
  Nan::Set(target, Nan::New("endQuery").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endQuery)).ToLocalChecked());
  Nan::Set(target, Nan::New("genBuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genBuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("genQueries").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genQueries)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferPointerv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferPointerv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("isBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("isQuery").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isQuery)).ToLocalChecked());
  Nan::Set(target, Nan::New("unmapBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(unmapBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("attachShader").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(attachShader)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindAttribLocation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindAttribLocation)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationSeparate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationSeparate)).ToLocalChecked());
  Nan::Set(target, Nan::New("compileShader").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compileShader)).ToLocalChecked());
  Nan::Set(target, Nan::New("createProgram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createProgram)).ToLocalChecked());
  Nan::Set(target, Nan::New("createShader").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createShader)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteProgram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteProgram)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteShader").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteShader)).ToLocalChecked());
  Nan::Set(target, Nan::New("detachShader").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(detachShader)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableVertexAttribArray").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableVertexAttribArray)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableVertexAttribArray").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableVertexAttribArray)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveAttrib").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveAttrib)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveUniform").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveUniform)).ToLocalChecked());
  Nan::Set(target, Nan::New("getAttachedShaders").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getAttachedShaders)).ToLocalChecked());
  Nan::Set(target, Nan::New("getAttribLocation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getAttribLocation)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramInfoLog").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramInfoLog)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getShaderInfoLog").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getShaderInfoLog)).ToLocalChecked());
  Nan::Set(target, Nan::New("getShaderSource").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getShaderSource)).ToLocalChecked());
  Nan::Set(target, Nan::New("getShaderiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getShaderiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformLocation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformLocation)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribPointerv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribPointerv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribdv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribdv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("isProgram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isProgram)).ToLocalChecked());
  Nan::Set(target, Nan::New("isShader").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isShader)).ToLocalChecked());
  Nan::Set(target, Nan::New("linkProgram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(linkProgram)).ToLocalChecked());
  Nan::Set(target, Nan::New("shaderSource").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shaderSource)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilFuncSeparate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilFuncSeparate)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilMaskSeparate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilMaskSeparate)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilOpSeparate").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilOpSeparate)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1i)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("useProgram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(useProgram)).ToLocalChecked());
  Nan::Set(target, Nan::New("validateProgram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(validateProgram)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1s)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2s)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3s)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4Nbv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4Nbv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4Niv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4Niv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4Nsv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4Nsv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4Nub").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4Nub)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4Nubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4Nubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4Nuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4Nuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4Nusv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4Nusv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4bv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4bv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4s").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4s)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4ubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4ubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4usv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4usv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2x3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2x3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2x4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2x4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3x2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3x2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3x4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3x4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4x2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4x2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4x3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4x3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginConditionalRender").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginConditionalRender)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginTransformFeedback").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginTransformFeedback)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindFragDataLocation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindFragDataLocation)).ToLocalChecked());
  Nan::Set(target, Nan::New("clampColor").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clampColor)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearBufferfi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearBufferfi)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearBufferfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearBufferfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearBufferiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearBufferiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearBufferuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearBufferuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorMaski").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorMaski)).ToLocalChecked());
  Nan::Set(target, Nan::New("disablei").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disablei)).ToLocalChecked());
  Nan::Set(target, Nan::New("enablei").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enablei)).ToLocalChecked());
  Nan::Set(target, Nan::New("endConditionalRender").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endConditionalRender)).ToLocalChecked());
  Nan::Set(target, Nan::New("endTransformFeedback").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endTransformFeedback)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBooleani_v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBooleani_v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragDataLocation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragDataLocation)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameterIiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameterIiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameterIuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameterIuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTransformFeedbackVarying").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTransformFeedbackVarying)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribIiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribIiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribIuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribIuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("isEnabledi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isEnabledi)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterIiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterIiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterIuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterIuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("transformFeedbackVaryings").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(transformFeedbackVaryings)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1i)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4bv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4bv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4sv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4sv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4ubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4ubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4usv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4usv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribIPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribIPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysInstanced").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysInstanced)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstanced").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstanced)).ToLocalChecked());
  Nan::Set(target, Nan::New("primitiveRestartIndex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(primitiveRestartIndex)).ToLocalChecked());
  Nan::Set(target, Nan::New("texBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferParameteri64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferParameteri64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInteger64i_v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInteger64i_v)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribDivisor").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribDivisor)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationSeparatei").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationSeparatei)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationi)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFuncSeparatei").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFuncSeparatei)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFunci").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFunci)).ToLocalChecked());
  Nan::Set(target, Nan::New("minSampleShading").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(minSampleShading)).ToLocalChecked());
  Nan::Set(target, Nan::New("getGraphicsResetStatus").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getGraphicsResetStatus)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnCompressedTexImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnCompressedTexImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnTexImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnTexImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformdv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformdv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysIndirectCount").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysIndirectCount)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsIndirectCount").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsIndirectCount)).ToLocalChecked());
  Nan::Set(target, Nan::New("specializeShader").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(specializeShader)).ToLocalChecked());
  Nan::Set(target, Nan::New("tbufferMask3DFX").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(tbufferMask3DFX)).ToLocalChecked());
  Nan::Set(target, Nan::New("debugMessageEnableAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(debugMessageEnableAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("debugMessageInsertAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(debugMessageInsertAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getDebugMessageLogAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getDebugMessageLogAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationIndexedAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationIndexedAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationSeparateIndexedAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationSeparateIndexedAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFuncIndexedAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFuncIndexedAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFuncSeparateIndexedAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFuncSeparateIndexedAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferSamplePositionsfvAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferSamplePositionsfvAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFramebufferParameterfvAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFramebufferParameterfvAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedFramebufferParameterfvAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedFramebufferParameterfvAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferSamplePositionsfvAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferSamplePositionsfvAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribParameteriAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribParameteriAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysIndirectAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysIndirectAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsIndirectAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsIndirectAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteNamesAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteNamesAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("genNamesAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genNamesAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("isNameAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isNameAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("queryObjectParameteruiAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(queryObjectParameteruiAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginPerfMonitorAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginPerfMonitorAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("deletePerfMonitorsAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deletePerfMonitorsAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("endPerfMonitorAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endPerfMonitorAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("genPerfMonitorsAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genPerfMonitorsAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfMonitorCounterDataAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfMonitorCounterDataAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfMonitorCounterInfoAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfMonitorCounterInfoAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfMonitorCounterStringAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfMonitorCounterStringAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfMonitorCountersAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfMonitorCountersAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfMonitorGroupStringAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfMonitorGroupStringAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfMonitorGroupsAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfMonitorGroupsAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("selectPerfMonitorCountersAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(selectPerfMonitorCountersAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("setMultisamplefvAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(setMultisamplefvAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorageSparseAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorageSparseAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorageSparseAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorageSparseAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilOpValueAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilOpValueAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("tessellationFactorAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(tessellationFactorAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("tessellationModeAMD").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(tessellationModeAMD)).ToLocalChecked());
  Nan::Set(target, Nan::New("blitFramebufferANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blitFramebufferANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorageMultisampleANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorageMultisampleANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysInstancedANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysInstancedANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribDivisorANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribDivisorANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginQueryANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginQueryANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteQueriesANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteQueriesANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("endQueryANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endQueryANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("genQueriesANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genQueriesANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjecti64vANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjecti64vANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectivANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectivANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectui64vANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectui64vANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectuivANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectuivANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryivANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryivANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("isQueryANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isQueryANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("queryCounterANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(queryCounterANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTranslatedShaderSourceANGLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTranslatedShaderSourceANGLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTextureLevelsAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTextureLevelsAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementArrayAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementArrayAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawRangeElementArrayAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawRangeElementArrayAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("elementPointerAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(elementPointerAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementArrayAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementArrayAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawRangeElementArrayAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawRangeElementArrayAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteFencesAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteFencesAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("finishFenceAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(finishFenceAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("finishObjectAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(finishObjectAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("genFencesAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genFencesAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("isFenceAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isFenceAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("setFenceAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(setFenceAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("testFenceAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(testFenceAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("testObjectAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(testObjectAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferParameteriAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferParameteriAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("flushMappedBufferRangeAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flushMappedBufferRangeAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorageMultisampleAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorageMultisampleAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("resolveMultisampleFramebufferAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resolveMultisampleFramebufferAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectParameterivAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectParameterivAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("objectPurgeableAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(objectPurgeableAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("objectUnpurgeableAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(objectUnpurgeableAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInteger64vAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInteger64vAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameterPointervAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameterPointervAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureRangeAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureRangeAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindVertexArrayAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindVertexArrayAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteVertexArraysAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteVertexArraysAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("genVertexArraysAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genVertexArraysAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("isVertexArrayAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isVertexArrayAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("flushVertexArrayRangeAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flushVertexArrayRangeAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayParameteriAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayParameteriAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayRangeAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayRangeAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableVertexAttribAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableVertexAttribAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableVertexAttribAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableVertexAttribAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("isVertexAttribEnabledAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isVertexAttribEnabledAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapVertexAttrib1dAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapVertexAttrib1dAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapVertexAttrib1fAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapVertexAttrib1fAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapVertexAttrib2dAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapVertexAttrib2dAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapVertexAttrib2fAPPLE").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapVertexAttrib2fAPPLE)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearDepthf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearDepthf)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRangef").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRangef)).ToLocalChecked());
  Nan::Set(target, Nan::New("getShaderPrecisionFormat").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getShaderPrecisionFormat)).ToLocalChecked());
  Nan::Set(target, Nan::New("releaseShaderCompiler").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(releaseShaderCompiler)).ToLocalChecked());
  Nan::Set(target, Nan::New("shaderBinary").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shaderBinary)).ToLocalChecked());
  Nan::Set(target, Nan::New("memoryBarrierByRegion").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(memoryBarrierByRegion)).ToLocalChecked());
  Nan::Set(target, Nan::New("primitiveBoundingBoxARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(primitiveBoundingBoxARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysInstancedBaseInstance").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysInstancedBaseInstance)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedBaseInstance").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedBaseInstance)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedBaseVertexBaseInstance").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedBaseVertexBaseInstance)).ToLocalChecked());
  Nan::Set(target, Nan::New("getImageHandleARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getImageHandleARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureHandleARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureHandleARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureSamplerHandleARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureSamplerHandleARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribLui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribLui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("isImageHandleResidentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isImageHandleResidentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("isTextureHandleResidentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isTextureHandleResidentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeImageHandleNonResidentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeImageHandleNonResidentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeImageHandleResidentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeImageHandleResidentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeTextureHandleNonResidentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeTextureHandleNonResidentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeTextureHandleResidentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeTextureHandleResidentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformHandleui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformHandleui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformHandleui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformHandleui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformHandleui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformHandleui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformHandleui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformHandleui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindFragDataLocationIndexed").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindFragDataLocationIndexed)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragDataIndex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragDataIndex)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferStorage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferStorage)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearBufferData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearBufferData)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedBufferDataEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedBufferDataEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedBufferSubDataEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedBufferSubDataEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearTexImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearTexImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearTexSubImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearTexSubImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("clipControl").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clipControl)).ToLocalChecked());
  Nan::Set(target, Nan::New("clampColorARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clampColorARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("dispatchCompute").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(dispatchCompute)).ToLocalChecked());
  Nan::Set(target, Nan::New("dispatchComputeIndirect").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(dispatchComputeIndirect)).ToLocalChecked());
  Nan::Set(target, Nan::New("dispatchComputeGroupSizeARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(dispatchComputeGroupSizeARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyImageSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyImageSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("debugMessageControlARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(debugMessageControlARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("debugMessageInsertARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(debugMessageInsertARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getDebugMessageLogARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getDebugMessageLogARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTextureUnit").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTextureUnit)).ToLocalChecked());
  Nan::Set(target, Nan::New("blitNamedFramebuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blitNamedFramebuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("checkNamedFramebufferStatus").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(checkNamedFramebufferStatus)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedBufferData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedBufferData)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedFramebufferfi").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedFramebufferfi)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedFramebufferfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedFramebufferfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedFramebufferiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedFramebufferiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearNamedFramebufferuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearNamedFramebufferuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTextureSubImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTextureSubImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTextureSubImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTextureSubImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTextureSubImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTextureSubImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyNamedBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyNamedBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTextureSubImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTextureSubImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTextureSubImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTextureSubImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTextureSubImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTextureSubImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("createBuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createBuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("createFramebuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createFramebuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("createProgramPipelines").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createProgramPipelines)).ToLocalChecked());
  Nan::Set(target, Nan::New("createQueries").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createQueries)).ToLocalChecked());
  Nan::Set(target, Nan::New("createRenderbuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createRenderbuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("createSamplers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createSamplers)).ToLocalChecked());
  Nan::Set(target, Nan::New("createTextures").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createTextures)).ToLocalChecked());
  Nan::Set(target, Nan::New("createTransformFeedbacks").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createTransformFeedbacks)).ToLocalChecked());
  Nan::Set(target, Nan::New("createVertexArrays").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createVertexArrays)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableVertexArrayAttrib").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableVertexArrayAttrib)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableVertexArrayAttrib").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableVertexArrayAttrib)).ToLocalChecked());
  Nan::Set(target, Nan::New("flushMappedNamedBufferRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flushMappedNamedBufferRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("generateTextureMipmap").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(generateTextureMipmap)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCompressedTextureImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCompressedTextureImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedBufferParameteri64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedBufferParameteri64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedBufferParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedBufferParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedBufferPointerv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedBufferPointerv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedFramebufferAttachmentParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedFramebufferAttachmentParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedFramebufferParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedFramebufferParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedRenderbufferParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedRenderbufferParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryBufferObjecti64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryBufferObjecti64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryBufferObjectiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryBufferObjectiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryBufferObjectui64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryBufferObjectui64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryBufferObjectuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryBufferObjectuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureLevelParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureLevelParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureLevelParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureLevelParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureParameterIiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureParameterIiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureParameterIuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureParameterIuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTransformFeedbacki64_v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTransformFeedbacki64_v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTransformFeedbacki_v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTransformFeedbacki_v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTransformFeedbackiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTransformFeedbackiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexArrayIndexed64iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexArrayIndexed64iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexArrayIndexediv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexArrayIndexediv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexArrayiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexArrayiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateNamedFramebufferData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateNamedFramebufferData)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateNamedFramebufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateNamedFramebufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedBufferData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedBufferData)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedBufferStorage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedBufferStorage)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferDrawBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferDrawBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferDrawBuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferDrawBuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferReadBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferReadBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferRenderbuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferRenderbuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTexture").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTexture)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTextureLayer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTextureLayer)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedRenderbufferStorage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedRenderbufferStorage)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedRenderbufferStorageMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedRenderbufferStorageMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureBufferRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureBufferRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterIiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterIiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterIuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterIuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterf)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage2DMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage2DMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage3DMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage3DMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureSubImage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureSubImage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureSubImage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureSubImage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureSubImage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureSubImage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("transformFeedbackBufferBase").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(transformFeedbackBufferBase)).ToLocalChecked());
  Nan::Set(target, Nan::New("transformFeedbackBufferRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(transformFeedbackBufferRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("unmapNamedBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(unmapNamedBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayAttribBinding").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayAttribBinding)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayAttribFormat").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayAttribFormat)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayAttribIFormat").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayAttribIFormat)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayAttribLFormat").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayAttribLFormat)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayBindingDivisor").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayBindingDivisor)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayElementBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayElementBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexBuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexBuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBuffersARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBuffersARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationSeparateiARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationSeparateiARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationiARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationiARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFuncSeparateiARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFuncSeparateiARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFunciARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFunciARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsBaseVertex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsBaseVertex)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedBaseVertex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedBaseVertex)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawRangeElementsBaseVertex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawRangeElementsBaseVertex)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsBaseVertex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsBaseVertex)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysIndirect").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysIndirect)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsIndirect").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsIndirect)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFramebufferParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFramebufferParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedFramebufferParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedFramebufferParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferParameteriEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferParameteriEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindFramebuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindFramebuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindRenderbuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindRenderbuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("blitFramebuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blitFramebuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("checkFramebufferStatus").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(checkFramebufferStatus)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteFramebuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteFramebuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteRenderbuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteRenderbuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferRenderbuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferRenderbuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureLayer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureLayer)).ToLocalChecked());
  Nan::Set(target, Nan::New("genFramebuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genFramebuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("genRenderbuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genRenderbuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("generateMipmap").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(generateMipmap)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFramebufferAttachmentParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFramebufferAttachmentParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getRenderbufferParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getRenderbufferParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("isFramebuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isFramebuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("isRenderbuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isRenderbuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorage)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorageMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorageMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureFaceARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureFaceARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureLayerARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureLayerARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameteriARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameteriARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramBinary").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramBinary)).ToLocalChecked());
  Nan::Set(target, Nan::New("programBinary").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programBinary)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCompressedTextureSubImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCompressedTextureSubImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureSubImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureSubImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("specializeShaderARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(specializeShaderARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformdv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformdv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2x3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2x3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2x4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2x4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3x2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3x2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3x4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3x4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4x2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4x2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4x3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4x3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformi64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformi64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformi64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformi64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4i64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4i64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4i64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4i64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4ui64ARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4ui64ARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4ui64vARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4ui64vARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorSubTable").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorSubTable)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorTable").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorTable)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorTableParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorTableParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorTableParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorTableParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionFilter1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionFilter1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionFilter2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionFilter2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameterf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameterf)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyColorSubTable").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyColorSubTable)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyColorTable").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyColorTable)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyConvolutionFilter1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyConvolutionFilter1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyConvolutionFilter2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyConvolutionFilter2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("getColorTable").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getColorTable)).ToLocalChecked());
  Nan::Set(target, Nan::New("getColorTableParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getColorTableParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getColorTableParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getColorTableParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getConvolutionFilter").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getConvolutionFilter)).ToLocalChecked());
  Nan::Set(target, Nan::New("getConvolutionParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getConvolutionParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getConvolutionParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getConvolutionParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getHistogram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getHistogram)).ToLocalChecked());
  Nan::Set(target, Nan::New("getHistogramParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getHistogramParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getHistogramParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getHistogramParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMinmax").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMinmax)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMinmaxParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMinmaxParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMinmaxParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMinmaxParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSeparableFilter").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSeparableFilter)).ToLocalChecked());
  Nan::Set(target, Nan::New("histogram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(histogram)).ToLocalChecked());
  Nan::Set(target, Nan::New("minmax").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(minmax)).ToLocalChecked());
  Nan::Set(target, Nan::New("resetHistogram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resetHistogram)).ToLocalChecked());
  Nan::Set(target, Nan::New("resetMinmax").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resetMinmax)).ToLocalChecked());
  Nan::Set(target, Nan::New("separableFilter2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(separableFilter2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysIndirectCountARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysIndirectCountARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsIndirectCountARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsIndirectCountARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysInstancedARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysInstancedARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribDivisorARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribDivisorARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInternalformativ").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInternalformativ)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInternalformati64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInternalformati64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateBufferData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateBufferData)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateBufferSubData").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateBufferSubData)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateFramebuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateFramebuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateSubFramebuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateSubFramebuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateTexImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateTexImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("invalidateTexSubImage").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(invalidateTexSubImage)).ToLocalChecked());
  Nan::Set(target, Nan::New("flushMappedBufferRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flushMappedBufferRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("currentPaletteMatrixARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(currentPaletteMatrixARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixIndexPointerARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixIndexPointerARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixIndexubvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixIndexubvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixIndexuivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixIndexuivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixIndexusvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixIndexusvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBuffersBase").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBuffersBase)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBuffersRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBuffersRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindImageTextures").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindImageTextures)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindSamplers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindSamplers)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTextures").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTextures)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindVertexBuffers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindVertexBuffers)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysIndirect").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysIndirect)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsIndirect").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsIndirect)).ToLocalChecked());
  Nan::Set(target, Nan::New("sampleCoverageARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(sampleCoverageARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("activeTextureARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(activeTextureARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("clientActiveTextureARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clientActiveTextureARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord1svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord1svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord2svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord2svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord3svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord3svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginQueryARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginQueryARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteQueriesARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteQueriesARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("endQueryARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endQueryARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("genQueriesARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genQueriesARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectuivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectuivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("isQueryARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isQueryARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("maxShaderCompilerThreadsARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(maxShaderCompilerThreadsARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterfARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterfARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonOffsetClamp").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonOffsetClamp)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramInterfaceiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramInterfaceiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramResourceIndex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramResourceIndex)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramResourceLocation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramResourceLocation)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramResourceLocationIndex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramResourceLocationIndex)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramResourceName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramResourceName)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramResourceiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramResourceiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("provokingVertex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(provokingVertex)).ToLocalChecked());
  Nan::Set(target, Nan::New("getGraphicsResetStatusARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getGraphicsResetStatusARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnColorTableARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnColorTableARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnCompressedTexImageARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnCompressedTexImageARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnConvolutionFilterARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnConvolutionFilterARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnHistogramARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnHistogramARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnMapdvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnMapdvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnMapfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnMapfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnMapivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnMapivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnMinmaxARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnMinmaxARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnPixelMapfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnPixelMapfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnPixelMapuivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnPixelMapuivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnPixelMapusvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnPixelMapusvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnPolygonStippleARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnPolygonStippleARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnSeparableFilterARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnSeparableFilterARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnTexImageARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnTexImageARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformdvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformdvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformuivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformuivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("readnPixelsARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(readnPixelsARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferSampleLocationsfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferSampleLocationsfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferSampleLocationsfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferSampleLocationsfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("minSampleShadingARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(minSampleShadingARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindSampler").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindSampler)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteSamplers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteSamplers)).ToLocalChecked());
  Nan::Set(target, Nan::New("genSamplers").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genSamplers)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSamplerParameterIiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSamplerParameterIiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSamplerParameterIuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSamplerParameterIuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSamplerParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSamplerParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSamplerParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSamplerParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("isSampler").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isSampler)).ToLocalChecked());
  Nan::Set(target, Nan::New("samplerParameterIiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(samplerParameterIiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("samplerParameterIuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(samplerParameterIuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("samplerParameterf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(samplerParameterf)).ToLocalChecked());
  Nan::Set(target, Nan::New("samplerParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(samplerParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("samplerParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(samplerParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("samplerParameteriv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(samplerParameteriv)).ToLocalChecked());
  Nan::Set(target, Nan::New("activeShaderProgram").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(activeShaderProgram)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindProgramPipeline").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindProgramPipeline)).ToLocalChecked());
  Nan::Set(target, Nan::New("createShaderProgramv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createShaderProgramv)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteProgramPipelines").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteProgramPipelines)).ToLocalChecked());
  Nan::Set(target, Nan::New("genProgramPipelines").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genProgramPipelines)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramPipelineInfoLog").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramPipelineInfoLog)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramPipelineiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramPipelineiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("isProgramPipeline").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isProgramPipeline)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1f)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1i)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2f)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2i)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3f)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3i)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4f").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4f)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4i").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4i)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4iv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4iv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2x3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2x3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2x3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2x3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2x4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2x4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2x4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2x4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3x2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3x2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3x2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3x2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3x4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3x4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3x4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3x4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4x2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4x2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4x2fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4x2fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4x3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4x3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4x3fv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4x3fv)).ToLocalChecked());
  Nan::Set(target, Nan::New("useProgramStages").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(useProgramStages)).ToLocalChecked());
  Nan::Set(target, Nan::New("validateProgramPipeline").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(validateProgramPipeline)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveAtomicCounterBufferiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveAtomicCounterBufferiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindImageTexture").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindImageTexture)).ToLocalChecked());
  Nan::Set(target, Nan::New("memoryBarrier").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(memoryBarrier)).ToLocalChecked());
  Nan::Set(target, Nan::New("attachObjectARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(attachObjectARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("compileShaderARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compileShaderARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("createProgramObjectARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createProgramObjectARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("createShaderObjectARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createShaderObjectARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteObjectARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteObjectARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("detachObjectARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(detachObjectARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveUniformARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveUniformARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getAttachedObjectsARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getAttachedObjectsARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getHandleARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getHandleARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInfoLogARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInfoLogARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectParameterfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectParameterfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectParameterivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectParameterivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getShaderSourceARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getShaderSourceARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformLocationARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformLocationARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("linkProgramARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(linkProgramARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("shaderSourceARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shaderSourceARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("useProgramObjectARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(useProgramObjectARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("validateProgramARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(validateProgramARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("shaderStorageBlockBinding").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shaderStorageBlockBinding)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveSubroutineName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveSubroutineName)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveSubroutineUniformName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveSubroutineUniformName)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveSubroutineUniformiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveSubroutineUniformiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramStageiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramStageiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSubroutineIndex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSubroutineIndex)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSubroutineUniformLocation").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSubroutineUniformLocation)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformSubroutineuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformSubroutineuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformSubroutinesuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformSubroutinesuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("compileShaderIncludeARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compileShaderIncludeARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteNamedStringARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteNamedStringARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedStringARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedStringARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedStringivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedStringivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("isNamedStringARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isNamedStringARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedStringARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedStringARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferPageCommitmentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferPageCommitmentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("texPageCommitmentARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texPageCommitmentARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInteger64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInteger64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("patchParameterfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(patchParameterfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("patchParameteri").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(patchParameteri)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureBarrier").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureBarrier)).ToLocalChecked());
  Nan::Set(target, Nan::New("texBufferARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texBufferARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("texBufferRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texBufferRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureBufferRangeEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureBufferRangeEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexImage1DARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexImage1DARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexImage2DARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexImage2DARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexImage3DARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexImage3DARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexSubImage1DARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexSubImage1DARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexSubImage2DARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexSubImage2DARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexSubImage3DARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexSubImage3DARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCompressedTexImageARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCompressedTexImageARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMultisamplefv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMultisamplefv)).ToLocalChecked());
  Nan::Set(target, Nan::New("sampleMaski").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(sampleMaski)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage2DMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage2DMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage3DMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage3DMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage1D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage1D)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage2D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage2D)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage3D").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage3D)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage2DMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage2DMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage3DMultisample").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage3DMultisample)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage2DMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage2DMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage3DMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage3DMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureView").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureView)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjecti64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjecti64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectui64v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectui64v)).ToLocalChecked());
  Nan::Set(target, Nan::New("queryCounter").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(queryCounter)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTransformFeedback").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTransformFeedback)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteTransformFeedbacks").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteTransformFeedbacks)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawTransformFeedback").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawTransformFeedback)).ToLocalChecked());
  Nan::Set(target, Nan::New("genTransformFeedbacks").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genTransformFeedbacks)).ToLocalChecked());
  Nan::Set(target, Nan::New("isTransformFeedback").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isTransformFeedback)).ToLocalChecked());
  Nan::Set(target, Nan::New("pauseTransformFeedback").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pauseTransformFeedback)).ToLocalChecked());
  Nan::Set(target, Nan::New("resumeTransformFeedback").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resumeTransformFeedback)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginQueryIndexed").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginQueryIndexed)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawTransformFeedbackStream").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawTransformFeedbackStream)).ToLocalChecked());
  Nan::Set(target, Nan::New("endQueryIndexed").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endQueryIndexed)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryIndexediv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryIndexediv)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawTransformFeedbackInstanced").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawTransformFeedbackInstanced)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawTransformFeedbackStreamInstanced").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawTransformFeedbackStreamInstanced)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferBase").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferBase)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferRange").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferRange)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveUniformBlockName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveUniformBlockName)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveUniformBlockiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveUniformBlockiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveUniformName").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveUniformName)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveUniformsiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveUniformsiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getIntegeri_v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getIntegeri_v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformBlockIndex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformBlockIndex)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformIndices").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformIndices)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformBlockBinding").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformBlockBinding)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindVertexArray").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindVertexArray)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteVertexArrays").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteVertexArrays)).ToLocalChecked());
  Nan::Set(target, Nan::New("genVertexArrays").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genVertexArrays)).ToLocalChecked());
  Nan::Set(target, Nan::New("isVertexArray").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isVertexArray)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribLdv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribLdv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4d").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4d)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4dv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4dv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribLPointer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribLPointer)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindVertexBuffer").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindVertexBuffer)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayBindVertexBufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayBindVertexBufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribBindingEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribBindingEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribFormatEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribFormatEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribIFormatEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribIFormatEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribLFormatEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribLFormatEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexBindingDivisorEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexBindingDivisorEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribBinding").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribBinding)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribFormat").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribFormat)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribIFormat").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribIFormat)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribLFormat").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribLFormat)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexBindingDivisor").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexBindingDivisor)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexBlendARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexBlendARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightPointerARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightPointerARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightbvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightbvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightdvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightdvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightsvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightsvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightubvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightubvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightuivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightuivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("weightusvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(weightusvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferDataARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferDataARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferSubDataARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferSubDataARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteBuffersARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteBuffersARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("genBuffersARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genBuffersARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferParameterivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferParameterivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferPointervARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferPointervARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferSubDataARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferSubDataARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("isBufferARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isBufferARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("unmapBufferARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(unmapBufferARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindProgramARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindProgramARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteProgramsARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteProgramsARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableVertexAttribArrayARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableVertexAttribArrayARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableVertexAttribArrayARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableVertexAttribArrayARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("genProgramsARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genProgramsARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramEnvParameterdvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramEnvParameterdvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramEnvParameterfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramEnvParameterfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramLocalParameterdvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramLocalParameterdvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramLocalParameterfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramLocalParameterfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramStringARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramStringARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribPointervARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribPointervARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribdvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribdvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribfvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribfvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("isProgramARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isProgramARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameter4dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameter4dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameter4dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameter4dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameter4fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameter4fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameter4fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameter4fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameter4dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameter4dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameter4dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameter4dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameter4fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameter4fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameter4fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameter4fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("programStringARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programStringARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4NbvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4NbvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4NivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4NivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4NsvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4NsvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4NubARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4NubARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4NubvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4NubvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4NuivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4NuivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4NusvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4NusvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4bvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4bvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4ubvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4ubvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4uivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4uivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4usvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4usvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribPointerARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribPointerARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindAttribLocationARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindAttribLocationARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveAttribARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveAttribARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("getAttribLocationARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getAttribLocationARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorP3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorP3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorP3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorP3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorP4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorP4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorP4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorP4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP1ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP1ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP1uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP1uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP2ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP2ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP2uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP2uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoordP4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoordP4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalP3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalP3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalP3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalP3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColorP3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColorP3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColorP3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColorP3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP1ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP1ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP1uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP1uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP2ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP2ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP2uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP2uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordP4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordP4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP1ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP1ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP1uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP1uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP2ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP2ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP2uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP2uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribP4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribP4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexP2ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexP2ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexP2uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexP2uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexP3ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexP3ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexP3uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexP3uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexP4ui").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexP4ui)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexP4uiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexP4uiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRangeArrayv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRangeArrayv)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRangeIndexed").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRangeIndexed)).ToLocalChecked());
  Nan::Set(target, Nan::New("getDoublei_v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getDoublei_v)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFloati_v").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFloati_v)).ToLocalChecked());
  Nan::Set(target, Nan::New("scissorArrayv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scissorArrayv)).ToLocalChecked());
  Nan::Set(target, Nan::New("scissorIndexed").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scissorIndexed)).ToLocalChecked());
  Nan::Set(target, Nan::New("scissorIndexedv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scissorIndexedv)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportArrayv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportArrayv)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportIndexedf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportIndexedf)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportIndexedfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportIndexedfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3dARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3dARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3dvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3dvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3fARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3fARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3fvARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3fvARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3iARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3iARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3ivARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3ivARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3sARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3sARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3svARB").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3svARB)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBuffersATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBuffersATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementArrayATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementArrayATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawRangeElementArrayATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawRangeElementArrayATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("elementPointerATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(elementPointerATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexBumpParameterfvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexBumpParameterfvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexBumpParameterivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexBumpParameterivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("texBumpParameterfvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texBumpParameterfvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("texBumpParameterivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texBumpParameterivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("alphaFragmentOp1ATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(alphaFragmentOp1ATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("alphaFragmentOp2ATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(alphaFragmentOp2ATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("alphaFragmentOp3ATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(alphaFragmentOp3ATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginFragmentShaderATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginFragmentShaderATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindFragmentShaderATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindFragmentShaderATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorFragmentOp1ATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorFragmentOp1ATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorFragmentOp2ATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorFragmentOp2ATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorFragmentOp3ATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorFragmentOp3ATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteFragmentShaderATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteFragmentShaderATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("endFragmentShaderATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endFragmentShaderATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("genFragmentShadersATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genFragmentShadersATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("passTexCoordATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(passTexCoordATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("sampleMapATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(sampleMapATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("setFragmentShaderConstantATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(setFragmentShaderConstantATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("unmapObjectBufferATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(unmapObjectBufferATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("pNTrianglesfATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pNTrianglesfATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("pNTrianglesiATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pNTrianglesiATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilFuncSeparateATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilFuncSeparateATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilOpSeparateATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilOpSeparateATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("arrayObjectATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(arrayObjectATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("freeObjectBufferATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(freeObjectBufferATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getArrayObjectfvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getArrayObjectfvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getArrayObjectivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getArrayObjectivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectBufferfvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectBufferfvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectBufferivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectBufferivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVariantArrayObjectfvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVariantArrayObjectfvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVariantArrayObjectivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVariantArrayObjectivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("isObjectBufferATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isObjectBufferATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("newObjectBufferATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(newObjectBufferATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("updateObjectBufferATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(updateObjectBufferATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantArrayObjectATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantArrayObjectATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribArrayObjectfvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribArrayObjectfvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribArrayObjectivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribArrayObjectivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribArrayObjectATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribArrayObjectATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("clientActiveVertexStreamATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clientActiveVertexStreamATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3bATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3bATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3bvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3bvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3dATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3dATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3dvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3dvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3fATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3fATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3fvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3fvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3iATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3iATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3ivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3ivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3sATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3sATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalStream3svATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalStream3svATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexBlendEnvfATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexBlendEnvfATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexBlendEnviATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexBlendEnviATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1dATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1dATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1dvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1dvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1fATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1fATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1fvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1fvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1iATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1iATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1ivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1ivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1sATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1sATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream1svATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream1svATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2dATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2dATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2dvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2dvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2fATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2fATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2fvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2fvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2iATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2iATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2ivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2ivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2sATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2sATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream2svATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream2svATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3dATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3dATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3dvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3dvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3fATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3fATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3fvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3fvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3iATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3iATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3ivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3ivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3sATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3sATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream3svATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream3svATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4dATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4dATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4dvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4dvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4fATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4fATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4fvATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4fvATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4iATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4iATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4ivATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4ivATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4sATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4sATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexStream4svATI").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexStream4svATI)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysInstancedBaseInstanceEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysInstancedBaseInstanceEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedBaseInstanceEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedBaseInstanceEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedBaseVertexBaseInstanceEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedBaseVertexBaseInstanceEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformBufferSizeEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformBufferSizeEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformBufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformBufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendColorEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendColorEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationSeparateEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationSeparateEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindFragDataLocationIndexedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindFragDataLocationIndexedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragDataIndexEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragDataIndexEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramResourceLocationIndexEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramResourceLocationIndexEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFuncSeparateEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFuncSeparateEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferStorageEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferStorageEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedBufferStorageEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedBufferStorageEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearTexImageEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearTexImageEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearTexSubImageEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearTexSubImageEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorSubTableEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorSubTableEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyColorSubTableEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyColorSubTableEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("lockArraysEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lockArraysEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("unlockArraysEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(unlockArraysEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionFilter1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionFilter1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionFilter2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionFilter2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameterfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameterfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameteriEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameteriEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("convolutionParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(convolutionParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyConvolutionFilter1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyConvolutionFilter1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyConvolutionFilter2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyConvolutionFilter2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getConvolutionFilterEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getConvolutionFilterEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getConvolutionParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getConvolutionParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getConvolutionParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getConvolutionParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSeparableFilterEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSeparableFilterEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("separableFilter2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(separableFilter2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("binormalPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(binormalPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("tangentPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(tangentPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyImageSubDataEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyImageSubDataEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexImage1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexImage1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexImage2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexImage2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexSubImage1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexSubImage1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexSubImage2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexSubImage2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexSubImage3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexSubImage3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("cullParameterdvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(cullParameterdvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("cullParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(cullParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectLabelEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectLabelEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("labelObjectEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(labelObjectEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("insertEventMarkerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(insertEventMarkerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("popGroupMarkerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(popGroupMarkerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pushGroupMarkerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pushGroupMarkerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthBoundsEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthBoundsEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTexture1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTexture1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTexture2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTexture2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTexture3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTexture3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTextureEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTextureEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTextureFaceEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTextureFaceEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferTextureLayerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferTextureLayerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameter4dEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameter4dEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameter4dvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameter4dvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameter4fEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameter4fEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameter4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameter4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameterI4iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameterI4iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameterI4ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameterI4ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameterI4uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameterI4uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameterI4uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameterI4uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParameters4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParameters4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParametersI4ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParametersI4ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramLocalParametersI4uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramLocalParametersI4uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedProgramStringEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedProgramStringEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedRenderbufferStorageEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedRenderbufferStorageEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedRenderbufferStorageMultisampleCoverageEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedRenderbufferStorageMultisampleCoverageEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedRenderbufferStorageMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedRenderbufferStorageMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1fEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1fEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2fEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2fEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3fEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3fEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4fEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4fEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2x3fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2x3fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix2x4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix2x4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3x2fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3x2fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix3x4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix3x4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4x2fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4x2fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformMatrix4x3fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformMatrix4x3fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pushClientAttribDefaultEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pushClientAttribDefaultEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureBufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureBufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureImage1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureImage1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureImage2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureImage2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureImage3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureImage3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterIivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterIivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterIuivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterIuivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameteriEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameteriEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureRenderbufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureRenderbufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureSubImage1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureSubImage1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureSubImage2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureSubImage2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureSubImage3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureSubImage3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("unmapNamedBufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(unmapNamedBufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayColorOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayColorOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayEdgeFlagOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayEdgeFlagOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayFogCoordOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayFogCoordOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayIndexOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayIndexOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayMultiTexCoordOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayMultiTexCoordOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayNormalOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayNormalOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArraySecondaryColorOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArraySecondaryColorOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayTexCoordOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayTexCoordOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribDivisorEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribDivisorEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribIOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribIOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("discardFramebufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(discardFramebufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBuffersEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBuffersEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorMaskIndexedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorMaskIndexedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableIndexedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableIndexedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableIndexedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableIndexedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBooleanIndexedvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBooleanIndexedvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getIntegerIndexedvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getIntegerIndexedvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isEnabledIndexedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isEnabledIndexedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationSeparateiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationSeparateiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendEquationiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendEquationiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFuncSeparateiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFuncSeparateiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendFunciEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendFunciEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorMaskiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorMaskiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isEnablediEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isEnablediEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsBaseVertexEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsBaseVertexEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedBaseVertexEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedBaseVertexEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawRangeElementsBaseVertexEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawRangeElementsBaseVertexEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsBaseVertexEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsBaseVertexEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysInstancedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysInstancedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawRangeElementsEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawRangeElementsEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoorddEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoorddEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoorddvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoorddvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentColorMaterialEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentColorMaterialEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightModelfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightModelfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightModelfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightModelfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightModeliEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightModeliEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightModelivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightModelivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentLightivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentLightivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentMaterialfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentMaterialfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentMaterialfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentMaterialfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentMaterialiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentMaterialiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentMaterialivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentMaterialivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragmentLightfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragmentLightfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragmentLightivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragmentLightivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragmentMaterialfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragmentMaterialfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragmentMaterialivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragmentMaterialivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightEnviEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightEnviEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("blitFramebufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blitFramebufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorageMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorageMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindFramebufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindFramebufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindRenderbufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindRenderbufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("checkFramebufferStatusEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(checkFramebufferStatusEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteFramebuffersEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteFramebuffersEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteRenderbuffersEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteRenderbuffersEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferRenderbufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferRenderbufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("genFramebuffersEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genFramebuffersEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("genRenderbuffersEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genRenderbuffersEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("generateMipmapEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(generateMipmapEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFramebufferAttachmentParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFramebufferAttachmentParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getRenderbufferParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getRenderbufferParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isFramebufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isFramebufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isRenderbufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isRenderbufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorageEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorageEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureFaceEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureFaceEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameteriEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameteriEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameters4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameters4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameters4fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameters4fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindFragDataLocationEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindFragDataLocationEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFragDataLocationEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFragDataLocationEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformuivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformuivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribIivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribIivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribIuivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribIuivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI1uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI1uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI2uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI2uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI3uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI3uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4bvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4bvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4svEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4svEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4ubvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4ubvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribI4usvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribI4usvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribIPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribIPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getHistogramEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getHistogramEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getHistogramParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getHistogramParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getHistogramParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getHistogramParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMinmaxEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMinmaxEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMinmaxParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMinmaxParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMinmaxParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMinmaxParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("histogramEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(histogramEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("minmaxEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(minmaxEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("resetHistogramEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resetHistogramEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("resetMinmaxEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resetMinmaxEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexFuncEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexFuncEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexMaterialEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexMaterialEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribDivisorEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribDivisorEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("applyTextureEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(applyTextureEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureLightEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureLightEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureMaterialEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureMaterialEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("flushMappedBufferRangeEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flushMappedBufferRangeEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferStorageMemEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferStorageMemEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("createMemoryObjectsEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createMemoryObjectsEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteMemoryObjectsEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteMemoryObjectsEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMemoryObjectParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMemoryObjectParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUnsignedBytei_vEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUnsignedBytei_vEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUnsignedBytevEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUnsignedBytevEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isMemoryObjectEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isMemoryObjectEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("memoryObjectParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(memoryObjectParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedBufferStorageMemEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedBufferStorageMemEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorageMem1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorageMem1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorageMem2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorageMem2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorageMem2DMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorageMem2DMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorageMem3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorageMem3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorageMem3DMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorageMem3DMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorageMem1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorageMem1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorageMem2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorageMem2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorageMem2DMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorageMem2DMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorageMem3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorageMem3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorageMem3DMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorageMem3DMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("importMemoryFdEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(importMemoryFdEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("importMemoryWin32HandleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(importMemoryWin32HandleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("importMemoryWin32NameEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(importMemoryWin32NameEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysIndirectEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysIndirectEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsIndirectEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsIndirectEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("sampleMaskEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(sampleMaskEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("samplePatternEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(samplePatternEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTexture2DMultisampleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTexture2DMultisampleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBuffersIndexedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBuffersIndexedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getIntegeri_vEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getIntegeri_vEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("readBufferIndexedEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(readBufferIndexedEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorTableEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorTableEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getColorTableEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getColorTableEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getColorTableParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getColorTableParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getColorTableParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getColorTableParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPixelTransformParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPixelTransformParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPixelTransformParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPixelTransformParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelTransformParameterfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelTransformParameterfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelTransformParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelTransformParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelTransformParameteriEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelTransformParameteriEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelTransformParameterivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelTransformParameterivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonOffsetClampEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonOffsetClampEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("provokingVertexEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(provokingVertexEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("coverageModulationNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(coverageModulationNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("coverageModulationTableNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(coverageModulationTableNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCoverageModulationTableNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCoverageModulationTableNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("rasterSamplesEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rasterSamplesEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginSceneEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginSceneEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("endSceneEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endSceneEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3bEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3bEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3bvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3bvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3dEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3dEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3dvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3dvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3fEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3fEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3fvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3fvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3iEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3iEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3ivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3ivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3sEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3sEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3svEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3svEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3ubEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3ubEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3ubvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3ubvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3uiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3uiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3uivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3uivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3usEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3usEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColor3usvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColor3usvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColorPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColorPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteSemaphoresEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteSemaphoresEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("genSemaphoresEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genSemaphoresEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getSemaphoreParameterui64vEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getSemaphoreParameterui64vEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isSemaphoreEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isSemaphoreEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("semaphoreParameterui64vEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(semaphoreParameterui64vEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("signalSemaphoreEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(signalSemaphoreEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("waitSemaphoreEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(waitSemaphoreEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("importSemaphoreFdEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(importSemaphoreFdEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("importSemaphoreWin32HandleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(importSemaphoreWin32HandleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("importSemaphoreWin32NameEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(importSemaphoreWin32NameEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("activeProgramEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(activeProgramEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("createShaderProgramEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createShaderProgramEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("useShaderProgramEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(useShaderProgramEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindImageTextureEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindImageTextureEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("memoryBarrierEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(memoryBarrierEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearPixelLocalStorageuiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearPixelLocalStorageuiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferPixelLocalStorageSizeEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferPixelLocalStorageSizeEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFramebufferPixelLocalStorageSizeEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFramebufferPixelLocalStorageSizeEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texPageCommitmentEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texPageCommitmentEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texturePageCommitmentEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texturePageCommitmentEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("activeStencilFaceEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(activeStencilFaceEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texSubImage1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texSubImage1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texSubImage2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texSubImage2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texSubImage3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texSubImage3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureLayerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureLayerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texBufferEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texBufferEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearColorIiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearColorIiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearColorIuiEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearColorIuiEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameterIivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameterIivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameterIuivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameterIuivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterIivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterIivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterIuivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterIuivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("areTexturesResidentEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(areTexturesResidentEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTextureEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTextureEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteTexturesEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteTexturesEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("genTexturesEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genTexturesEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isTextureEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isTextureEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("prioritizeTexturesEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(prioritizeTexturesEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureNormalEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureNormalEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texStorage3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texStorage3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage1DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage1DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage2DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage2DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureStorage3DEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureStorage3DEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureViewEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureViewEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjecti64vEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjecti64vEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getQueryObjectui64vEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getQueryObjectui64vEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginTransformFeedbackEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginTransformFeedbackEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferBaseEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferBaseEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferRangeEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferRangeEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("endTransformFeedbackEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endTransformFeedbackEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTransformFeedbackVaryingEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTransformFeedbackVaryingEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("transformFeedbackVaryingsEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(transformFeedbackVaryingsEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("arrayElementEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(arrayElementEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("edgeFlagPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(edgeFlagPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindArraySetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindArraySetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribLdvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribLdvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayVertexAttribLOffsetEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayVertexAttribLOffsetEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1dEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1dEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1dvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1dvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2dEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2dEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2dvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2dvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3dEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3dEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3dvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3dvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4dEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4dEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4dvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4dvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribLPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribLPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginVertexShaderEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginVertexShaderEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindLightParameterEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindLightParameterEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindMaterialParameterEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindMaterialParameterEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindParameterEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindParameterEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTexGenParameterEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTexGenParameterEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTextureUnitParameterEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTextureUnitParameterEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindVertexShaderEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindVertexShaderEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteVertexShaderEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteVertexShaderEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableVariantClientStateEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableVariantClientStateEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableVariantClientStateEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableVariantClientStateEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("endVertexShaderEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endVertexShaderEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("extractComponentEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extractComponentEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("genSymbolsEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genSymbolsEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("genVertexShadersEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genVertexShadersEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInvariantBooleanvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInvariantBooleanvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInvariantFloatvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInvariantFloatvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInvariantIntegervEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInvariantIntegervEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getLocalConstantBooleanvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getLocalConstantBooleanvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getLocalConstantFloatvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getLocalConstantFloatvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getLocalConstantIntegervEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getLocalConstantIntegervEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVariantBooleanvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVariantBooleanvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVariantFloatvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVariantFloatvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVariantIntegervEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVariantIntegervEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVariantPointervEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVariantPointervEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("insertComponentEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(insertComponentEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("isVariantEnabledEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isVariantEnabledEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("setInvariantEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(setInvariantEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("setLocalConstantEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(setLocalConstantEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("shaderOp1EXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shaderOp1EXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("shaderOp2EXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shaderOp2EXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("shaderOp3EXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(shaderOp3EXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("swizzleEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(swizzleEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantbvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantbvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantdvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantdvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantsvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantsvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantubvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantubvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantuivEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantuivEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("variantusvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(variantusvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("writeMaskEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(writeMaskEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexWeightPointerEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexWeightPointerEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexWeightfEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexWeightfEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexWeightfvEXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexWeightfvEXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("acquireKeyedMutexWin32EXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(acquireKeyedMutexWin32EXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("releaseKeyedMutexWin32EXT").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(releaseKeyedMutexWin32EXT)).ToLocalChecked());
  Nan::Set(target, Nan::New("frameTerminatorGREMEDY").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(frameTerminatorGREMEDY)).ToLocalChecked());
  Nan::Set(target, Nan::New("stringMarkerGREMEDY").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stringMarkerGREMEDY)).ToLocalChecked());
  Nan::Set(target, Nan::New("getImageTransformParameterfvHP").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getImageTransformParameterfvHP)).ToLocalChecked());
  Nan::Set(target, Nan::New("getImageTransformParameterivHP").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getImageTransformParameterivHP)).ToLocalChecked());
  Nan::Set(target, Nan::New("imageTransformParameterfHP").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(imageTransformParameterfHP)).ToLocalChecked());
  Nan::Set(target, Nan::New("imageTransformParameterfvHP").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(imageTransformParameterfvHP)).ToLocalChecked());
  Nan::Set(target, Nan::New("imageTransformParameteriHP").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(imageTransformParameteriHP)).ToLocalChecked());
  Nan::Set(target, Nan::New("imageTransformParameterivHP").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(imageTransformParameterivHP)).ToLocalChecked());
  Nan::Set(target, Nan::New("syncTextureINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(syncTextureINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("unmapTexture2DINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(unmapTexture2DINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginPerfQueryINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginPerfQueryINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("createPerfQueryINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createPerfQueryINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("deletePerfQueryINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deletePerfQueryINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("endPerfQueryINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endPerfQueryINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFirstPerfQueryIdINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFirstPerfQueryIdINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNextPerfQueryIdINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNextPerfQueryIdINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfCounterInfoINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfCounterInfoINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfQueryDataINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfQueryDataINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfQueryIdByNameINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfQueryIdByNameINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPerfQueryInfoINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPerfQueryInfoINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("texScissorFuncINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texScissorFuncINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("texScissorINTEL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texScissorINTEL)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendBarrierKHR").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendBarrierKHR)).ToLocalChecked());
  Nan::Set(target, Nan::New("debugMessageControl").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(debugMessageControl)).ToLocalChecked());
  Nan::Set(target, Nan::New("debugMessageInsert").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(debugMessageInsert)).ToLocalChecked());
  Nan::Set(target, Nan::New("getDebugMessageLog").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getDebugMessageLog)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectLabel").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectLabel)).ToLocalChecked());
  Nan::Set(target, Nan::New("getObjectPtrLabel").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getObjectPtrLabel)).ToLocalChecked());
  Nan::Set(target, Nan::New("objectLabel").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(objectLabel)).ToLocalChecked());
  Nan::Set(target, Nan::New("objectPtrLabel").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(objectPtrLabel)).ToLocalChecked());
  Nan::Set(target, Nan::New("popDebugGroup").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(popDebugGroup)).ToLocalChecked());
  Nan::Set(target, Nan::New("pushDebugGroup").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pushDebugGroup)).ToLocalChecked());
  Nan::Set(target, Nan::New("maxShaderCompilerThreadsKHR").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(maxShaderCompilerThreadsKHR)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformfv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformfv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getnUniformuiv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getnUniformuiv)).ToLocalChecked());
  Nan::Set(target, Nan::New("readnPixels").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(readnPixels)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferRegionEnabled").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferRegionEnabled)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteBufferRegion").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteBufferRegion)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBufferRegion").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBufferRegion)).ToLocalChecked());
  Nan::Set(target, Nan::New("newBufferRegion").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(newBufferRegion)).ToLocalChecked());
  Nan::Set(target, Nan::New("readBufferRegion").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(readBufferRegion)).ToLocalChecked());
  Nan::Set(target, Nan::New("resizeBuffersMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resizeBuffersMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2dMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2dMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2dvMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2dvMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2fMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2fMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2fvMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2fvMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2iMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2iMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2ivMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2ivMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2sMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2sMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos2svMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos2svMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3dMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3dMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3dvMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3dvMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3fMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3fMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3fvMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3fvMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3iMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3iMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3ivMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3ivMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3sMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3sMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos3svMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos3svMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos4dvMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos4dvMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos4fMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos4fMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos4fvMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos4fvMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos4iMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos4iMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos4ivMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos4ivMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos4sMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos4sMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("windowPos4svMESA").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(windowPos4svMESA)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginConditionalRenderNVX").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginConditionalRenderNVX)).ToLocalChecked());
  Nan::Set(target, Nan::New("endConditionalRenderNVX").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endConditionalRenderNVX)).ToLocalChecked());
  Nan::Set(target, Nan::New("lGPUCopyImageSubDataNVX").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lGPUCopyImageSubDataNVX)).ToLocalChecked());
  Nan::Set(target, Nan::New("lGPUInterlockNVX").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lGPUInterlockNVX)).ToLocalChecked());
  Nan::Set(target, Nan::New("lGPUNamedBufferSubDataNVX").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lGPUNamedBufferSubDataNVX)).ToLocalChecked());
  Nan::Set(target, Nan::New("stereoParameterfNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stereoParameterfNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stereoParameteriNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stereoParameteriNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysIndirectBindlessNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysIndirectBindlessNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsIndirectBindlessNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsIndirectBindlessNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawArraysIndirectBindlessCountNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawArraysIndirectBindlessCountNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiDrawElementsIndirectBindlessCountNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiDrawElementsIndirectBindlessCountNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getImageHandleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getImageHandleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureHandleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureHandleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTextureSamplerHandleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTextureSamplerHandleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isImageHandleResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isImageHandleResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isTextureHandleResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isTextureHandleResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeImageHandleNonResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeImageHandleNonResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeImageHandleResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeImageHandleResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeTextureHandleNonResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeTextureHandleNonResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeTextureHandleResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeTextureHandleResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformHandleui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformHandleui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformHandleui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformHandleui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformHandleui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformHandleui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformHandleui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformHandleui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendBarrierNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendBarrierNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("blendParameteriNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blendParameteriNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportPositionWScaleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportPositionWScaleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("callCommandListNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(callCommandListNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("commandListSegmentsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(commandListSegmentsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("compileCommandListNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compileCommandListNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("createCommandListsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createCommandListsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("createStatesNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(createStatesNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteCommandListsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteCommandListsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteStatesNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteStatesNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawCommandsAddressNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawCommandsAddressNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawCommandsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawCommandsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawCommandsStatesAddressNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawCommandsStatesAddressNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawCommandsStatesNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawCommandsStatesNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCommandHeaderNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCommandHeaderNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getStageIndexNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getStageIndexNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isCommandListNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isCommandListNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isStateNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isStateNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("listDrawCommandsStatesClientNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(listDrawCommandsStatesClientNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stateCaptureNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stateCaptureNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginConditionalRenderNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginConditionalRenderNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("endConditionalRenderNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endConditionalRenderNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("subpixelPrecisionBiasNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(subpixelPrecisionBiasNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("conservativeRasterParameterfNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(conservativeRasterParameterfNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("conservativeRasterParameteriNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(conservativeRasterParameteriNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyBufferSubDataNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyBufferSubDataNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyImageSubDataNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyImageSubDataNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearDepthdNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearDepthdNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthBoundsdNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthBoundsdNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRangedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRangedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawBuffersNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawBuffersNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawArraysInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawArraysInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawElementsInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawElementsInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawTextureNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawTextureNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawVkImageNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawVkImageNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("signalVkFenceNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(signalVkFenceNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("signalVkSemaphoreNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(signalVkSemaphoreNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("waitVkSemaphoreNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(waitVkSemaphoreNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("evalMapsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(evalMapsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapAttribParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapAttribParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapAttribParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapAttribParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapControlPointsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapControlPointsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMapParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMapParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapControlPointsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapControlPointsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("mapParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mapParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMultisamplefvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMultisamplefvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("sampleMaskIndexedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(sampleMaskIndexedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("texRenderbufferNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texRenderbufferNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteFencesNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteFencesNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("finishFenceNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(finishFenceNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("genFencesNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genFencesNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFenceivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFenceivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isFenceNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isFenceNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("setFenceNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(setFenceNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("testFenceNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(testFenceNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("fragmentCoverageColorNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fragmentCoverageColorNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramNamedParameterdvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramNamedParameterdvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramNamedParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramNamedParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programNamedParameter4dNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programNamedParameter4dNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programNamedParameter4fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programNamedParameter4fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("blitFramebufferNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(blitFramebufferNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorageMultisampleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorageMultisampleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderbufferStorageMultisampleCoverageNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderbufferStorageMultisampleCoverageNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programVertexLimitNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programVertexLimitNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastBarrierNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastBarrierNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastBlitFramebufferNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastBlitFramebufferNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastBufferSubDataNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastBufferSubDataNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastCopyBufferSubDataNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastCopyBufferSubDataNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastCopyImageSubDataNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastCopyImageSubDataNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastFramebufferSampleLocationsfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastFramebufferSampleLocationsfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastGetQueryObjecti64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastGetQueryObjecti64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastGetQueryObjectivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastGetQueryObjectivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastGetQueryObjectui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastGetQueryObjectui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastGetQueryObjectuivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastGetQueryObjectuivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("multicastWaitSyncNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multicastWaitSyncNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("renderGpuMaskNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(renderGpuMaskNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameterI4iNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameterI4iNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameterI4ivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameterI4ivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameterI4uiNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameterI4uiNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParameterI4uivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParameterI4uivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParametersI4ivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParametersI4ivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programEnvParametersI4uivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programEnvParametersI4uivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameterI4iNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameterI4iNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameterI4ivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameterI4ivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameterI4uiNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameterI4uiNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParameterI4uivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParameterI4uivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParametersI4ivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParametersI4ivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programLocalParametersI4uivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programLocalParametersI4uivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformi64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformi64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getUniformui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getUniformui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform1ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform1ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform2ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform2ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform3ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform3ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniform4ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniform4ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform1ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform1ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform2ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform2ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform3ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform3ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniform4ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniform4ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribDivisorNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribDivisorNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getInternalformatSampleivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getInternalformatSampleivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2x3fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2x3fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix2x4fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix2x4fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3x2fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3x2fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix3x4fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix3x4fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4x2fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4x2fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformMatrix4x3fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformMatrix4x3fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginOcclusionQueryNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginOcclusionQueryNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteOcclusionQueriesNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteOcclusionQueriesNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("endOcclusionQueryNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endOcclusionQueryNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("genOcclusionQueriesNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genOcclusionQueriesNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getOcclusionQueryivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getOcclusionQueryivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getOcclusionQueryuivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getOcclusionQueryuivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isOcclusionQueryNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isOcclusionQueryNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programBufferParametersIivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programBufferParametersIivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programBufferParametersIuivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programBufferParametersIuivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programBufferParametersfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programBufferParametersfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("coverFillPathInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(coverFillPathInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("coverFillPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(coverFillPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("coverStrokePathInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(coverStrokePathInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("coverStrokePathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(coverStrokePathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("deletePathsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deletePathsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("genPathsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genPathsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathColorGenfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathColorGenfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathColorGenivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathColorGenivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathCommandsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathCommandsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathCoordsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathCoordsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathDashArrayNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathDashArrayNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathLengthNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathLengthNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathMetricRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathMetricRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathMetricsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathMetricsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathSpacingNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathSpacingNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathTexGenfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathTexGenfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getPathTexGenivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getPathTexGenivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramResourcefvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramResourcefvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("interpolatePathsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(interpolatePathsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isPointInFillPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isPointInFillPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isPointInStrokePathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isPointInStrokePathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixLoad3x2fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixLoad3x2fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixLoad3x3fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixLoad3x3fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixLoadTranspose3x3fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixLoadTranspose3x3fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixMult3x2fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixMult3x2fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixMult3x3fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixMult3x3fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("matrixMultTranspose3x3fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(matrixMultTranspose3x3fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathColorGenNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathColorGenNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathCommandsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathCommandsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathCoordsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathCoordsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathCoverDepthFuncNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathCoverDepthFuncNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathDashArrayNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathDashArrayNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathFogGenNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathFogGenNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathGlyphIndexArrayNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathGlyphIndexArrayNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathGlyphRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathGlyphRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathGlyphsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathGlyphsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathMemoryGlyphIndexArrayNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathMemoryGlyphIndexArrayNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathParameterfNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathParameterfNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathParameteriNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathParameteriNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathStencilDepthOffsetNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathStencilDepthOffsetNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathStencilFuncNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathStencilFuncNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathStringNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathStringNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathSubCommandsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathSubCommandsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathSubCoordsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathSubCoordsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pathTexGenNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pathTexGenNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointAlongPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointAlongPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programPathFragmentInputGenNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programPathFragmentInputGenNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilFillPathInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilFillPathInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilFillPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilFillPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilStrokePathInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilStrokePathInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilStrokePathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilStrokePathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilThenCoverFillPathInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilThenCoverFillPathInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilThenCoverFillPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilThenCoverFillPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilThenCoverStrokePathInstancedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilThenCoverStrokePathInstancedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("stencilThenCoverStrokePathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(stencilThenCoverStrokePathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("transformPathNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(transformPathNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("flushPixelDataRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flushPixelDataRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pixelDataRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pixelDataRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameteriNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameteriNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonModeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonModeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideoi64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideoi64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideoivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideoivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideoui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideoui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideouivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideouivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("presentFrameDualFillNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(presentFrameDualFillNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("presentFrameKeyedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(presentFrameKeyedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("primitiveRestartIndexNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(primitiveRestartIndexNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("primitiveRestartNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(primitiveRestartNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("combinerInputNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(combinerInputNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("combinerOutputNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(combinerOutputNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("combinerParameterfNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(combinerParameterfNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("combinerParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(combinerParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("combinerParameteriNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(combinerParameteriNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("combinerParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(combinerParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("finalCombinerInputNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(finalCombinerInputNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCombinerInputParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCombinerInputParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCombinerInputParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCombinerInputParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCombinerOutputParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCombinerOutputParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCombinerOutputParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCombinerOutputParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFinalCombinerInputParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFinalCombinerInputParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFinalCombinerInputParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFinalCombinerInputParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("combinerStageParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(combinerStageParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getCombinerStageParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getCombinerStageParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferSampleLocationsfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferSampleLocationsfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("namedFramebufferSampleLocationsfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(namedFramebufferSampleLocationsfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getBufferParameterui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getBufferParameterui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getIntegerui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getIntegerui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getNamedBufferParameterui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getNamedBufferParameterui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isBufferResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isBufferResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isNamedBufferResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isNamedBufferResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeBufferNonResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeBufferNonResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeBufferResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeBufferResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeNamedBufferNonResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeNamedBufferNonResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("makeNamedBufferResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(makeNamedBufferResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programUniformui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programUniformui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("uniformui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(uniformui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexImage3DNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexImage3DNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("compressedTexSubImage3DNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(compressedTexSubImage3DNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("copyTexSubImage3DNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(copyTexSubImage3DNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureLayerNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureLayerNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage3DNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage3DNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("texSubImage3DNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texSubImage3DNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureBarrierNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureBarrierNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage2DMultisampleCoverageNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage2DMultisampleCoverageNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("texImage3DMultisampleCoverageNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texImage3DMultisampleCoverageNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureImage2DMultisampleCoverageNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureImage2DMultisampleCoverageNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureImage2DMultisampleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureImage2DMultisampleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureImage3DMultisampleCoverageNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureImage3DMultisampleCoverageNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("textureImage3DMultisampleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(textureImage3DMultisampleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("activeVaryingNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(activeVaryingNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginTransformFeedbackNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginTransformFeedbackNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferBaseNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferBaseNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferOffsetNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferOffsetNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindBufferRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindBufferRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("endTransformFeedbackNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endTransformFeedbackNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getActiveVaryingNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getActiveVaryingNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTransformFeedbackVaryingNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTransformFeedbackVaryingNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVaryingLocationNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVaryingLocationNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("transformFeedbackAttribsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(transformFeedbackAttribsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("transformFeedbackVaryingsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(transformFeedbackVaryingsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindTransformFeedbackNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindTransformFeedbackNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteTransformFeedbacksNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteTransformFeedbacksNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("drawTransformFeedbackNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(drawTransformFeedbackNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("genTransformFeedbacksNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genTransformFeedbacksNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isTransformFeedbackNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isTransformFeedbackNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("pauseTransformFeedbackNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pauseTransformFeedbackNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("resumeTransformFeedbackNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(resumeTransformFeedbackNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vDPAUFiniNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vDPAUFiniNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vDPAUInitNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vDPAUInitNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("flushVertexArrayRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(flushVertexArrayRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexArrayRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexArrayRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribLi64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribLi64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribLui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribLui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL1ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL1ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL2ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL2ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL3ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL3ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4i64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4i64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4i64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4i64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4ui64NV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4ui64NV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribL4ui64vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribL4ui64vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribLFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribLFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bufferAddressRangeNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bufferAddressRangeNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("colorFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(colorFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("edgeFlagFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(edgeFlagFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogCoordFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogCoordFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("indexFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(indexFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("normalFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normalFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("secondaryColorFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(secondaryColorFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("texCoordFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texCoordFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribIFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribIFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexFormatNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexFormatNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("areProgramsResidentNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(areProgramsResidentNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindProgramNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindProgramNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("deleteProgramsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(deleteProgramsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("executeProgramNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(executeProgramNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("genProgramsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(genProgramsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramParameterdvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramParameterdvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramStringNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramStringNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getProgramivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getProgramivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTrackMatrixivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTrackMatrixivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribPointervNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribPointervNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribdvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribdvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVertexAttribivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVertexAttribivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isProgramNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isProgramNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("loadProgramNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(loadProgramNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameter4dNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameter4dNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameter4dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameter4dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameter4fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameter4fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameter4fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameter4fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameters4dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameters4dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("programParameters4fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(programParameters4fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("requestResidentProgramsNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(requestResidentProgramsNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("trackMatrixNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(trackMatrixNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1dNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1dNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1sNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1sNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib1svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib1svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2dNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2dNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2sNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2sNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib2svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib2svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3dNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3dNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3sNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3sNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib3svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib3svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4dNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4dNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4fNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4fNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4sNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4sNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4ubNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4ubNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttrib4ubvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttrib4ubvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribPointerNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribPointerNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs1dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs1dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs1fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs1fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs1svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs1svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs2dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs2dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs2fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs2fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs2svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs2svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs3dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs3dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs3fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs3fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs3svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs3svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs4dvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs4dvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs4fvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs4fvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs4svNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs4svNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("vertexAttribs4ubvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(vertexAttribs4ubvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("beginVideoCaptureNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(beginVideoCaptureNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindVideoCaptureStreamBufferNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindVideoCaptureStreamBufferNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("bindVideoCaptureStreamTextureNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(bindVideoCaptureStreamTextureNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("endVideoCaptureNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endVideoCaptureNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideoCaptureStreamdvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideoCaptureStreamdvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideoCaptureStreamfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideoCaptureStreamfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideoCaptureStreamivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideoCaptureStreamivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getVideoCaptureivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getVideoCaptureivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("videoCaptureNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(videoCaptureNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("videoCaptureStreamParameterdvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(videoCaptureStreamParameterdvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("videoCaptureStreamParameterfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(videoCaptureStreamParameterfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("videoCaptureStreamParameterivNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(videoCaptureStreamParameterivNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRangeArrayfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRangeArrayfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRangeIndexedfNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRangeIndexedfNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableiNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableiNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableiNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableiNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFloati_vNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFloati_vNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("isEnablediNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isEnablediNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("scissorArrayvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scissorArrayvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("scissorIndexedNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scissorIndexedNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("scissorIndexedvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scissorIndexedvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportArrayvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportArrayvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportIndexedfNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportIndexedfNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportIndexedfvNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportIndexedfvNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("viewportSwizzleNV").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(viewportSwizzleNV)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureMultiviewOVR").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureMultiviewOVR)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferTextureMultisampleMultiviewOVR").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferTextureMultisampleMultiviewOVR)).ToLocalChecked());
  Nan::Set(target, Nan::New("alphaFuncQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(alphaFuncQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("disableDriverControlQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(disableDriverControlQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("enableDriverControlQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(enableDriverControlQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("getDriverControlStringQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getDriverControlStringQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("getDriverControlsQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getDriverControlsQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetBufferPointervQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetBufferPointervQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetBuffersQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetBuffersQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetFramebuffersQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetFramebuffersQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetRenderbuffersQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetRenderbuffersQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetTexLevelParameterivQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetTexLevelParameterivQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetTexSubImageQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetTexSubImageQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetTexturesQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetTexturesQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extTexObjectStateOverrideiQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extTexObjectStateOverrideiQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetProgramBinarySourceQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetProgramBinarySourceQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetProgramsQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetProgramsQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extGetShadersQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extGetShadersQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("extIsProgramBinaryQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(extIsProgramBinaryQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferFoveationConfigQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferFoveationConfigQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferFoveationParametersQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferFoveationParametersQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("framebufferFetchBarrierQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(framebufferFetchBarrierQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("endTilingQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(endTilingQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("startTilingQCOM").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(startTilingQCOM)).ToLocalChecked());
  Nan::Set(target, Nan::New("alphaFuncx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(alphaFuncx)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearColorx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearColorx)).ToLocalChecked());
  Nan::Set(target, Nan::New("clearDepthx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clearDepthx)).ToLocalChecked());
  Nan::Set(target, Nan::New("color4x").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(color4x)).ToLocalChecked());
  Nan::Set(target, Nan::New("depthRangex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(depthRangex)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogx)).ToLocalChecked());
  Nan::Set(target, Nan::New("fogxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(fogxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("frustumf").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(frustumf)).ToLocalChecked());
  Nan::Set(target, Nan::New("frustumx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(frustumx)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightModelx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightModelx)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightModelxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightModelxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightx)).ToLocalChecked());
  Nan::Set(target, Nan::New("lightxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lightxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("lineWidthx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(lineWidthx)).ToLocalChecked());
  Nan::Set(target, Nan::New("loadMatrixx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(loadMatrixx)).ToLocalChecked());
  Nan::Set(target, Nan::New("materialx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(materialx)).ToLocalChecked());
  Nan::Set(target, Nan::New("materialxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(materialxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("multMatrixx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multMatrixx)).ToLocalChecked());
  Nan::Set(target, Nan::New("multiTexCoord4x").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(multiTexCoord4x)).ToLocalChecked());
  Nan::Set(target, Nan::New("normal3x").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(normal3x)).ToLocalChecked());
  Nan::Set(target, Nan::New("orthof").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(orthof)).ToLocalChecked());
  Nan::Set(target, Nan::New("orthox").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(orthox)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointSizex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointSizex)).ToLocalChecked());
  Nan::Set(target, Nan::New("polygonOffsetx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(polygonOffsetx)).ToLocalChecked());
  Nan::Set(target, Nan::New("rotatex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(rotatex)).ToLocalChecked());
  Nan::Set(target, Nan::New("sampleCoveragex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(sampleCoveragex)).ToLocalChecked());
  Nan::Set(target, Nan::New("scalex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(scalex)).ToLocalChecked());
  Nan::Set(target, Nan::New("texEnvx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texEnvx)).ToLocalChecked());
  Nan::Set(target, Nan::New("texEnvxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texEnvxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterx)).ToLocalChecked());
  Nan::Set(target, Nan::New("translatex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(translatex)).ToLocalChecked());
  Nan::Set(target, Nan::New("clipPlanef").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clipPlanef)).ToLocalChecked());
  Nan::Set(target, Nan::New("clipPlanex").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(clipPlanex)).ToLocalChecked());
  Nan::Set(target, Nan::New("getFixedv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getFixedv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getLightxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getLightxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMaterialxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMaterialxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexEnvxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexEnvxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getTexParameterxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getTexParameterxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterx").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterx)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointParameterxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointParameterxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("pointSizePointerOES").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(pointSizePointerOES)).ToLocalChecked());
  Nan::Set(target, Nan::New("texParameterxv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(texParameterxv)).ToLocalChecked());
  Nan::Set(target, Nan::New("getExtensionREGAL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getExtensionREGAL)).ToLocalChecked());
  Nan::Set(target, Nan::New("isSupportedREGAL").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(isSupportedREGAL)).ToLocalChecked());
  Nan::Set(target, Nan::New("addressSpace").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(addressSpace)).ToLocalChecked());
  Nan::Set(target, Nan::New("dataPipe").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(dataPipe)).ToLocalChecked());
  Nan::Set(target, Nan::New("getMPEGQuantTableubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(getMPEGQuantTableubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("mPEGQuantTableubv").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(mPEGQuantTableubv)).ToLocalChecked());
  Nan::Set(target, Nan::New("addSwapHintRectWIN").ToLocalChecked(),
    Nan::GetFunction(Nan::New<FunctionTemplate>(addSwapHintRectWIN)).ToLocalChecked());

}

NODE_MODULE(gljs, InitAll)
